:PROPERTIES:
:ID:       a5886419-b2dd-4a02-a91d-0bc392fb3b88
:END:
#+title: Python: Environment Management

Everytime I revisit this, it improves significantly ... but it's still a mess
for someone who hasn't coded a lot of python.

But it's honestly not that bad. There's just a lot of ecosystem sprawl and it's
hard to assess with zero name-recognition to any of it.

[[file:img/python_environment.png]]

It's a well-known issue: see [[https://drewdevault.com/2021/11/16/Python-stop-screwing-distros-over.html][Python: Please stop screwing over Linux distros]],
but honestly it's improved a lot. It mostly results from a combination of
python's popularity, a notebook's need for version-specific requirements and
python's ubiquity, being essential to modern linux/mac systems. This last point
means containerization and locked dependencies are essential.

I've solved this two times in the past two years, only to lack sufficient time
to work with notebooks. Google Colab works well, but lacks the speed/flexibility
& precision I need when the notebook requires external services.  And I've
probably worked though this ten times in the past ten years as the norms shifted
through:

+ vm/linux/mac
+ virtualenv
+ docker: storage requirements are annoying and maintaining image persistence
  through system reinstalls is a bit of a problem (i was really too
  unemployed/isolated to even use Docker, though I initially used it in 2013)
+ pipenv/etc
+ back to virtualenv, since it's core
+ oh poetry: looks a little too high-level essential
+ guix profile + pipenv: works until you need multiple python versions?
+ hmmm oh, poetry! but it doesn't work well for notebook dependencies

You may find some simple solution where you never really have the need for
precision/reproducibility in python environments ... if you're not using tools
like the following,

+ Blender-as-a-Module
+ Tensorflow with CUDA
+ The fucking =LD_LIBRARY_PATH= and =patchelf= thing
+ Builds of Atlas/Lapack, perhaps using AMD's AOCC compiler/optimizer

I think the answer for me in 2023 is just =virtualenv + direnv=, perhaps
including the possibility for poetry where it's found in a package.

Oh and I really don't like jupyter notebooks. The benefits and caveats are
similar to those for "literate programming" -- they're great when you want to
communicate your work or in other limited use cases. But I need autocompletion
and I like REPL's -- oh and brittle/new OS installs basically break anything and
duct tape connecting your editor to your python environments. With guix/nix, you
/maybe/ take slower steps forward, but you basically never take steps backwards.

I guess I basically need a scheme for naming/organizing notebook environments.

* Direnv + Venv

** Pros
+ Simple and very core.
+ Direnv is a self-contained Go library, with emphasis on "self-contained."

** Cons
+ Doesn't necessarily handle Python environments.

* Poetry ([[https://python-poetry.org/docs/][docs]])

Nice when working on packages. IMO, doesn't really work with notebook
environments.

** Pros
+ suffient containerization

** Cons
+ A little cumbersome, especially when managing Guix & Arch envs
+ a new abstraction set has appeared.

* Guix

If I were working with python often and using Guix, I would create something
like a single channel that only has Guix/Nonguix as channel dependencies.

** Pros
+ Totally reproducible environments

** Cons
+ Guix python packages are old. This is in the "cons" for me, but is not too bad
  in itself.

* Nix

** Pros
+ Combines well with poetry using [[https://github.com/nix-community/poetry2nix][nix-community/poetry2nix]]

** Cons
+ Requires Nix, which IMO has advantages/disadvantages wrt Guix.
+ I don't have Nix on my systems. Perhaps in the future.

* Pipenv ([[https://pipenv.pypa.io/en/latest/index.html][docs]])

** Pros
+ Works alright.
+ It's a fairly thin set of tools, reuses existing abstractions, mostly.

** Cons
+ A little cumbersome, especially when managing Guix & Arch env

* Docker

** Pros
+ Works well, even for complex GPU things when AUR can't get you a =clinfo= that
  works ...
+ The Docker transient buffers in emacs are very helpful. ALL of the commands
  are logged.


#+begin_quote
it's complicated, I know... sometimes it be like that, sometimes it do ... i've
been here before.
#+end_quote

** Cons

+ Requires planning (paths, volumes, mounts).
+ A little messy. Requires upkeep
+ Usually requires more knowledge about your builds
+ Your projects can't easily be integrated into one another.
