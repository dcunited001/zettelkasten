:PROPERTIES:
:ID:       40dcb082-52a4-436c-b13a-975d3bd27cef
:END:
#+TITLE: Orange Pi: Firmware, u-boot, rkdevtool and SPI Flash
#+CATEGORY: slips
#+TAGS:

#+begin_quote
The =rkdeveloptool= commands here just provide a reference for options. They
aren't necessarily configuring anything. Just adding this caveat.
#+end_quote

* Roam
+ [[id:35cdd063-b646-4141-83ea-fcac8b337875][Orange Pi]]
+ [[id:708d6f59-64ad-473a-bfbb-58d663bde4f0][IoT]]

* Docs
+ [[https://github.com/rockchip-linux/rkdeveloptool][rockchip-linux/rkdeveloptool]]
  - radxa: [[https://docs.radxa.com/en/rock5/lowlevel-development/bootloader_spi_flash?method=simple][Flash BootLoader to SPI Nor Flash]] and [[https://docs.radxa.com/en/compute-module/cm3/low-level-dev/rkdeveloptool][rkdeveloptool]]
+ Usage: [[https://github.com/rockchip-linux/u-boot/blob/2687dce2617032930f2c43fef349bdea694c6f68/doc/README.rockusb#L31-L47][update TF-A and u-boot]] (general) and for [[https://github.com/rockchip-linux/u-boot/blob/2687dce2617032930f2c43fef349bdea694c6f68/board/rockchip/evb_rk3399/README#L94-L113][evb_rk3399]]
+ Instructions for [[http://www.orangepi.org/orangepiwiki/index.php/Orange_Pi_5_Plus#How_to_use_the_debugging_serial_port][clearing SPI Flash on Windows]] (using Gui RK Dev Tool)
  - the device setup is the same
+ [[https://en.wikipedia.org/wiki/GUID_Partition_Table#Partition_table_header_(LBA_1)][GPT: Partition table header]]



* Resources

** Device Tree

+ [[https://www.horan.hk/blog/firmware-extract-gpl-part2/][Methods of extracting firmware from IoT devices]] (part 2)
+ [[https://genodians.org/nfeske/2021-05-19-pine-dts-pruning][visualize device trees]] with =tools/dts/extract= script (via [[https://github.com/genodelabs/genode/tree/master/tool/dts][genodelabs/genode]])
  - can't quite get it to work, though =extract= does select subtrees.

** Armbian forums

+ [[https://forum.armbian.com/topic/49922-orange-pi-5-bricked/][Orange Pi 5 Bricked]]
+ [[https://forum.armbian.com/topic/26418-maskrom-erase-spi/#comment-175057][Maskrom / erase SPI]]
  - This thread seems to imply you can use the Radxa SPL loader image for Orange
    Pi. By size, the two bins are similar. However, [[https://medium.com/@tunacici7/first-stage-loaders-bios-u-efi-iboot1-u-boot-spl-5c0bee7feb15][their devicetrees may
    differ]]... I'm assuming the =rkdeveloptool= uses functionality in the SPI
    protocol (or MaskROM) to acquire some details.

* Terms

+ TFA :: Trusted Firmware
+ U-boot :: The 2nd stage bootloader for IoT devices
+ SPL Loader :: A program to "flash" to a board in MaskROM mode via
  =rkdeveloptool= which permits some device interactivity
  - this can be built from source, but you still need an =idbloader= and =uboot= to
    flash to SPI
  - there's a miniloader from the orangepi downloads under the official tools.
    see the wiki for more information


* Round Two
:PROPERTIES:
:header-args+: :var obtmp=(or (bound-and-true-p ob@orange_pi_firmware_u_boot_rkdevtool_and_spi_flash) (setq ob@orange_pi_firmware_u_boot_rkdevtool_and_spi_flash (make-temp-file "roam-" t)))
:END:

** Rationale

Still want to see what blobs are going on here. These are nice devices, but...

+ There's a lot of native chinese docs/guides without translation
  - Most guides/projects just accept upstream linux blobs and recycle the same
    binaries from OPi/Rockchip. It's unclear how to get on a device and clarify
    the extant hardware functionality for a given Linux image/firmware
  - Determining whether the necessary firmware support is an issue would be nice
    to do quickly.
+ I need to be able to determine whether/how the NPU stuff is working
+ I'm just curioius.

*** Reset SPI to newer U-Boot image

The newer photonvision build removes firmware from the image. That definitely
needs to at least be in the U-Boot image in SPI Flash.

+ Download [[https://www.armbian.com/orange-pi-5-plus/][Armbian Server for OrangePi 5 Plus]]
+ use =nix shell nixpkgs#usbimager= to get [[https://gitlab.com/bztsrc/usbimager][bztsrc/usbimager]]
+ Follow [[https://docs.armbian.com/User-Guide_Getting-Started/#how-to-prepare-a-sd-card][these directions from Armbian]] to burn the image onto a flash card.

** SPL Loader

*** Loading the Loader

**** Overview

If it's already built, use =nix shell nixpkgs#rkdeveloptool=

+ get =binwalk= from Guix: v3 wasn't so great
  - Guix has =v2.3.3=, Nix has the "rust rewrite" =v3.1.0=

#+begin_src shell
img=rkbin/rk3588_spl_loader_v1.19.113.bin
rkdevelop ld # ensure device in MaskROM and accessible
rkdevelop db $img # download the SPL Loader to the device
#+end_src

**** Setting up =udev= rules to avoid =root=

see [[https://github.com/dcunited001/ellipsis/blob/9562939d05c834c4f0b4d206e3e1bfa98705e076/nixos/modules/nixos/hardware/rkdeveloptool.nix][nixos/modules/nixos/hardware/rkdeveloptool.nix]]

#+begin_src nix
{ config, lib, pkgs, ... }:
let
  # rockchip's udev rules haven't been updated since 2021
  #
  # - they don't include model 350b for the rk3588 (orangepi 5)
  # - they set everything to 666 and writable by users
  #
  # this is based on the scdaemon service

  rkdeveloptoolRev = "304f073752fd25c854e1bcf05d8e7f925b1f4e14";

  rockchipRules = pkgs.fetchurl {
    url =
      "https://raw.githubusercontent.com/rockchip-linux/rkdeveloptool/${rkdeveloptoolRev}/99-rk-rockusb.rules";
    sha256 = "0x1nkvfzidzjx0dis9xkw2yw09bv81zqkby12sbhlmgs607a68lf";
  };

  destination = "99-rk-rockusb.rules";

  # ran `udevadm verify --resolve-names=never --no-style 99-rk-rockusb.rules.test`
  rockchipUdevRulesPkg = pkgs.runCommand "rockchip-udev-rules" { } ''
    loc="$out/lib/udev/rules.d/"
    mkdir -p "''${loc}"
    sed 's/LABEL="end_rules"/# RK3588 \nATTRS{idVendor}=="2207", ATTRS{idProduct}=="350b", MODE="0660", GROUP="plugdev"\n\nLABEL="end_rules"/g' "${rockchipRules}" > "rkrules.1"
    sed 's/ MODE="0666", GROUP="users"/ MODE="0660", GROUP="plugdev"/g' "rkrules.1" > "rkrules.2"
    cp "rkrules.2" "''${loc}/${destination}"
  '';

  # too many derivations using sed ... but whatever. nicer facilities would
  # require the full stdenv.mkDerivation
  cfg = config.hardware.rkdeveloptool;
in {
  options.hardware.rkdeveloptool = {
    enable = lib.mkEnableOption "udev rules for rkdeveloptool and Rockchip";
    # don't install this by default
    # package = lib.mkDefault pkgs.rkdeveloptool;
  };

  config = lib.mkIf cfg.enable {
    services.udev.packages = [ rockchipUdevRulesPkg ];
    users.groups.plugdev = { };
  };
}
#+end_src

Then add the module, enable it and build the image, but before =nixos-rebuild
switch=, validate the udev rules by finding the result and running:

#+begin_src shell
udevadm verify --resolve-names=never \
    /nix/store/$systemDerivation/etc/udev/rules.d/99-rk-rockusb.rules
#+end_src
***** Problem

Getting this failure on =strace -e all rkdeveloptool dl $img= where it tries to
write and fails.

#+begin_example
lseek(8, 0, SEEK_SET) = 0
read(8,              "LDR f\0\v\1\0\0\0\0\0\1\351\7\n\t\10/\"8853\2f\0\0\09\1"..., 491520) = 491520
read(8,              "\265\360\342\301P\306$\236\22\367X\216@\271\267\276\213\372%\335t\327oYF~\23A\356\375\365\221"..., 4096) = 448
close(8) = 0
openat(AT_FDCWD,     "/dev/bus/usb/005/008", O_RDWR|O_CLOEXEC) = -1 EACCES (Permission denied)
munmap(0x7f3f55291000, 495616) = 0
fstat(1, {st_mode=S_IFCHR|0620, st_rdev=makedev(0x88, 0x9), ...}) = 0
write(1,             "\33[30;41mCreating Comm Object fai"..., 42) = 42
exit_group(-255)                        = ?
#+end_example

Checked =sudo dmesg= and found =vendor=2207= =product=350b=

#+begin_example text
usb 5-4: new high-speed USB device number 8 using xhci_hcd
usb 5-4: New USB device found, idVendor=2207, idProduct=350b, bcdDevice= 1.00
usb 5-4: New USB device strings: Mfr=0, Product=0, SerialNumber=0
#+end_example

***** Check =udev=

#+begin_src shell
thisdev=/dev/bus/usb/005/008
udevadm info $thisdev # this dumps everything

# to grab for a script (still requires knowing the device name/path)
vendor=$(udevadm info -q property --property="ID_VENDOR" --value $thisdev)
model=$(udevadm info -q property --property="ID_MODEL" --value $thisdev)
#+end_src

Searched within =./nixos/modules= in =nixos/nixpkgs= for =plugdev=

+ found =rtl-sdr=, loaded via =nix shell nixpkgs#rtl-sdr=
+ the package for that modules runs some replacements on the =udev= rules to add
  the =plugdev= group
+ used =env | grep rtl-sdr= to find a =$nixBinPath= to check
+ then ran =cat $nixBinPath/../etc/rules.d/rtl-sdr.rules=

**** Backup existing loader
*** rockchip-linux/rkbin =74213af1=

This builds the SPL Loader, which programs the RK3588 to be booted by a host
computer, according to gemini.

**** Building the loader

We're supposed to run the blob =./tools/boot_merger=

+ After clone, run =./tools/boot_merger RKBOOT/RK3588MINIALL.ini=
+ This creates =rk3588_spl_loader_v1.19.113.bin=, which is specified by the =ini=

This shows that quite a bit differs.

#+begin_src shell :eval never
rkbin=rkbin/rk3588_spl_loader_v1.19.113.bin
radxa=radxa/RADXA_rk3588_spl_loader_v1.15.113.bin
diffoscope $rkbin $radxa
#+end_src

The file isn't ELF. Instead it begins with =LDR=, which i think is a "boot stream"
... so i guess i was correct in thinking the =MaskROM= pauses the boot. The loader
file then contains something the CPU can interpret at that stage.

#+begin_src shell
head -c3 rkbin/rk3588_spl_loader_v1.19.113.bin
#+end_src

#+RESULTS:
: LDR


**** Base RK35888

#+begin_src shell :results output verbatim code :wrap example conf
cat $obtmp/rkbin/RKBOOT/RK3588MINIALL.ini
#+end_src

#+RESULTS:
#+begin_example conf
[CHIP_NAME]
NAME=RK3588
[VERSION]
MAJOR=1
MINOR=11
[CODE471_OPTION]
NUM=1
Path1=bin/rk35/rk3588_ddr_lp4_2112MHz_lp5_2400MHz_v1.19.bin
Sleep=1
[CODE472_OPTION]
NUM=1
Path1=bin/rk35/rk3588_usbplug_v1.11.bin
[LOADER_OPTION]
NUM=2
LOADER1=FlashData
LOADER2=FlashBoot
FlashData=bin/rk35/rk3588_ddr_lp4_2112MHz_lp5_2400MHz_v1.19.bin
FlashBoot=bin/rk35/rk3588_spl_v1.13.bin
[OUTPUT]
PATH=rk3588_spl_loader_v1.19.113.bin
[SYSTEM]
NEWIDB=true
[FLAG]
471_RC4_OFF=true
RC4_OFF=true
[BOOT1_PARAM]
WORD_0=0x0
WORD_1=0x0
WORD_2=0x0
WORD_3=0x0
WORD_4=0x0
WORD_5=0x0
WORD_6=0x0
WORD_7=0x0
#+end_example

***** IPC

#+begin_src shell :results output verbatim code :wrap example diff
diff $obtmp/rkbin/RKBOOT/RK3588MINIALL{,_IPC}.ini
#+end_src

#+RESULTS:
#+begin_example diff
20c20,21
< PATH=rk3588_spl_loader_v1.19.113.bin
---
> PATH=rk3588_download_v1.19.113.bin
> IDB_PATH=rk3588_idblock_v1.19.113.img
25a27
> CREATE_IDB=true
#+end_example

***** PCIE_EP

#+begin_src shell :results output verbatim code :wrap example diff
diff $obtmp/rkbin/RKBOOT/RK3588MINIALL{,_PCIE_EP}.ini
#+end_src

#+RESULTS:
#+begin_example diff
17,18c17,18
< FlashData=bin/rk35/rk3588_ddr_lp4_2112MHz_lp5_2400MHz_v1.19.bin
< FlashBoot=bin/rk35/rk3588_spl_v1.13.bin
---
> FlashData=bin/rk35/rk3588_pcie_v2.20.bin
> FlashBoot=bin/rk35/rk3588_pcie_v2.20.bin
20c20
< PATH=rk3588_spl_loader_v1.19.113.bin
---
> PATH=rk3588_pcie_loader_v2.20.bin
26,34c26
< [BOOT1_PARAM]
< WORD_0=0x0
< WORD_1=0x0
< WORD_2=0x0
< WORD_3=0x0
< WORD_4=0x0
< WORD_5=0x0
< WORD_6=0x0
< WORD_7=0x0
---
> CREATE_IDB=true
#+end_example

***** RAMBOOT

Nics.... =null{0,1}.bin=

#+begin_src shell :results output verbatim code :wrap example diff
diff $obtmp/rkbin/RKBOOT/RK3588MINIALL{,_RAMBOOT}.ini
#+end_src

#+RESULTS:
#+begin_example diff
5c5
< MINOR=11
---
> MINOR=6
12c12
< Path1=bin/rk35/rk3588_usbplug_v1.11.bin
---
> Path1=bin/rk35/rk3588_ramboot_v1.06.bin
17,18c17,18
< FlashData=bin/rk35/rk3588_ddr_lp4_2112MHz_lp5_2400MHz_v1.19.bin
< FlashBoot=bin/rk35/rk3588_spl_v1.13.bin
---
> FlashData=bin/rk35/rk3588_ramboot_null0.bin
> FlashBoot=bin/rk35/rk3588_ramboot_null1.bin
20c20
< PATH=rk3588_spl_loader_v1.19.113.bin
---
> PATH=rk3588_ramboot_loader_v1.19.106.bin
26,34d25
< [BOOT1_PARAM]
< WORD_0=0x0
< WORD_1=0x0
< WORD_2=0x0
< WORD_3=0x0
< WORD_4=0x0
< WORD_5=0x0
< WORD_6=0x0
< WORD_7=0x0
#+end_example
* First Go
** Setup

Run =guix shell rkdeveloptool binwalk= and run =rkdeveloptool -h= to see options

I was going to run the commands in an org-babel session ... but that's probably
a bad idea.

** Connect Device

+ Connect USB-C to =USB-C Data=
+ Press/hold =MaskROM=
+ Connect USB-C to =USB-C Power=, power on
+ Release =MaskROM=

** Connect rkdeveloptool

Check that device is available

#+begin_src sh :eval no
rkdeveloptool ld
# DevNo=1 Vid=0x2207,Pid=0x350b,LocationID=102    Maskrom
#+end_src

*** Download SPL loader

Everything except =ld= fails.

+ According to [[https://github.com/rockchip-linux/rkdeveloptool/issues/69][#69]], you need to run =db= first to push the =loader.bin= onto the
  board. I originally assumed this would extract [part of] the firmware, but
  this initializes the hardware with an SPL loader.
+ I guess the MaskROM mode halts the boot process. When you run =db $loader=,
  you're sending an alternate first-phase bootloader.
+ AFAIK, the =ul $loader= command will burn the image into SPI flash. Otherwise,
  it's just running the SPL =$loader= as a program.

*** Check device

After =db $loader=, try =rkdeveloptool td= to check the device (not sure what tests
are actually run here)

* Usage

+ rkdeveloptool db $image :: save boot from device to bootloader
+ rkdeveloptool wl $sectorStart $sectorLength :: write file to bootloader
  storage



Chip Info

#+begin_example shell
rkdeveloptool rci
# Chip Info:  38 38 35 33 A0 1 2A 2 0 80 3E 0 10 10 64 69

rkdeveloptool rcb
# Capability:2F 03 00 00 00 00 00 00
# Direct LBA:     enabled
# Vendor Storage: enabled
# First 4m Access:        enabled
# Read LBA:       enabled
# Read Com Log:   enabled
# Read IDB Config:        enabled
# New IDB:        enabled
#+end_example

*** Active Storage

=eMMC= storage defaults to active.

+ The radxa guide implies that storage can't be selected by hardware (may be a
  limitation of their hardware or their SPL Loader bin)

#+begin_example shell
rkdeveloptool rid
# Flash ID: 45 4D 4D 43 20

rkdeveloptool rfi
# Flash Info:
#         Manufacturer: SAMSUNG, value=00
#         Flash Size: 238552 MB
#         Flash Size: 488554496 Sectors
#         Block Size: 512 KB
#         Page Size: 2 KB
#         ECC Bits: 0
#         Access Time: 40
#         Flash CS: Flash<0>

rkdeveloptool ppt
# Not found any partition table!
#+end_example

Change to =SPI Nor=:

#+begin_example shell
# ChangeStorage:          cs [storage: 1=EMMC, 2=SD, 9=SPINOR]
rkdeveloptool cs 9
#+end_example

Dump the partition table, which gives the LBA Offsets

#+begin_example shell
rkdeveloptool ppt
# **********Partition Info(GPT)**********
# NO  LBA       Name
# 00  00000040  idbloader
# 01  00000400  uboot
#+end_example

Check the =SPI Nor= data

#+begin_example shell
rkdeveloptool rid
# Flash ID: 4E 4F 52 20 20

rkdeveloptool rfi
# Flash Info:
#        Manufacturer: SAMSUNG, value=00
#        Flash Size: 16 MB
#        Flash Size: 32768 Sectors
#        Block Size: 64 KB
#        Page Size: 2 KB
#        ECC Bits: 0
#        Access Time: 40
#        Flash CS: Flash<0>
#+end_example

*** GPT Table

Extract the =MBR+GPT= Header.

+ 0x0000 sector :: MBR
+ 0x0001 sector :: GPT

#+begin_example sh
rkdeveloptool rl 0x0000 2 $img
# cat $img | xxd
#+end_example

Parse the header with =sfdisk -d $img= to display info on truncated disk .... hmmm
seems to validate some aspects of the disk.

#+begin_example yaml
# GPT PMBR size mismatch (8191 != 1) will be corrected by write.
label: dos
label-id: 0x00000000
device: 20250408_lba0.img
unit: sectors
grain: 512
sector-size: 512
20250408_lba0.img1 : start=           1, size=           1, type=ee
#+end_example

Extract the full image

#+begin_example sh
rkdeveloptool rl 0x0000 32768 $fullimg
#+end_example

Dump GPT header to json

#+begin_src sh :results output code :wrap src json :eval query
sfdisk --json $fullimg
#+end_src

#+RESULTS:
#+begin_src json
{
   "partitiontable": {
      "label": "gpt",
      "id": "FC962DFA-7504-4678-A999-D219793C10EC",
      "device": "full-spi.img",
      "unit": "sectors",
      "firstlba": 34,
      "lastlba": 8158,
      "sectorsize": 512,
      "partitions": [
         {
            "node": "full-spi.img1",
            "start": 64,
            "size": 960,
            "type": "0FC63DAF-8483-4772-8E79-3D69D8477DE4",
            "uuid": "9B647F18-6CFB-4F5C-B33D-9799543E1A02",
            "name": "idbloader"
         },{
            "node": "full-spi.img2",
            "start": 1024,
            "size": 6144,
            "type": "0FC63DAF-8483-4772-8E79-3D69D8477DE4",
            "uuid": "BF621326-6273-4F65-81A8-3AC2F0686FD7",
            "name": "uboot"
         }
      ]
   }
}
#+end_src

*** Binwalk

=binwalk -Me $fullimg=

#+begin_example text
Scan Time:     2025-04-08 19:02:25
Target File:   full-spi.img
MD5 Checksum:  9881c035932b9e31dc22be03c4700e80
Signatures:    411

DECIMAL       HEXADECIMAL     DESCRIPTION
--------------------------------------------------------------------------------
253624        0x3DEB8         CRC32 polynomial table, little endian
328280        0x50258         Flattened device tree, size: 6809 bytes, version: 17
524288        0x80000         Flattened device tree, size: 1975 bytes, version: 17
1335116       0x145F4C        CRC32 polynomial table, little endian
1429259       0x15CF0B        Android bootimg, kernel size: 1919249152 bytes, kernel addr: 0x5F6C656E, ramdisk size: 1919181921 bytes, ramdisk addr: 0x5700635F, product name: ""
1997312       0x1E7A00        Flattened device tree, size: 21304 bytes, version: 17
2146304       0x20C000        Flattened device tree, size: 13605 bytes, version: 17
#+end_example

So there are four device trees. Then, with =binwalk -cf $csv -e $fullimg=

#+begin_src sh :results output code :wrap example sh :eval query
p=/tmp/tmp.WJgyO3457v
img=full.img
csv=/tmp/fdsa.log
i=0
grep -e device $csv |\
    sed -E 's/([0-9]+),.*size: ([0-9]+) bytes.*/\1 \2/g' |\
while read dtoffset dtsize; do
  i="$((i + 1))"
#  echo $i: $dtoffset $dtsize
  fname="$p/$(basename $p/$img .img).$i.dtb"
  echo dd if=$p/$img of=$fname bs=1 skip=$dtoffset count=$dtsize
done
#+end_src

#+RESULTS:
#+begin_example sh
dd if=/tmp/tmp.WJgyO3457v/full.img of=full.1.dtb bs=1 skip=328280 count=6809
dd if=/tmp/tmp.WJgyO3457v/full.img of=full.2.dtb bs=1 skip=524288 count=1975
dd if=/tmp/tmp.WJgyO3457v/full.img of=full.3.dtb bs=1 skip=1997312 count=21304
dd if=/tmp/tmp.WJgyO3457v/full.img of=full.4.dtb bs=1 skip=2146304 count=13605
#+end_example

... and copy the =dd= commands and run.

*** Device Tree

#+begin_src sh :results output :eval query
p=/tmp/tmp.WJgyO3457v
prefix=full
cd $p

for f in $prefix.{1,2,3,4}.dtb; do
    fout="$(basename $f .dtb).dts"
    dtc -s -I dtb $f -O dts -o $fout
done
#+end_src

| full.1 | rk3588 orangepi 5 plus |
| full.2 | firmware               |
| full.3 | rk3588 orangepi 5 plus |
| full.4 | rk3588 orangepi 5      |

**** Visualize DTS Files

#+begin_src

#+end_src


* Kernel Config

** Get the kernel config

From the Orange Pi 5+ image, =ls /boot/config-6*= if it's

From a running system

#+begin_src sh
kconfig="$(mktemp)"
cat /proc/config.gz | gunzip -c - > $kconfig
#+end_src

** Analyze the kernel config

* Issues

hmmm need to fixup everything in this heading

** TODO Finish Notes


*** Tasks

+ [ ] read from SPI Flash
+ [ ] binwalk -Me
+ [ ] extract GPT partition table

*** Targeting devices

The radxa notes state that =rkdeveloptool= can't select devices to write to,
though the CLI shows the =ld= command......

*** Extracting offsets
+ The Flash stores images within a GPT partition.

+ After =db $image=, then you should be able to add the device as loopback and
  inspect its partition structure to find offsets
+ The u-boot image usually contains both the firmware and the bootloader.

** Reset Device into MaskROM mode

Apparently [[https://github.com/rockchip-linux/rkdeveloptool/issues/43#issuecomment-555286351][rkdeveloptool rd 3]] reboots into MaskROM mode ... (need to verify in
the C source)
** Guix Shell

+ Requires sudo/hardware access
+ Probably needs a wrapper script to [[https://www.draketo.de/software/guix-work.html#run-in-ontainer][run in container]], but with hardware access.

*** Pass through USB Device

Get the bus/device

#+begin_src sh :results output
vendor=2207 # Rockchip
busid="$(lsusb | grep $vendor | sed -E 's/^Bus ([0-9]+).*$/\1/g')"
devid="$(lsusb | grep $vendor | sed -E 's/^Bus.*Device ([0-9]+).*$/\1/g')"
devpath="/dev/bus/usb/$busid/$devid"

echo $devpath
#+end_src

#+RESULTS:
: /dev/bus/usb/001/010

*** rkdeveloptool build

**** Via AUR:

Version 1.32: adds =cs= command?

#+begin_quote
linux-vdso.so.1 (0x000072488157f000)
libusb-1.0.so.0 => /usr/lib/libusb-1.0.so.0 (0x00007248813d1000)
libstdc++.so.6 => /usr/lib/libstdc++.so.6 (0x0000724881000000)
libgcc_s.so.1 => /usr/lib/libgcc_s.so.1 (0x00007248813a3000)
libc.so.6 => /usr/lib/libc.so.6 (0x0000724880e0e000)
libudev.so.1 => /usr/lib/libudev.so.1 (0x000072488135c000)
/lib64/ld-linux-x86-64.so.2 => /usr/lib64/ld-linux-x86-64.so.2 (0x0000724881581000)
libm.so.6 => /usr/lib/libm.so.6 (0x0000724880d16000)
libcap.so.2 => /usr/lib/libcap.so.2 (0x000072488134e000)
#+end_quote

**** Via Guix

Version 1.3

#+begin_quote
linux-vdso.so.1 (0x00007b4957f55000)
libusb-1.0.so.0 => /gnu/store/4gqfvdiz8zrf7kx0zwq7j94acdgkzszd-libusb-1.0.25/lib/libusb-1.0.so.0 (0x00007b4957f31000)
libstdc++.so.6 => /gnu/store/d69awcc5wahh71amx0dmgaimsdvvp2bg-gcc-11.4.0-lib/lib/libstdc++.so.6 (0x00007b4957c00000)
libm.so.6 => /gnu/store/hw6g2kjayxnqi8rwpnmpraalxi0djkxc-glibc-2.39/lib/libm.so.6 (0x00007b4957e51000)
libgcc_s.so.1 => /gnu/store/d69awcc5wahh71amx0dmgaimsdvvp2bg-gcc-11.4.0-lib/lib/libgcc_s.so.1 (0x00007b4957e37000)
libc.so.6 => /gnu/store/hw6g2kjayxnqi8rwpnmpraalxi0djkxc-glibc-2.39/lib/libc.so.6 (0x00007b4957a22000)
/gnu/store/hw6g2kjayxnqi8rwpnmpraalxi0djkxc-glibc-2.39/lib/ld-linux-x86-64.so.2 => /usr/lib64/ld-linux-x86-64.so.2 (0x00007b4957f57000)
#+end_quote
** Babel

#+name: spiPath
#+begin_src emacs-lisp :eval query :cache yes
(setq-local spi-path (or (bound-and-true-p spi-path)
                         (read-string "SPI path: " (make-temp-file "spi-" t))))
#+end_src

#+RESULTS[c8bf8b1f4e9255aefd0f4f9f3671f961bb8a067b]: spiPath
: /tmp/spi-6djkEd

Start a session.

+ For some reason, =guix shell= without clearing out =GUIX_PROFILE= is setting up
  the path incorrectly (babel is doing something else). Using =--pure= leaves me
  without some essential tools.
+ =:dir spiPath= isn't working...

# +header: :dir spiPath

#+begin_src sh :session *spi* :eval query :async yes :var spiPath=spiPath
cd $spiPath
pkgs=(rkdeveloptool binwalk)
guix shell ${pkgs[@]}

# fix path
PATH=${GUIX_ENVIRONMENT}/bin:$PATH
#+end_src

#+RESULTS:
: bash: bind: warning: line editing not enabled
: bash: bind: warning: line editing not enabled
: bash: bind: warning: line editing not enabled
: bash: bind: warning: line editing not enabled
: bash: bind: warning: line editing not enabled
: direnv: unloading
: $ $ $ $

Test session

+ The =line editing not enabled= warning may be causing problems.
+ The process may emit some weird control characters, so maybe this won't work.

#+begin_src sh :session *spi* :eval no :results output verbatim
rkdeveloptool -h | tr -d '\r'
#+end_src

#+RESULTS:
#+begin_example
---------------------Tool Usage ---------------------
Help:                   -h or --help
Version:                -v or --version
ListDevice:             ld
DownloadBoot:           db <Loader>
UpgradeLoader:          ul <Loader>
ReadLBA:                rl  <BeginSec> <SectorLen> <File>
WriteLBA:               wl  <BeginSec> <File>
WriteLBA:               wlx  <PartitionName> <File>
WriteGPT:               gpt <gpt partition table>
WriteParameter:         prm <parameter>
PrintPartition:         ppt
EraseFlash:             ef
TestDevice:             td
ResetDevice:            rd [subcode]
ReadFlashID:            rid
ReadFlashInfo:          rfi
ReadChipInfo:           rci
ReadCapability:         rcb
PackBootLoader:         pack
UnpackBootLoader:       unpack <boot loader>
TagSPL:                 tagspl <tag> <U-Boot SPL>
-------------------------------------------------------
#+end_example
