:PROPERTIES:
:ID:       8c823305-1e78-4282-a8bf-aef1e852eeee
:END:
#+TITLE: Org Babel: Files Modified During Execution
#+CATEGORY: slips
#+TAGS:

* Roam
+ [[id:6f769bd4-6f54-4da7-a329-8cf5226128c9][Emacs]]
+ [[id:bdae77b1-d9f0-4d3a-a2fb-2ecdab5fdcba][Unix]]
+ [[id:bdae77b1-d9f0-4d3a-a2fb-2ecdab5fd531][Linux]]
+ [[id:33cee19d-b67b-429c-963b-29209d0982bc][Org]]
+ [[id:dae42c2e-aba7-4c9c-9878-b9665befe205][IPC And Sockets]]

* Resources

The baeldung site keeps showing up lately:

+ [[https://www.baeldung.com/linux/monitor-changes-directory-tree][Monitor A Directory Tree For Changes]]
+ [[https://www.baeldung.com/linux/socat-command][The socat Command in Linux]]

* Goal

It's not 100% clear to me what intermediate data is generated by =org-babel= in
entirety, so I'd like to determine the kinds of files generated by org-babel
during execution.

I don't really feel like tracing through the org-babel source end-to-end though.

* Auth Sources

Emacs includes =auth-sources= which transparently handles GPG-encrypted
authentication tokens pretty well ... however, the libraries have to support
it.

Basically, I want to run =graphql= queries in =org-babel=, but I need somewhere
to put the authorization token. Storing it in an emacs-lisp variable would work,
but if this is getting written somewhere like logs/cache/history, then I'd like
to know.

The handling of tramp, org-babel and etc seems to be done with security in mind
because quite a bit of this stuff "just works" while remaining transparent.
AFAIK, anyways. it's not exactly exhaustive, but from what I've seen, there
seems to be quite a bit of effort in minimizing the footprint of side
effects. Of course, the further I get away from the Emacs core, the less sure I
am (for no specific reasons).

* Org Babel Execution Artifacts

The main motivating factor for me here: is it worth it to reverse engineer
how libraries like =ghub= and =forge=.

** Temporary Files

As shown below, org-babel emits content to two separate directories. The
temporary directory path is persisted through the emacs-session.

** Logs

Other places where information could be stored include logs or side-effects.

** Execution On Remote Hosts

When using Tramp's paths to specify that code should be executed on remote
hosts, org-babel expects to be able to write to the temporary directory.

So, things like [[id:b5b9a80f-aca5-4326-a83a-0faedbc0c89b][Running Scripts on a DD-WRT Router]] would only work if the
router's shell supports the capabilities that org-babel requires. It uses =ash=
as the shell, so it doesn't. However, because it errors out, the artifacts of
its execution are left behind and new =$(mktemp -d)= directories are created
each time.

* Testing Temporary Files

Some scripts are pushed to the following paths in =/tmp/babel-*= and these seem
to be cleared out between executions.

#+name: ob-tmpdir
#+begin_src emacs-lisp
org-babel-temporary-directory
#+end_src

#+RESULTS: ob-tmpdir
: /tmp/babel-Z8282u

#+name: ob-stable-tmpdir
#+begin_src emacs-lisp
org-babel-temporary-stable-directory
#+end_src

#+RESULTS: ob-stable-tmpdir
: /tmp/babel-stable-182

This script captures the temporary file while it exists. Only one file shows,
but ob-execution invocations create a dependency tree of scripts to
execute. Doing so here requires confirming five times.

#+begin_src sh :results output :noweb yes :exports both
tree <<ob-tmpdir()>> <<ob-stable-tmpdir()>>

echo \n\n====================\n
echo temporary script file: "$(ls <<ob-tmpdir()>>/*)"
echo \n====================\n\n

cat <<ob-tmpdir()>>/*
#+end_src

#+RESULTS:
#+begin_example
/tmp/babel-Z8282u
└── ob-input-1gdf8R
/tmp/babel-stable-182

1 directory, 1 file
nn====================n
temporary script file: /tmp/babel-Z8282u/ob-input-1gdf8R
n====================nn
tree /tmp/babel-Z8282u /tmp/babel-stable-182

echo \n\n====================\n
echo temporary script file: "$(ls /tmp/babel-Z8282u/*)"
echo \n====================\n\n

cat /tmp/babel-Z8282u/*
#+end_example

* Testing with =inotify=

** Setup

Install the =inotify-tools= and =socat= packages. These are installed in a
profile that isn't available by default.

#+begin_src sh
which inotifywait
which socat
#+end_src

#+RESULTS:
: /gnu/store/cm6nlbq06ac3cvpm71bnl20bq6cg34jb-profile/bin/inotifywait

** Start inotifywait

This version of =inotifywait= seems sensitive to the order of arguments:

+ =--timefmt= needs to precede =--format=
+ it considers =--output= invalid and requires =-o= after =-d=
+ if =-o= comes before =--format=, there is no output to file.

inotifywait =--format= format:

| %w | watched file |                       |
| $f | file         | when %w is a dir      |
| %e | event        |                       |
| %T | time         | Change with --timefmt |

Running the socat block below will run all the blocks

#+name: inotify-pid
#+begin_src sh :results output code :noweb yes :exports both
ipid=$(pgrep inotifywait)

tmpdir="<<ob-tmpdir()>>"
stable_tmpdir="<<ob-stable-tmpdir()>>"

ilog=/tmp/inotify.log
[[ -e $ilog ]] && rm $ilog
touch $ilog

if [ -z $ipid ]; then
    #iout=$(mktemp)
    inotifywait -m -d --timefmt %T --format "%T %w %e %f" -o $ilog $tmpdir $stable_tmpdir
    # ipid=$! # not backgrounded
    [[ $? -gt 0 ]] && echo "failed to start inotifywait" && exit 1;
    ipid=$(pgrep inotifywait)
    [[ -z $ipid ]] && echo "failed to get pid for inotifywait" && exit 1;
fi

echo ipid=$ipid
echo ilog=$ilog
#+end_src

#+RESULTS: inotify-pid
#+begin_src sh
ipid=9286
ilog=/tmp/inotify.log
#+end_src

** Start socat

Using a noweb-reference for =<<inotify-pid>>= requires reevaluating the above
blocks. This would otherwise pass environment variables passed between blocks
without the need to parse a table or text.


Close after timeout of 30s

#+begin_src sh :results output code :noweb yes :exports both
<<inotify-pid()>>

[[ -z $ipid ]] && ipid=$(pgrep inotifywait)
ilog=/tmp/inotify.log

echo $ipid
[[ -z $ipid ]] && echo "failed to get pid for inotifywait" && exit 1

tail -f $ilog | socat -T10 STDIN STDOUT
#+end_src

#+RESULTS:
#+begin_src sh
9356
15:59:02 /tmp/babel-Z8282u/ CLOSE_WRITE,CLOSE ob-error-LUibMz
15:59:02 /tmp/babel-Z8282u/ DELETE ob-error-LUibMz
15:59:02 /tmp/babel-Z8282u/ CREATE .#ob-input-m9QeeX
15:59:02 /tmp/babel-Z8282u/ MODIFY ob-input-m9QeeX
15:59:02 /tmp/babel-Z8282u/ OPEN ob-input-m9QeeX
15:59:02 /tmp/babel-Z8282u/ MODIFY ob-input-m9QeeX
15:59:02 /tmp/babel-Z8282u/ CLOSE_WRITE,CLOSE ob-input-m9QeeX
15:59:02 /tmp/babel-Z8282u/ DELETE .#ob-input-m9QeeX
15:59:02 /tmp/babel-Z8282u/ OPEN ob-input-m9QeeX
15:59:02 /tmp/babel-Z8282u/ ACCESS ob-input-m9QeeX
#+end_src

** Results

The file access is logged above. The =socat= process must finish before
org-babel will consider it's block to be complete.

Org babel redirects the =STDERR= output to the =ob-error-= buffers, which are
defined in the [[https://git.savannah.gnu.org/cgit/emacs/org-mode.git/tree/lisp/ob-eval.el#n95][ob-eval.el]] code in =org-babel--shell-command-on-region=.

