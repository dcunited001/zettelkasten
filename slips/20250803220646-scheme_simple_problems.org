:PROPERTIES:
:ID:       d8eb5133-1e50-47c7-8127-370999d75e5f
:END:
#+TITLE: Scheme: Simple Problems
#+CATEGORY: slips
#+TAGS:

* Roam
+ [[id:b82627bf-a0de-45c5-8ff4-229936549942][Guix]]
+ [[id:87c43128-92c2-49ed-b76c-0d3c2d6182ec][Scheme]]

* Notes

Branched off from [[id:81a26cc3-22f3-4332-96c2-c71407d5149d][DC Guix: ts-hyprlang]] to describe questions that seem simple,
but end up being fairly involved to test, esp in the middle of a stateful system
subject to entangled dynamics.

i.e. assertions about inner logic of some Guile & Scheme issues require leaning
on faulty assumptions, meta-magic or brittle state. "Axes" of ambiguity, where
each affects the other.

As a beginner, if the ambiguity and faulty assumptions linger, it makes
designing modular code problematic, but worse, it impairs memory later on
because the faulty assumptions have left a larger imprint on the mind.

Reading scheme is deceptively simply, even when getting into recursive
=define-syntax-rule=. I assume the clarity would be quickly lost when reading
badly written scheme.

** Specific Examples

While packaging =ts-hyprlang=

+ Problems with definitions/references using @@ syntax? No, not here.
 ok, you can't simply rename the package. I've screwed
+ Can I simply define the same =(package (name "eg-hello"))= used elsewhere?
  - nope. this clearly breaks. I've played around with this a bunch, but never
    explicitly answered that IIRC (smh...)
+ Did I need =(package/inherit ...)=? Instead =(package (inherit base) ...)=?
  - I have no idea (need to look at the =define-syntax-rule=)
  - Guix has moved from standard scheme records towards its own =(guix records)=.
    The exact mechanics of =(inherit %a-guix-record)= are a bit opaque.
  - Some lower level details are easier to trace. Given enough time, I could
    find it (I may have), but any /exposure-based language learning/ needs quick
    resolution of ambiguity. The docs are great, but some problems are very
    difficult to overcome without explication by simply reading source.
  - Without accumulating fundamentals, it's difficult branch out to write
    scheme. Guix code is mostly configuration, especially in a personal
    codebase: cargo-culting this creates lots of code to delete/prune/rearrange
    later.
+ Did I need =(let ((base ts-hyprlang)) (package ...))=?
  - This didn't seem to matter. =let= is the aspect of scheme that's a real
    mind-fuck, but it's also one of the most valuable core principals of scheme.
  - After reading through the lambda calculus for let (and extrapolating), the
    core idea behind environments/bindings allows you to reason systematically
    about composed mappings of variable bindings across language or system
    interfaces.
    - e.g. "does this go in =.profile=, =.envrc=, =.dir-locals.el=, =$project/.env=,
      =~/.config/uwsm/env-sway=, source code, a big hash in the sky, etc, etc..."
      become far simpler to reason about holistically -- and particularly how
      you should name the bindings so they compose seamlessly without endless
      shuffling and aimless refactoring.
    - it clarifies that environment variables are a primarily a kernel construct
      propagated downstream through processes by composing merged environment
      deltas ... and everything else extends from that. it seems complex, but
      it's an endless sea of complexity if you don't really see it from this
      perspective (it's a perpective from the center of a panopticon vs some
      remote periphery: everything becomes more proportional)
  - The real mind-fuck is =identifier-syntax= ... which i really don't understand.

** On Scheme Itself

My issues are mostly with Geiser; that & some kind of environment setup that
amorphously propagated "simple" but defintely anomalous UI/UX issues. The
language itself is also difficult, but unrelated to Geiser.

Learning scheme definitely requires guidance. The implementation doesn't matter:
Scheme is not a language, it's a meta-language. "No two schemers are alike," a
quote from a video on R6RS never to be found in my youtube history. Without a
proper initiation into the SICP by the greybeards... it's hard to understand how
one decides _which_ DSL or style and why. Deciding how to integrate these tools
hides some dangerous chasms in any metaprogramming-centric language ... but
again, scheme is a meta-language (both in it's application, as well as the
motiviations behind ideas like Geiser or R6RS)

SICP opens with the following:

#+begin_quote
"A computational process is indeed much like a sorcerer’s idea of a
spirit. It cannot be seen or touched. It is not composed of matter at all.
However, it is very real. It can perform intellectual work. It can answer
questions. It can affect the world by disbursing money at a bank or by
controlling a robot arm in a factory. The programs we use to conjure
processes are like a sorcerer’s spells. They are carefully composed from
symbolic expressions in arcane and esoteric programming languages that
prescribe the tasks we want our processes to perform" -- SICP
#+end_quote

And by the end of chapter 4 you know their heads are in the philosophy. The
video does it better though.

#+begin_html
<iframe width="560" height="315"
src="https://www.youtube.com/embed/2Op3QLzMgSY?si=6Xvpc5-XTLD2Nkx2"
title="YouTube video player" frameborder="0" allow="accelerometer; autoplay;
clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share"
referrerpolicy="strict-origin-when-cross-origin" allowfullscreen></iframe>
#+end_html
