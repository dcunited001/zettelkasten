:PROPERTIES:
:ID:       6aaab141-1944-4f4b-a6c0-01474f501859
:END:
#+TITLE: Podman: Configuration Files
#+CATEGORY: slips
#+TAGS:

* Roam
+ [[id:afe1b2f0-d765-4b68-85d0-2a9983fa2127][Containers]]
+ [[id:ac2a1ae4-a695-4226-91f0-8386dc4d9b07][DevOps]]

* Overview

+ add details on Docker, containerd

** Nix

** Rootless Configs

*** Change default storage location

[[https://access.redhat.com/solutions/7007159][How to change rootless users' container storage location]]

This is useful when:

+ you have rootless containers started as services (under specific users), but
  you don't want them to auto-create a =$HOME/.local/share= directory
+ these are usually login users anyways (they will get an =$XDG_RUNTIME_DIR=)
+ you don't want an old system's container images/volumes polluting your =$HOME=
  directory or eating up =/home= partition space. (in my experience cleaning this
  up while transferring to a new system is a PITA ... or it eats your partitions)

*** Rootless Networking

With a complicated setup, you'll need rootful access to setup containers.

**** Network Backend

+ cni :: rootful; default before podman =v4= (will be deprecated)
+ netavark :: rootful; default used for =v4=
+ slirp4netns :: rootless default before =v5=
+ pasta :: rootless since =v5=
* Podman

** Registries

*** registries.conf.d

Load order:

+ /etc/containers/registries.conf
+ /etc/containers/registries.conf.d/*.conf

**** Arch Aliases =/etc/containers/registries.conf.d/00-shortnames.conf=

#+begin_example toml
[aliases]
  # Amazon Linux
  "amazonlinux" = "public.ecr.aws/amazonlinux/amazonlinux"
  # centos
  "centos" = "quay.io/centos/centos"
  # containers
  "skopeo" = "quay.io/skopeo/stable"
  "buildah" = "quay.io/buildah/stable"
  "podman" = "quay.io/podman/stable"
  "hello" = "quay.io/podman/hello"
  "hello-world" = "quay.io/podman/hello"
  # docker
  "alpine" = "docker.io/library/alpine"
  "docker" = "docker.io/library/docker"
  "registry" = "docker.io/library/registry"
  "swarm" = "docker.io/library/swarm"
#+end_example

** Policy

From =man containers-policy.json=

#+begin_src plantuml :file img/devops/containers-policy.example.svg :exports results
@startjson
{
  "default": [{"type": "reject"}],
  "transports": {
    "docker": {
      "docker.io/openshift": [
        {"type": "insecureAcceptAnything"}],
      "docker.io/library/busybox": [
        {"type": "insecureAcceptAnything"}],
      "*.temporary-project.example.com": [
        {"type": "insecureAcceptAnything"}],
      "hostname:5000/myns/sigstore-signed-with-full-references": [
        { "type": "sigstoreSigned",
          "keyPath": "/path/to/sigstore-pubkey.pub" }],
      "hostname:5000/myns/sigstore-signed-fulcio-rekor": [
        { "type": "sigstoreSigned",
          "fulcio": {
            "caPath": "/path/to/fulcio_v1.crt.pem",
            "oidcIssuer": "https://github.com/login/oauth",
            "subjectEmail": "test-user@example.com" },
          "rekorPublicKeyPath": "/path/to/rekor.pub" }],
      "hostname:5000/myns/sigstore-signed-byopki": [
        { "type": "sigstoreSigned",
          "pki": {
            "caRootsPath": "/path/to/pki_root_crts.pem",
            "caIntermediatesPath": "/path/to/pki_intermediate_crts.pem",
            "subjectHostname": "test-user.example.com",
            "subjectEmail": "test-user@example.com" } }],
      "hostname:5000/myns/sigstore-signed-allows-malicious-tag-substitution": [
        { "type": "sigstoreSigned",
          "keyPath": "/path/to/sigstore-pubkey.pub",
          "signedIdentity": {
            "type": "matchRepository"} }],
      "hostname:5000/myns/sigstore-signed-fulcio-rekor- allows-malicious-tag-substitution": [
        { "type": "sigstoreSigned",
          "fulcio": {
            "caPath": "/path/to/fulcio_v1.crt.pem",
            "oidcIssuer": "https://github.com/login/oauth",
            "subjectEmail": "test-user@example.com" },
          "rekorPublicKeyPath": "/path/to/rekor.pub",
          "signedIdentity": { "type": "matchRepository" } }]
    }, "dir": {
      "": [{"type": "insecureAcceptAnything"}]
    }, "atomic": {
      "hostname:5000/myns/official": [
        { "type": "signedBy",
          "keyType": "GPGKeys",
          "keyPath": "/path/to/official-pubkey.gpg" }],
      "hostname:5000/vendor/product": [
        { "type": "signedBy",
          "keyType": "GPGKeys",
          "keyPath": "/path/to/vendor-pubkey.gpg",
          "signedIdentity": {
            "type": "exactRepository",
            "dockerRepository": "vendor-hostname/product/repository" } },
        { "type": "signedBy",
          "keyType": "GPGKeys",
          "keyPath": "/path/to/reviewer-pubkey.gpg" }],
      "private-mirror:5000/vendor-mirror": [
        { "type": "signedBy",
          "keyType": "GPGKeys",
          "keyPath": "/path/to/vendor-pubkey.gpg",
          "signedIdentity": {
            "type": "remapIdentity",
            "prefix": "private-mirror:5000/vendor-mirror",
            "signedPrefix": "vendor.example.com" }
        }]
    }
  }
}
@endjson
#+end_src

#+RESULTS:
[[file:img/devops/containers-policy.example.svg]]


** Storage

**** TODO: chunk up, convert to yaml, emit to =@startyaml=

#+begin_src toml
[storage]

# not native TOML boolean := This is a "string bool": "false" | "true" (cannot
# be native TOML boolean)

# Default storage driver, must be set for proper operation.
driver = "overlay"

# Temporary storage location
runroot = "/run/containers/storage"

##### Priority list. Test one by one: pick the storage driver if not defined.
driver_priority = ["overlay", "btrfs"]

# Primary Read/Write location of container storage
# When changing the graphroot location on an SELinux system, you must
# ensure the labeling matches the default location's labels with the
# following commands:
# semanage fcontext -a -e /var/lib/containers/storage /NEWSTORAGEPATH
# restorecon -R -v /NEWSTORAGEPATH
graphroot = "/var/lib/containers/storage"

# Optional alternate location of image store if a location separate from the
# container store is required. If set, it must be different than graphroot.
####
imagestore = ""

##### Storage path for rootless users
rootless_storage_path = "$HOME/.local/share/containers/storage"

# Transient store mode makes all container metadata be saved in temporary storage
# (i.e. runroot above). This is faster, but doesn't persist across reboots.
# Additional garbage collection must also be performed at boot-time, so this
# option should remain disabled in most configurations.
transient_store = true #####

[storage.options]

# AdditionalImageStores is used to pass paths to additional Read/Only image stores
# Must be comma separated list.
additionalimagestores = [
]

[storage.options.pull_options]

# Enable the "zstd:chunked" feature, which allows partial pulls, reusing
# content that already exists on the system. This is disabled by default,
# and must be explicitly enabled to be used. For more on zstd:chunked, see
# https://github.com/containers/storage/blob/main/docs/containers-storage-zstd-chunked.md


####
enable_partial_images = "false" # (not native TOML boolean)


# Tells containers/storage to use hard links rather then create new files in
# the image, if an identical file already existed in storage.

#####
use_hard_links = "false" # (not native TOML boolean)


# Path to an ostree repository that might have
# previously pulled content which can be used when attempting to avoid
# pulling content from the container registry.

#####
ostree_repos=""

# If set to "true", containers/storage will convert images that are
# not already in zstd:chunked format to that format before processing
# in order to take advantage of local deduplication and hard linking.
# It is an expensive operation so it is not enabled by default.

#####
convert_images = "false" # (not native TOML boolean)


# This should ALMOST NEVER be set.
# It allows partial pulls of images without guaranteeing that "partial
# pulls" and non-partial pulls both result in consistent image contents.
# This allows pulling estargz images and early versions of zstd:chunked images;
# otherwise, these layers always use the traditional non-partial pull path.
#
# This option should be enabled EXTREMELY rarely, only if ALL images that could
# EVER be conceivably pulled on this system are GUARANTEED (e.g. using a signature policy)
# to come from a build system trusted to never attack image integrity.
#
# If this consistency enforcement were disabled, malicious images could be built
# in a way designed to evade other audit mechanisms, so presence of most other audit
# mechanisms is not a replacement for the above-mentioned need for all images to come
# from a trusted build system.
#
# As a side effect, enabling this option will also make image IDs unpredictable
# (usually not equal to the traditional value matching the config digest).

#####
insecure_allow_unpredictable_image_contents = "false"

# Root-auto-userns-user is a user name which can be used to look up one or more UID/GID
# ranges in the /etc/subuid and /etc/subgid file.  These ranges will be partitioned
# to containers configured to create automatically a user namespace.  Containers
# configured to automatically create a user namespace can still overlap with containers
# having an explicit mapping set.
# This setting is ignored when running as rootless.

#####
root-auto-userns-user = "storage"

# Auto-userns-min-size is the minimum size for a user namespace created automatically.

####
auto-userns-min-size=1024

# Auto-userns-max-size is the maximum size for a user namespace created automatically.

#####
auto-userns-max-size=65536

[storage.options.overlay]

# ignore_chown_errors can be set to allow a non privileged user running with
# a single UID within a user namespace to run containers. The user can pull
# and use any image even those with multiple uids.  Note multiple UIDs will be
# squashed down to the default uid in the container.  These images will have no
# separation between the users in the container. Only supported for the overlay
# and vfs drivers.
ignore_chown_errors = "false" # (not native TOML boolean)

##### Inodes is used to set a maximum inodes of the container image.
inodes = ""

###### Path to helper program for mounting FS instead of mounting it directly.
mount_program = "/usr/bin/fuse-overlayfs"

# mountopt specifies comma separated list of extra mount options
mountopt = "nodev"

##### Set to skip a PRIVATE bind mount on the storage home directory.
skip_mount_home = "false" # (not native TOML boolean)


##### Set to use composefs to mount data layers with overlay.
use_composefs = "false" # (not native TOML boolean)

##### Size is used to set a maximum size of the container image.
size = ""

# ForceMask specifies the permissions mask that is used for new files and
# directories.
#
# The values "shared" and "private" are accepted.
# Octal permission masks are also accepted.
#
#  "": No value specified.
#     All files/directories, get set with the permissions identified within the
#     image.
#  "private": it is equivalent to 0700.
#     All files/directories get set with 0700 permissions.  The owner has rwx
#     access to the files. No other users on the system can access the files.
#     This setting could be used with networked based homedirs.
#  "shared": it is equivalent to 0755.
#     The owner has rwx access to the files and everyone else can read, access
#     and execute them. This setting is useful for sharing containers storage
#     with other users.  For instance have a storage owned by root but shared
#     to rootless users as an additional store.
#     NOTE:  All files within the image are made readable and executable by any
#     user on the system. Even /etc/shadow within your image is now readable by
#     any user.
#
#   OCTAL: Users can experiment with other OCTAL Permissions.
#
#  Note: The force_mask Flag is an experimental feature, it could change in the
#  future.  When "force_mask" is set the original permission mask is stored in
#  the "user.containers.override_stat" xattr and the "mount_program" option must
#  be specified. Mount programs like "/usr/bin/fuse-overlayfs" present the
#  extended attribute permissions to processes within containers rather than the
#  "force_mask"  permissions.

#####
force_mask = ""

#+end_src
