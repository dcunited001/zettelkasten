:PROPERTIES:
:ID:       f6af081c-2a1e-4423-9278-da6e0b276aef
:END:
#+TITLE: Hyprland: XKB Common
#+CATEGORY: slips
#+TAGS:

* Roam
+ [[id:bc406527-0255-4d70-b620-82495ac5c8fe][Hyprland]]
+ [[id:3d2330da-5a95-408a-b940-7d2b3b0c7fb2][Keyboard]]
+ [[id:003953f8-acde-4c26-8c6b-d0aa3b27002b][XKB]]

* Overview

Saving files in =~/.config/xkb= can crash hyprland pretty easily. I seem to be
better off when I terminate =fcitx5= ... I think?

+ This session hasn't crashed yet, but saving =~/.config/xkb/rules/evdev= with
  invalid =RMVLO -> KcCGST= mapping syntax seemed to crash it pretty good.

Actually using XKB Common for more advanced stuff is pretty rough.

+ You almost certainly want toggles or layered/switched functionality.
+ Redefined keybinds need to satisfy X11/XWayland, Wayland & maybe console. ...
  while also playing nice with your shiny =QMK k$yB$,000rd(s)= (which I've never
  interacted with in person)

But they are portable to any PC-104 keyboard. I would _not_ touch this if I
thought I was going to lose or redo my customizations. With X11 there weren't so
many compatibility layers ... but editing root files sucks. Here, you can
accumulate what you need and it should function in many places.

+ 2011, 2013, 2014, 2015, 2016 ...everyone just uses QMK & i have no idea WTF
  that is, 2017, 2019... etc
+ I mean some of the primary examples on libxkbcommon _are_ exactly what i
  configured on mac, then linux, then mac, then linux....

* =xkbtest= directory

A better workflow is a second =~/.config/xkbtest= directory that contains small
changes, either loading on top of =~/.config/xkb= via its paths or only containing
what's necessary. Both are actually pretty challenging

+ Difficult getting =xkbcommon= and =xkbcli= paths right to compile keymaps or run
  test tools.
  - A small =Makefile= or =Justfile= can help env, with tooling startup via
      watch/exec.
+ The other bigger problem: it's hard to know when XKB's namespacing are going
  to cause issues with =xkbcli= compilation.
  - e.g. Avoiding file-name collisions with maps that already exist

It's probably easier to duplicate the code in =~/.config/{xkb,xkbtest}=, but when
constructing path in =Makefile=, ensure that =xkbcli= doesn't load from your running
user's =xkb= directory.

#+begin_example shell
# specify path and
xkbcli list

xkbcli compile-keymap --rules evdev \
  --model pc104 \
  --layout io \
  --variant altgr-intl \
  --options mylvl5:ins_switch

# you can also test these in a VTY using screen/tmux

diff --color \
  <(no_set_xkb_env; xkbcli dump-keymap-wayland ...) \
  <(set_test_xkb_env; xkbcli compile-keymap ...)

xkbcli interactive-{wayland,x11,evdev}
#+end_example

Once the =xkbcli= compilation or xkbcli seems to give good results, then port in
the customizations to hyprland.

I have no idea why it's so difficult to find examples.


* Extra Modifiers

+ [[https://github.com/qmk/qmk_firmware/issues/17749][qmk/qmk_firmware#17749]] there's a "shift of 8"
  + =xkb_keycode = linux_input_keycode + 8=

** =ISO_Level5_Shift= to =EightLevel= character entry.

+ I've got =<INS>= remapped as a =ISO_Level5_Shift= with the modifier bits
  recognized by =wev= as such
+ But I need to debug the other details in the xkbcommon layout to understand
  why characters don't come through.

*~/.config/xkb/symbols/mylevel5*

#+begin_example xkb
// -*- mode: xkb -*-
partial modifier_keys
xkb_symbols "ins_switch" {
  key <INS> {[  ISO_Level5_Shift  ], type[group1]="ONE_LEVEL" };
};
#+end_example

*~/.config/xkb/rules/evdev*

#+begin_example
! option = symbols
  mylvl5:ins_switch					= +mylevel5(ins_switch)

! include %S/evdev
#+end_example

This may need to go in a different rules file... and the include may need to
precede the option declaration.

hyprland and other apps will need the =evdev.xml= completed, otherwise new
options/layouts will not be discoverable.

From there, you should be able add the option to variants in Hyprland's conf,
=fcitx5=, etc.

The keyboard's =fn= key remaps =print/break/pause= on top of =insert/home/end=, so
i'll probably map one of those to an additional =super= or something. I want
relative symmetry with functionality.

** =ISO_LEVELX_{SHIFT,LATCH,LOCK}=

From [[https://unix.stackexchange.com/questions/302163/how-to-make-a-iso-level4-shift-and-lock-in-xkb][How to make a ISO_Level4_Shift and Lock in xkb?]]

*** First Example

https://unix.stackexchange.com/questions/302163/how-to-make-a-iso-level4-shift-and-lock-in-xkb

#+begin_src xkb
// $ xkbcomp $DISPLAY - | less
//....
xkb_compatibility "complete+ledcaps(shift_lock)" {
    //....
    interpret ISO_Level3_Shift+AnyOf(all) {
        virtualModifier= LevelThree;
        useModMapMods=level1;
        action= SetMods(modifiers=LevelThree,clearLocks);
    };
    interpret ISO_Level3_Latch+AnyOf(all) {
        virtualModifier= LevelThree;
        useModMapMods=level1;
        action= LatchMods(modifiers=LevelThree,clearLocks,latchToLock);
    };
    interpret ISO_Level3_Lock+AnyOf(all) {
        virtualModifier= LevelThree;
        useModMapMods=level1;
        action= LockMods(modifiers=LevelThree);
    };
    //....
    interpret ISO_Level3_Shift+AnyOfOrNone(all) {
        action= SetMods(modifiers=LevelThree,clearLocks);
    };
    interpret ISO_Level3_Latch+AnyOfOrNone(all) {
        action= LatchMods(modifiers=LevelThree,clearLocks,latchToLock);
    };
    interpret ISO_Level3_Lock+AnyOfOrNone(all) {
        action= LockMods(modifiers=LevelThree);
    };

    //....

    // the 'level2' latch apparently doesn't have the same support
    interpret ISO_Level2_Latch+AnyOf(all) {
        useModMapMods=level1;
        action= LatchMods(modifiers=Shift,clearLocks,latchToLock);
    };
    interpret ISO_Level2_Latch+AnyOfOrNone(all) {
        action= LatchMods(modifiers=Shift,clearLocks,latchToLock);
    };
}; // <-- mind these fucking semicolons (they matter)

#+end_src

From 

#+begin_src c++
//....in xkbcommon/xkbcommon-keysyms.h:
//....
#define XKB_KEY_ISO_Fast_Cursor_Left          0xfe2c
#define XKB_KEY_ISO_Fast_Cursor_Right         0xfe2d
#define XKB_KEY_ISO_Fast_Cursor_Up            0xfe2e
#define XKB_KEY_ISO_Fast_Cursor_Down          0xfe2f

// "Remove the XKB_KEY_ prefix to get keysym names we can reference in XKB rules.
// Let's use ISO_Fast_Cursor_Left to fake ISO_Level4_Latch."
#+end_src

with =setxkbmap -print=:

#+begin_src text
xkb_keymap {
    xkb_keycodes  { include "evdev+aliases(qwerty)" };
    xkb_types     { include "complete"  };
    xkb_compat    { include "complete"  };
    xkb_symbols   { include "pc+us(altgr-intl)+inet(evdev)" };
    xkb_geometry  { include "pc(pc105)" };
};
#+end_src

Apparently, you can just edit this file in place...............................

yes. the dots are necessary................................

#+begin_src xkb
// Attempting to define and use a key as Level4 Shift/Latch/Lock.
// Plan: * activate lv5 shift on rctrl.
//       * place latches on lv5 of keys 2,3,4,5 for corresponding level.
//       * replace keys ASDF with 8-level versions and define symbols for test.
//       * pressing RCtrl+4 then A should result in Ã

// starting point: setxkbmap -layout us -variant altgr-intl -option '' -print
// load this file: xkbcomp myfile.xkb $DISPLAY
xkb_keymap {
    xkb_keycodes  { include "evdev+aliases(qwerty)" };
    xkb_types     { include "complete"      };
    xkb_compat    { 
        include "complete"      

        // add in interpretations
        // ISO_Level3_Latch includes a +AnyOf stanza and a +AnyOfOrNone stanza (same for ISO_Level5_Latch)
        // assume each additional latch needs both
        interpret ISO_Level2_Latch+AnyOf(all) {
            useModMapMods=level1;
            action= LatchMods(modifiers=Shift,clearLocks,latchToLock);
        };
        interpret ISO_Level2_Latch+AnyOfOrNone(all) {
            action= LatchMods(modifiers=Shift,clearLocks,latchToLock);
        };
        interpret ISO_Fast_Cursor_Left+AnyOf(all) {
            // Level4 needs both Shift and LevelThree
            useModMapMods=level1;
            action= LatchMods(modifiers=Shift+LevelThree,clearLocks,latchToLock);
        };
        interpret ISO_Fast_Cursor_Left+AnyOfOrNone(all) {
            // Level4 needs both Shift and LevelThree
            action= LatchMods(modifiers=Shift+LevelThree,clearLocks,latchToLock);
        };
    };
    xkb_symbols   { 
        include "pc"
        include "us(altgr-intl)"
        include "inet(evdev)"

        // latch keys
        key <AE02> {
            type= "EIGHT_LEVEL",
            symbols[Group1]= [ 2, at, twosuperior, dead_doubleacute, ISO_Level2_Latch, X, z, Z ]
        };
        key <AE03> {
            type= "EIGHT_LEVEL",
            symbols[Group1]= [ 3, numbersign, threesuperior, dead_macron, ISO_Level3_Latch, X, z, Z ]
        };
        // no ISO_Level4_Latch so use ISO_Fast_Cursor_Left
        key <AE04> {
            type= "EIGHT_LEVEL",
            symbols[Group1]= [ 4, dollar, currency, sterling, ISO_Fast_Cursor_Left, X, z, Z ]
        };
        key <AE05> {
            type= "EIGHT_LEVEL",
            symbols[Group1]= [ 5, percent, EuroSign, dead_cedilla, ISO_Level5_Latch, X, z, Z ]
        };
        // no ISO_Level6_Latch so use ISO_Fast_Cursor_Right
        // no ISO_Level7_Latch so use ISO_Fast_Cursor_Up
        // no ISO_Level8_Latch so use ISO_Fast_Cursor_Down

        // eight-level keys ASDF for testing
        key <AC01> {
            type= "EIGHT_LEVEL_SEMIALPHABETIC",
            symbols[Group1]= [ a, A, aacute, Aacute, agrave, Agrave, aring, Aring ]
        };
        key <AC02> {
            type= "EIGHT_LEVEL_SEMIALPHABETIC",
            symbols[Group1]= [ s, S, ssharp, section, ccedilla, Ccedilla, ntilde, Ntilde ]
        };
        key <AC03> {
            type= "EIGHT_LEVEL_SEMIALPHABETIC",
            symbols[Group1]= [ d, D, eth, ETH, thorn, THORN, t, T ]
        };
        key <AC04> {
            type= "EIGHT_LEVEL_SEMIALPHABETIC",
            symbols[Group1]= [ f, F, eacute, Eacute, x, X, z, Z ]
        };

        // ISO_Level3_Shift on Right Alt
        include "level3(ralt_switch)"
        // ISO_Level5_Shift on Right Ctrl
        include "level5(rctrl_switch)"  
    };
    xkb_geometry  { include "pc(pc105)"     };
};
#+end_src

You have no idea how much time I've wasted dabbling with this... basically to
turn around and find the answers were online ... just invisible. It would be so
much easier to test the =*.xkb= file (on X11 or wherever)

#+begin_quote
Every other person who has the "skills and knowledge" has about 5 or 10 QMK
keyboards to their name. They're $300+ each. I've never touched one and maybe
I've seen one twice. There's no grey-market for hobbyist or specialist tools
like that in Roanoke, so it's like quadruple-jeopardy.
#+end_quote

*** Example: create a =type=

https://unix.stackexchange.com/a/768054

Nice to finally know what a =type= is (I feel bad because it's not like the xkb
docs are that bad, but I really needed to be able to /speak/ or /interact/ with one
of these "mythical programmer keyboard enthusiasts" or whatever)

Almost zero interaction with anyone else with passion/enthusiasm for programming
(until maybe somewhat recently). I can only describe my life as some kind of
sardonic "Chinese water torture" designed to maximize a "Tantalus" or "Buridan's
Ass" dynamic. It is fucking bullshit.

#+begin_src xkb
default partial xkb_types "default" {

    // Adds the shortcut Hyper to reach level 7
    // and Hyper+Shift to reach level 8

    virtual_modifiers  LevelThree, LevelFive, Hyper;

    type "EIGHT_LEVEL_HYPER" {
        modifiers = Shift + LevelThree + LevelFive + Hyper;
        map[None] = Level1;
        map[Shift] = Level2;
        map[LevelThree] = Level3;
        map[Shift+LevelThree] = Level4;
        map[LevelFive] = Level5;
        map[Shift+LevelFive] = Level6;
        map[Hyper] = Level7;
        map[LevelThree+LevelFive] = Level7;
        map[Shift+Hyper] = Level8;
        map[Shift+LevelThree+LevelFive] = Level8;
        level_name[Level1] = "Base";
        level_name[Level2] = "Shift";
        level_name[Level3] = "Alt Base";
        level_name[Level4] = "Shift Alt";
        level_name[Level5] = "X";
        level_name[Level6] = "X Shift";
        level_name[Level7] = "X Alt Base";
        level_name[Level8] = "X Shift Alt";
    };
};
#+end_src

Then apply the type here.

#+begin_src xkb
default partial alphanumeric_keys
xkb_symbols "level7se" {
    // Include your favourite symbols
    include "se" 

    name[Group1]="Level7-se";
    key.type[Group1] = "EIGHT_LEVEL_HYPER";

    // Copy in the lines from the symbols file of your choice and make
    // your edits, here just the button A
    key <AC01>  { [ a, A, b, B, c, C, d, D ]}; 

    // Modifier keys only have one level
    key.type[Group1] = "ONE_LEVEL";

    // Right Alt gives level 3
    key <RALT> {[ ISO_Level3_Shift ]};

    // Left Win key gives level 5 
    key <LWIN> {[ ISO_Level5_Shift ]};

    // The button to the left of the number line (paragraph on Swedish 
    // keyboards. Tilde on some others?) gives level 7.
    key <TLDE> {[ Hyper_R ]};    
};
#+end_src

Then load with =setxkbmap -types complete+level7_hyper level7se=

*** Seriously

Where the fuck was this on the internet the entire fucking time goddamit


* Modifier Bits

** TLDR

Need to check binds occasionally to grok how =# hyprlang if SOMEENVVAR= actually
works. I'm hoping I don't need to restart or relogin while I do that.

So, i remapped music/audio to keybinds, but =# hyprlang= resets the value to blank
is wrong. Are they actually mapped as such?... Nope. The keys triggering the
actions aren't either.

#+begin_src shell :results output table :var q=jqHyprBindCSV
# what's on lvl5?
hjbinds 32 | jq -r "$q"

# I guess I need an option to return everything that matches the mask
#+end_src

#+RESULTS:
| arg | catch_all | description | dispatcher | has_description | key | keycode | locked | longPress | modmask | mouse | non_consuming | release | repeat | submap |
|  11 | false     |             | workspace  | false           |     |      10 | false  | false     |      32 | false | false         | false   | false  |        |
|  12 | false     |             | workspace  | false           |     |      11 | false  | false     |      32 | false | false         | false   | false  |        |
|  13 | false     |             | workspace  | false           |     |      12 | false  | false     |      32 | false | false         | false   | false  |        |

#+name: jqHyprBindCSV
#+begin_example jq
# this should apparently go in ~/.jq/convert.jq
def json2csv:
  (map(keys) | add | unique) as $cols
  | map(. as $row | $cols | map($row[.])) as $rows
  | $cols, $rows[]
  | @csv;

map(select(.dispatcher == "workspace")) | json2csv
#+end_example


Thanks to: [[https://nntrn.github.io/jq-recipes/transform/json2csv.html][jq recipes (json2csv)]]

... as this wasn't going anywhere

#+begin_example jq
map(select(.dispatcher == "workspace")) | ([.[0] | keys] + [.[1:] | values])
# => [ [keys...], {"what": "the"}, {"eff": "??"}, {"and": "how get keythings?"}] ]
#+end_example

** Dumping =wev=

#+name: wevDump
#+begin_src shell
wev | grep depressed | sed -E 's/  +//g' | sort | uniq | cut -f2- -d' '
# and mark region, then C-u M-| "sort -k '1.7,1.8'" if necessary

# halfway faking the babel here, to avoid re-eval without worrying about :cache
#+end_src

#+RESULTS: wevDump
| 00000001: | Shift   |         |      |      |      |
| 00000004: | Control |         |      |      |      |
| 00000020: | Mod3    |         |      |      |      |
| 00000021: | Shift   | Mod3    |      |      |      |
| 00000024: | Control | Mod3    |      |      |      |
| 00000025: | Shift   | Control | Mod3 |      |      |
| 00000028: | Mod1    | Mod3    |      |      |      |
| 00000029: | Shift   | Mod1    | Mod3 |      |      |
| 0000002C: | Control | Mod1    | Mod3 |      |      |
| 0000002D: | Shift   | Control | Mod1 | Mod3 |      |
| 00000041: | Shift   | Mod4    |      |      |      |
| 00000060: | Mod3    | Mod4    |      |      |      |
| 00000061: | Shift   | Mod3    | Mod4 |      |      |
| 00000064: | Control | Mod3    | Mod4 |      |      |
| 00000065: | Shift   | Control | Mod3 | Mod4 |      |
| 00000068: | Mod1    | Mod3    | Mod4 |      |      |
| 00000069: | Shift   | Mod1    | Mod3 | Mod4 |      |
| 0000006C: | Control | Mod1    | Mod3 | Mod4 |      |
| 0000006D: | Shift   | Control | Mod1 | Mod3 | Mod4 |

And in reverse with =C-u M-| rev= the modifiers are "more clear"

#+begin_example
3doM :02000000
3doM tfihS :12000000
3doM lortnoC :42000000
3doM lortnoC tfihS :52000000
3doM 1doM :82000000
3doM 1doM tfihS :92000000
3doM 1doM lortnoC :C2000000
3doM 1doM lortnoC tfihS :D2000000
4doM :04000000
4doM tfihS :14000000
4doM 3doM :06000000
4doM 3doM tfihS :16000000
4doM 3doM lortnoC :46000000
4doM 3doM lortnoC tfihS :56000000
4doM 3doM 1doM :86000000
4doM 3doM 1doM lortnoC :C6000000
4doM 3doM 1doM lortnoC tfihS :D6000000
#+end_example

That's got most of them, but =Altgr= is hard to combine for me as =fn-home=. it may
be missing one or two. I was mainly interested in the modifier bits.

+ Ctrl is Mod1 :: adds =8=
+ Altgr is Mod2 :: adds =16=
+ LVL5 as Mod3 :: adds =32=
+ Super is Mod4 :: adds =64=

To update my =hjbinds= script:

#+begin_example emacs-lisp
;; this was a string, but now it's "emacs-lisp"
;; "
(mapcar (-partial #'+ 32) (list
0  1
       4  5
               8  9  12 13
64 65
       68 69
               72 73 76 77
               )) ;; => (32 33 36 37 40 41 44 45 96 97 100 101 104 105 108 109)
;; "
#+end_example

At the end of =mapcar=, hit C-u C-x C-e.

+ I used the same approach to update =MODMASKS= below
+ A different approach would be to munge the text for =tree=, but that:
  - There's less control over the output.
  - It requires a bit too much prep: is it now a script for a script? which part
    of this is automated?
+ Another simpler way would be to grab =MODMASKS=, loop over it and use =case=
  with bitmasks ... without =;;= for shift, ctrl, alt.

After trying the below bitmask ... is it just me or are bitmasks more convenient
than basically every other feature in =/bin/sh=? That's strange. =Food for thoug--
... (Error | out | of | memory | ??)=

** hjbinds

The script dumps binds. It only processes one bind.

#+begin_src shell
# list everything.
lvl5mod=32
for i in "$(hjbinds --list-mods)"; do
  if (( $lvl5mod & $i != 0 )); then echo $i; fi;
done | tr '\n' ' '
# that's not really that hard.

# bad ux though, but so is not being able to write #!/bin/sh & packages
#+end_src

#+RESULTS:
: 32 33 36 37 40 41 44 45 96 97 100 101 104 105 108 109

The Gemini result for "bash bitmasking" was pretty useful. I didn't know about
the =(( ... ))= syntax ... but the conditional fails if =(( ... ))= evalutes to =0=,
since it's um a =test=, which I guess is the point.

Anyways... The script dumps binds.

#+begin_src shell
#!/bin/sh

MODBITS=(1 4 8 16 32 64)
# Value for -M must match a valid mask: ${MODBITS[@]}
# nevermind... i'd rather have the caller loop the results
# M|+M) matchmasks=$OPTARG ;;

MODMASKS=(0 1 4 5 8 9 12 13 16 17 20 21 24 25 28 29 32 33 36 37 40 41 44 45 64 65 68 69 72 73 76 77 80 81 84 85 88 89 92 93 96 97 100 101 104 105 108 109)

MODHELP="
modmasks:

             shift:
             0  1        ctrl:
                         4  5         alt:
                                      8   9   12  13
    altgr:   16 17
                         20  21
                                      24  25  28  29
    lvl5:    32 33
                         36 37
                                      40  41  44  45
    super:   64 65
                         68 69
                                      72  73  76  77
      A-s:   80 81
                         84 85
                                      88  89  92  93
    A-H-s:   96 97
                        100 101
                                      104 105 108 109
"

[[ "$1" == "--list-mods" ]] && echo "${MODMASKS[@]}" && exit 0

select=""
while getopts :lroenmd OPT; do
    case $OPT in
        l|+l) select+=".locked and " ;;
        r|+r) select+=".release and " ;;
        # c|+c) select+=".click" ;;
        # g|+g) select+=".drag" ;;
        o|+o) select+=".longPress and " ;;
        e|+e) select+=".repeat and " ;;
        n|+n) select+=".non_consuming and " ;;
        m|+m) select+=".mouse and " ;;
        d|+d) select+=".has_description and " ;;
        *)
            echo "usage: `basename $0` [+-lroenmd} [--] modmask...

${MODHELP[@]}
"
            exit 2
    esac
done
shift `expr $OPTIND - 1`
OPTIND=1

[[ $# -lt 1 ]] && echo "requires modmask" && exit 1;

modmask=""
for m in ${MODMASKS[@]}; do
    if [[ "$1" == "$m" ]]; then
        modmask="$1";
    fi
done

[[ -z "$modmask" ]] && echo "a valid modmask is required" && exit 1;

set -o pipefail # ... outside of shell?
hyprctl binds -j | jq '. | map(select('"$select .modmask == $modmask"'))'

# | select(.submap == "" and .modmask == 0) '
#+end_src
* ...

Needlessly depressing overview ...

But no one ever gives a shit, if they even know what I went through, completely
alone, basically 24/7 for 12 years.

Like right now, the main reason I'm doing this is to attempt to get a =SUPER= key
on the right-hand side of my basic =$10= dell keyboard ... it's over 10 years old
and it's not that bad. But like every other stock/consumer/gamer piece of
garbage, it's designed so grandma or some degenerate can press any of the 10
function keys? So there's like TWO Function Keys with 10+ fn-based scancodes...
In case someone forgets that a Fn Key exists and can't mute the music?

Every single consumer garbage keyboard is like this, whether it's a $10 keyboard
or a $3,500 laptop. THESE ARE NOT TOOLS MADE FOR EXPERTS OR FOR PEOPLE WHO GIVE
A SHIT ABOUT DESKTOP COMPUTING AT ALL.

I do like this pc104 keyboard though, but it SUCKS to not have symmetric modkeys
(which give you FOUR different /basic/ approaches for keybindings and seriously
reduce the accumulation of repetitive strain and more if you count modifiers
that you press with each hand)
