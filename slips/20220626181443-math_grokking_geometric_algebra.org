:PROPERTIES:
:ID:       899163d3-951f-420f-bed1-013c97cd13d7
:END:
#+TITLE: Math: grokking geometric algebra
#+CATEGORY: slips
#+TAGS:
#+STARTUP: nolatexpreview

* Roam

+ [[id:a24b12f8-b3e3-4f66-9a5c-f29b715e1506][Math]]
+ [[id:73aee8fe-b894-4bda-a9b9-c1685d3249c2][SQL]]

* 6/22/22

#+begin_quote
and in fact if you have a surface with its normal versors orthogonal to it, the
flux does a scalar product against these versors so it takes account of how much
of the vector field is orthogonal to the surface (parallel to the orthogonal
versor)
#+end_quote


+ If $cos^{2}\theta + sin^{2}\theta = 1$ represents a circle
  - and $cosh^{2}\theta - sinh^{2}\theta = 1$ represents (a continuation of a
    circle? into) a hyperbola (i.e. $cosh^{2}\theta - sinh^{2}\theta =
    cos^{2}\theta + sin^{2}\theta)$ ?)
+ and if versors satisfy a similar distance equivalence over the surface of a
  sphere -- which involves $exp(ar) = cos^{2}\theta + r*sin^{2}\theta$ where r
  is a vector quaternion and $r^{2} = -1$

Then =Circle :: Hyperbola :: ...What?==

** 12/31/25

+ [[https://en.wikipedia.org/wiki/Hyperbolic_functions][wiki:Hyperbolic_Functions]]
+ [[https://en.wikipedia.org/wiki/Versor][wiki:Versor]]

I keep coming back to my notes to find info on this. It's related to a fairly
mind-blowing basis for connecting =sin= and =cos= with their hyprbolic counterparts
=sinh= and =cosh=. Everything is part of a continuum.

*** Powers of =sine= in complex domain

[[https://x.com/aionfork/status/2004258924686725171][RE to a math post on twix visualizing the powers of sine from =-n= to =n=]]

\(\left(\frac{e^{iz} - e^{iz}}{2\imath}\right)^{n}
= \sin^{n} (z)
= \left(\sin (x)\cosh (y)+i\cos (x)\sinh (y)\right)^{n}\)

This expands into a polynomial that, given the right equation or identity, can
be quickly enumerated from "=Pascal's Triforce=... idk what else to call it.
Anyways, it's the specific "meanings" of polynomials whose frequencies
constitute each coefficient in the total polynomial.

+ From line 5 (counting from zero), the \(\left(10 a^{3}b^{2} + 10 a^{2}b^{3}\right)\)
  are two cases of terms whose powers add to 5 with the same coefficient.
+ They're different events in a distribution, members in a set, permutations on
  object properties after a dataset has been processed, etc ... but for the
  relation at hand, they have similar rate of occurance (at least in the
  algebra)

#+name: pascalsAplusB
|  1 | 1 |
|  2 | 1 |
|  3 | 1 |
|  4 | 1 |
|  5 | 1 |
|  6 | 1 |
|  7 | 1 |
|  8 | 1 |
|  9 | 1 |
| 10 | 1 |
| 11 | 1 |
| 12 | 1 |

#+name: pascalsAminusB
|  1 |  1 |
|  2 | -1 |
|  3 |  1 |
|  4 | -1 |
|  5 |  1 |
|  6 | -1 |
|  7 |  1 |
|  8 | -1 |
|  9 |  1 |
| 10 | -1 |
| 11 |  1 |
| 12 | -1 |

#+name: pascalsTriangle
|---+----+----+-----+-----+-----+-----+-----+-----+-----+----+----|
| 1 |  1 |  1 |   1 |   1 |   1 |   1 |   1 |   1 |   1 |  1 |  1 |
| 1 |  2 |  3 |   4 |   5 |   6 |   7 |   8 |   9 |  10 | 11 | 12 |
| 1 |  3 |  6 |  10 |  15 |  21 |  28 |  36 |  45 |  55 | 66 |    |
| 1 |  4 | 10 |  20 |  35 |  56 |  84 | 120 | 165 | 220 |    |    |
| 1 |  5 | 15 |  35 |  70 | 126 | 210 | 330 | 495 |     |    |    |
| 1 |  6 | 21 |  56 | 126 | 252 | 462 | 792 |     |     |    |    |
| 1 |  7 | 28 |  84 | 210 | 462 | 924 |     |     |     |    |    |
| 1 |  8 | 36 | 120 | 330 | 792 |     |     |     |     |    |    |
| 1 |  9 | 45 | 165 | 495 |     |     |     |     |     |    |    |
| 1 | 10 | 55 | 220 |     |     |     |     |     |     |    |    |
| 1 | 11 | 66 |     |     |     |     |     |     |     |    |    |
| 1 | 12 |    |     |     |     |     |     |     |     |    |    |

# +TBLFM: @@=remote(pascalsAlgebra, @@)*2

#+begin_src sqlite :var p1=pascalsTriangle q1=pascalsAplusB p2=pascalsTriangle q2=pascalsAminusB invnorm=2 :nullvalue=''
create temporary table pasc1(n1 int, n2 int, n3 int, n4 int, n5 int, n6 int, n7 int, n8 int, n9 int, n10 int, n11 int, n12 int);
create temporary table pasc2(n1 int, n2 int, n3 int, n4 int, n5 int, n6 int, n7 int, n8 int, n9 int, n10 int, n11 int, n12 int);
create temporary table pasc1w(id int, w int);
create temporary table pasc2w(id int, w int);

.mode csv pasc1
.mode csv pasc2
.mode csv q1
.mode csv q2
.import $p1 pasc1
.import $p2 pasc2
.import $q1 pasc1w
.import $q2 pasc2w

-- with cte ...

select
((asign.w * a.n1) + (bsign.w * b.n1)) / $invnorm,
case (a.n2 is not null) when true then ((asign.w * a.n2) + (bsign.w * b.n2)) / $invnorm else '' end,
case (a.n2 is not null) when true then ((asign.w * a.n3) + (bsign.w * b.n3)) / $invnorm else '' end,
case (a.n2 is not null) when true then ((asign.w * a.n4) + (bsign.w * b.n4)) / $invnorm else '' end,
case (a.n2 is not null) when true then ((asign.w * a.n5) + (bsign.w * b.n5)) / $invnorm else '' end,
case (a.n2 is not null) when true then ((asign.w * a.n6) + (bsign.w * b.n6)) / $invnorm else '' end,
case (a.n2 is not null) when true then ((asign.w * a.n7) + (bsign.w * b.n7)) / $invnorm else '' end,
case (a.n2 is not null) when true then ((asign.w * a.n8) + (bsign.w * b.n8)) / $invnorm else '' end,
case (a.n2 is not null) when true then ((asign.w * a.n9) + (bsign.w * b.n9)) / $invnorm else '' end,
case (a.n2 is not null) when true then ((asign.w * a.n10) + (bsign.w * b.n10)) / $invnorm else '' end,
case (a.n2 is not null) when true then ((asign.w * a.n11) + (bsign.w * b.n11)) / $invnorm else '' end,
case (a.n2 is not null) when true then ((asign.w * a.n12) + (bsign.w * b.n12)) / $invnorm else '' end
from pasc1 as a -- , pasc2 as b
join pasc2 as b on b.n2 = a.n2
join pasc1w as asign on asign.id = a.n2
join pasc2w as bsign on bsign.id = b.n2;

-- insert into existing_table (id, n) select id,n from temp_table;

#+end_src

*** \(\left(a + b\right)^{n} + \left(a - b\right)^{n}\)

#+RESULTS:
| 1 |  1 |  1 |   1 |   1 |   1 |   1 |   1 |   1 |  1 |  1 | 1 |
|   |    |    |     |     |     |     |     |     |    |    |   |
| 1 |  3 |  6 |  10 |  15 |  21 |  28 |  36 |  45 | 55 | 66 |   |
|   |    |    |     |     |     |     |     |     |    |    |   |
| 1 |  5 | 15 |  35 |  70 | 126 | 210 | 330 | 495 |    |    |   |
|   |    |    |     |     |     |     |     |     |    |    |   |
| 1 |  7 | 28 |  84 | 210 | 462 | 924 |     |     |    |    |   |
|   |    |    |     |     |     |     |     |     |    |    |   |
| 1 |  9 | 45 | 165 | 495 |     |     |     |     |    |    |   |
|   |    |    |     |     |     |     |     |     |    |    |   |
| 1 | 11 | 66 |     |     |     |     |     |     |    |    |   |
|   |    |    |     |     |     |     |     |     |    |    |   |

*** \(\left(a + b\right)^{n} - \left(a - b\right)^{n}\)

#+RESULTS:
|   |    |    |     |     |     |     |     |     |     |    |    |
| 1 |  2 |  3 |   4 |   5 |   6 |   7 |   8 |   9 |  10 | 11 | 12 |
|   |    |    |     |     |     |     |     |     |     |    |    |
| 1 |  4 | 10 |  20 |  35 |  56 |  84 | 120 | 165 | 220 |    |    |
|   |    |    |     |     |     |     |     |     |     |    |    |
| 1 |  6 | 21 |  56 | 126 | 252 | 462 | 792 |     |     |    |    |
|   |    |    |     |     |     |     |     |     |     |    |    |
| 1 |  8 | 36 | 120 | 330 | 792 |     |     |     |     |    |    |
|   |    |    |     |     |     |     |     |     |     |    |    |
| 1 | 10 | 55 | 220 |     |     |     |     |     |     |    |    |
|   |    |    |     |     |     |     |     |     |     |    |    |
| 1 | 12 |    |     |     |     |     |     |     |     |    |    |


* 10/29/22


+ From [[https://bivector.net/doc.html][Bivector.net]]
  - [[https://bivector.net/2DPGA.pdf][2D Projective Geometric Algebra]] (cheatsheet)
  - [[https://bivector.net/3DPGA.pdf][3D Projective Geometric Algebra]] (cheatsheet)

* 10/30/22

I received the book, [[https://www.amazon.com/Geometric-Algebra-Applications-Vol-Modelling/dp/3030349764][Geometric Algebra Applications Vol. II: Robot Modelling and
Control]], a few days ago. I haven't been able to read much of it, but it's
quite comprehensive. I could only afford one volume and the second one covers
more of what I'm looking for. For whatever reason, both volumes overlap
significantly in their coverage of GA basics. This is fine. The author/publisher
seems to have correctly anticipated that readers may be interested in Robotics
but not Computer Vision, though now that I've read about how Conformal GA
connects the two, I would like the first volume.

And that is perhaps the most important thing I've learned so far:
implementations of robotics motor control requiring computer vision (i.e. any
robot algorithm that needs eyes) can be implemented with Conformal Geometric
Algebra in such a way that unifies the spaces you work within. That is the
general appeal of GA, but it may be a bit of an oversell -- though I'm not
really qualified to say.

** On Optimization

GA does require lifting and lowering your calculations with what are essentially
functors -- although someone else may call these natural transformations or
multilinear algebras or non/orthonormal basis-shifts. In practice (i have zero
experience), this means you will want /everything/ to be in GA terms .... that's
how it always is with the "unifying" programming frameworks or solutions. I'm
sure there are plenty of C/C++ libraries out there that have not swallowed the
GA pill. You'll also want a truly functional framework. Perhaps something like
haskell. It's too bad we can't have nice things -- hey, at least you're not
stuck with javascript.

It's not clear to me whether these techniques easily carry over to the GPU,
especially in spaces that are not easily rastered. I have no experience with
CUDA programming (only OpenGL/Vulkan), which is the GPU equivalent to
understanding classical mechanics but not quantum mechanics.

** Possibilities for Optimization in Hardware

Glossing over the introduction to program optimization, it seems like the
tendancy to rely heavily on C/C++ directive-based metaprogramming would imply
that in-silicon methods may be appropriate. Things like SIMD or exotic CPU
instructions...

Even better, since there are so many connections in this book to Fourier/Wavelet
transforms, perhaps low-dimensional GA computations could be virtualized inside
the kind of optical computing methods used in some bleeding edge AI chips today.
GA works because everything is a simple transformation to greatly reduced
systems. The idea that you would have calculations carried out within optical
computing (or via fourier optics) is a longshot. This may require trading
precision for speed.

I should probably actually read this before i continue to spout nonsense. It
does seem like the need to tune your data structures and abstraction design to
the specifics of the GA is a major limitation.
