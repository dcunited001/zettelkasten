:PROPERTIES:
:ID:       b3f26f1f-1527-4707-9e5f-baac3ac7b865
:END:
#+TITLE: NixOS: mixing packages and profiles with home-manager
#+CATEGORY: slips
#+TAGS:  
* Roam
+ [[id:2049060e-6755-4a64-b295-F7B563B41505][NixOS]]
+ [[id:b82627bf-a0de-45c5-8ff4-229936549942][Guix]]
  
* Docs
* Resources
In response to [[https://zaynetro.com/post/2024-you-dont-need-home-manager-nix][You may not need a Home Manager]]
* Notes

This is similar to something I had considered for Guix. It's a creative and
minimal approach. I'm a bit cynical about having too many tools and I'm not sure
how introducing each one will affect build times, storage or maintainance.

I just didn't want to end up in uncharted territory with Guix, since trying to
get the same configuration working on Guix system and arch was difficult. I'm
tryin to move towrads something in between this, hjem and home-manager.

#+begin_quote
I'm not trying to be overly critical here. I'll probably try a similar approach
& I enjoy thinking about this stuff. I've been holding off on flakes, but I
after seeing what's needed for channels (less than Guix, somewhat, but also
different) ... I need more exp. with builds, design and mainly =nix= the language
#+end_quote

Whether it would work out depends:

- on the use-case: whether the user primarily works with network, systems,
  webdev, devops, etc
- the developer's workflow, languages and tools (will linking)
- whether it's a foreign distribution/system (like darwin/bsd).
  - there shouldn't be as many issues there (idk). almost certainly there would
    be minimal coupling between home-manager builds and the system's state
- whether the user leverages the network for needs (make everything much
  simpler, except systemd network services and handling network configuration)
- how desktop components & d-bus services interact:
  - primarily an i3 & "x" bar user with bin scripts? or maintaining custom
    interfaces?
  - or half tiling WM & half custom-desktop-environment? d-bus decouples a lot
    of this, but need to choose whether interfaces deploy from system or =hm= or
    elsewhere.
- whether the user can anticipate where cognitive load increases.
  - which configs/scripts reference links & why
  - where can layers of abstraction be injected. e.g. instead of stylix, maybe
    push a config file update & let pywal read it. but this is more cognitive
    load & moving parts (honestly so is home configuration management anyways)
  - what's the system state and will services/processes need to restart.
  - what I had been designing would end up changing, but I didn't have enough
    experience with desktop packaging/etc (arch on easy mode, until it's not)


**** Approaches and Potential issues

+ You keep paths/shebangs/etc pointing to links, wherever possible.
  - org-tangle could produce some resulting configs files, but unless they're
    completely separate, it's not reproducible. even if it is, it's technically
    not pure
+ SystemD units can be connecting units together using symbolic references (by
  needs/wants/etc)
  - this can be usually be worked around by separating phases in the home build:
    system, packages/profile (or jinja/org-tangle) and finally hm.
  - stale sockets
  - updates to d-bus interfaces. d-bus is designed to decouple components from
    each other
+ Shebangs would also ideally point to links. I'm not sure, but that's
  difficult/impossible for shebangs unless you reserialize or push data into the
  serialization phase

+ Activation of systemd services
  - updating slices/scopes
  - load order if units need restarting between updates (but dependences aren't
    confined to scopes)

+ Serialization of configs/scripts is a lot of work. Much of this is simpler
  with Nix, I think. With Guix, your records specify an interface and are
  consumed by serializers (standard or custom). The latter was biggest blocker
  for me bc if I didn't anticipate some aspect of the g-exp's, diagnosing it
  requires tinkering with a ship in a bottle (whether during the build phases or
  afterwards).

+ When producing derived files/scripts with home-manager though, the tools you
  configure will end up stovepiped, since it's more costly to work around cases
  where there's interdependencies.
  - e.g. stylix produces themes 4 waybar/swaync that need to launch scripts
    calling other scripts/tools

**** TL;DR;

At some level or another, =hm= and =nixos= users want more customization &
efficiency. Regardless of where the complexity is, whether upstream (req.
pinning) or created in the repo, there's no eliminating it, since it's inherent
in the domain.

#+begin_quote
See [[https://lawsofux.com/articles/2024/teslers-law/#:~:text=The%20following%20is%20an%20excerpt,complexity%20that%20cannot%20be%20reduced.][Tesler's Law]]. Given a rough measure of complexity for each component, the
total complexity lies between the sum & product of all the components.
#+end_quote

With home configuration, users create their own complexity (i.e. lots of
ruby-goldberg footguns). External tooling helps a lot, but pre-figures many
aspects of design. The more complex the compoents, their interactions and the
users needs ... the more difficult it is to anticiate how design changes. With
upstream tooling, then it's at least well-tested and the incremental
development/testing has been socialized (... but users do need to at least grok
it first & that requires acclimation to the tooling/ecosystem)

***** Docs

Some way to get more users spending face-time or pair programming. Things like
planned/organized meetups or team config contests or would help drive engagement
required to share ideas and drive mindshare... maybe? Or maybe just "office
hours" with streaming and a pair-programming VSCode server (or T-Mux/Vim)

For example, I've heard a lot online about the docs being scattered or out of
date. I've checked in from time-to-time, but never really needed them. I mainly
looked at the source to see how things were built while trying to replicate a
package on Guix...

But now that I have the nixpkgs source on my machine, it's easy to extract, grep
through & work with. I don't really use a lot of Vim tooling. I'm not exactly
"good at this" ... but if I couldn't query the source code like a database, I
would never figure much out for any language/ecosystem.

What I'm trying to say is that the "archwiki" model is not really a great
approach to providing documentation, since the source code itself is always 100%
current. Given how many interdependencies/recipes/etc are accounted for in the
=nixpkgs= source (and how simple the =nix= language is once you grok it) there
shouldn't be much need to to refer to external documentation.

The problem is bootstrapping new users who have been culturally programmed to
learn that way. There may be shortcomings on tooling (or automating pulling
sources), but getting info from the web is generally extremely slow.

