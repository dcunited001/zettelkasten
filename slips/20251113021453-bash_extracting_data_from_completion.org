:PROPERTIES:
:ID:       bf65099a-f570-4dbd-b2bd-fd237628714a
:END:
#+TITLE: Bash: Extracting Data From Completion
#+CATEGORY: slips
#+TAGS:
* Roam
+ [[id:cf847bc5-31f7-4bb8-8324-7680a8f2953d][Shell]]
+ [[id:49373db0-532d-4b0f-b8ec-3f9a3f897895][Step CA]]

* Docs

* Resources

* Notes

There's about 270 subcommands lol, so I need a way to compress the information &
prioritize it. There are interactive ways to utilize =step= and =step ca=, but I
really just want to script through the creation, so i can regen artifacts
quickly. This doesn't include much of =step kms=, I think.

The complexity is organized as follows:

+ step crypto :: low-level crypto utilities
  - hash, jose, jwe, jwk, jws, jwt, kdf, key, nacl, otp
+ step {crl,fileserver,oauth,path,api,base64,beta,context} :: misc commands
+ step ssh :: ssh certificate commands
+ step certificate :: certificiate lifecycle & management utilities
  
The bulk of the complexity is found under the =step ca= subcommands, where the
most number of unique options are under =step ca {init,certificate,bootstrap}=

+ step ca {acme,policy acme} :: acme configuration (and external account binding)
+ step ca {provisioner, provisioner ssh, provisioner x509} :: provisioner
  configuration  
+ step ca {policy, policy authority ssh, policy authority x509} :: policy
  configuration
+ step ca {bootstrap,health} :: bootstrapping a =step ca= client
+ step ca init :: initializing a CA
+ step ca certificate :: issue root-signed certificates
+ step ca sign :: sign a CSR and generate its certificate
+ step ca {rekey,renew,revoke,token} :: misc certificate management
+ step ca admin :: manage admin users for a CA
+ step ca {root,roots,federation} :: manage cert bundles

* From File Tree
:PROPERTIES:
:header-args+: :dir "/data/ecto/crypto/smallstep/docs/step-cli/reference"
:END:

It's easier to clone the smallstep/docs repo and run:

#+begin_src shell
repo=$(pwd)
cd reference
tree -d .
#+end_src

state machine ftw

#+name: awkStepCmdInfo
#+begin_example awk
BEGIN { inName=0; inUsage=0; inOptions=0; inRaw=0; } 
($0 ~/^## Name/) { inName=1; inUsage=0; inOptions=0; inRaw=0; print "#",FILENAME; next; }
($0 ~/^## Usage/) { inName=0; inUsage=1; inOptions=0; inRaw=0; next; }
($0 ~/^## .*$/ && inOptions==1) { inName=0; inUsage=0; inOptions=0; inRaw=0; exit; } # next; } 
($0 ~/^## Options/) { inName=0; inUsage=0; inOptions=1; inRaw=0; print "## Options"; next; }
($0 ~/^```$/ && inRaw==1) { inName=0; inUsage=0; inRaw=0; next; }
($0 ~/^```raw$/ && inUsage==1) { inName=0; inUsage=1; inRaw=1; next; }
(inName==1) { print $0; next; }
(inRaw==1) { print $0; next; }
(inOptions==1) { print $0; next; }

#+end_example

#+headers: :var awkprog=awkStepCmdInfo
#+begin_src shell :results output file :file "../step-cli-usage-options.mdx"
mdx=$(find . -mindepth 2 -name '*.mdx' -type f -printf '%p\n' | sort)
i=0
for f in $mdx; do
    i="$((i+1))";
    gawk "$awkprog" $f
    # [[ $i -gt 20 ]] && break
done
#+end_src

#+RESULTS:
[[file:../../../ecto/crypto/smallstep/docs/step-cli/step-cli-usage-options.mdx]]

Count options (imperfect, but sufficient)

#+name: stepCountOptions
#+begin_src shell :results output verbatim :var group="../step-cli-usage-options.mdx" n=25
grep -E '^\*\*-' "$group" \
| tr -d '*' | sort | uniq -c \
| sort -rnk1 | head -n"$n"
#+end_src

#+RESULTS: stepCountOptions
#+begin_example
    101 --context=`name`
    101 --ca-url=`URI`
    100 --root=`file`
     79 --admin-subject=`subject`, --admin-name=`subject`
     78 --admin-provisioner=`name`, --admin-issuer=`name`
     78 --admin-key=`file`
     78 --admin-cert=`chain`
     76 --admin-password-file=`file`, --password-file=`file`
     65 --provisioner=`name`, --issuer=`name`
     50 --remove
     34 --eab-key-reference=`value`
     34 --eab-key-id=`value`
     28 -f, --force
     23 --password-file=`file`
     22 --ca-config=`file`
     16 --offline
     13 --insecure
     11 --set=`key=value`
     11 --set-file=`file`
     11 --key=`file`
     10 --provisioner=`name`
     10 --kid=`kid`
      9 --raw
      8 --provisioner-password-file=`file`
      8 --no-password
#+end_example

#+name: stepDumpOptions
#+begin_src shell :results output verbatim :var group="../step-cli-usage-options.mdx" n=25
grep -E '^\*\*-' "$group" \
| tr -d '*' | sort | uniq
#+end_src

** =step certificate=

#+headers: :var awkprog=awkStepCmdInfo
#+begin_src shell :results output file :file "../step-cli-usage-certificate.mdx"
mdx=$(find certificate -mindepth 2 -name '*.mdx' -type f -printf '%p\n' | sort)
for f in $mdx; do
    gawk "$awkprog" $f
done
#+end_src

#+RESULTS:
[[file:../../../ecto/crypto/smallstep/docs/step-cli/step-cli-usage-certificate.mdx]]

#+call: stepCountOptions(group="../step-cli-usage-certificate.mdx")

#+RESULTS:
#+begin_example
      5 --servername=`value`
      5 --roots=`roots`
      5 --insecure
      5 -f, --force
      5 --bundle
      3 --password-file=`file`
      2 --verbose, -v
      2 --template=`file`
      2 --set=`key=value`
      2 --set-file=`file`
      2 --profile=`profile`
      2 --prefix=`name`
      2 --not-before=`time|duration`
      2 --not-after=`time|duration`
      2 --no-system
      2 --no-password
      2 --kms=`uri`
      2 --java
      2 --format=`format`
      2 --firefox
      2 --all
      1 --verify-ocsp
      1 --verify-crl
      1 --subtle
      1 --skip-csr-signature
#+end_example
** =step ca policy=

#+headers: :var awkprog=awkStepCmdInfo
#+begin_src shell :results output file :file "../step-cli-usage-ca-policy.mdx"
mdx="$(find ca -mindepth 2 -name '*.mdx' -type f -printf '%p\n' | sort \
    | grep -E 'ca/policy' \
    | grep -v '/acme' \
    | grep -v '/provisioner')"
for f in $mdx; do
    gawk "$awkprog" $f
done
#+end_src

#+RESULTS:
[[file:../../../ecto/crypto/smallstep/docs/step-cli/step-cli-usage-ca-policy.mdx]]

#+call: stepCountOptions(group="../step-cli-usage-ca-policy.mdx")

#+RESULTS:
#+begin_example
     24 --root=`file`
     24 --context=`name`
     24 --ca-url=`URI`
     24 --admin-subject=`subject`, --admin-name=`subject`
     24 --admin-provisioner=`name`, --admin-issuer=`name`
     24 --admin-password-file=`file`, --password-file=`file`
     24 --admin-key=`file`
     24 --admin-cert=`chain`
     22 --provisioner=`name`, --issuer=`name`
     20 --remove
     12 --eab-key-reference=`value`
     12 --eab-key-id=`value`
      2 --provisioner=`name`
#+end_example

** =step ca provisioner=

#+headers: :var awkprog=awkStepCmdInfo
#+begin_src shell :results output file :file "../step-cli-usage-ca-provisioner.mdx"
mdx="$(find ca -mindepth 2 -name '*.mdx' -type f -printf '%p\n' \
    | sort \
    | grep -E 'ca(/policy)?/provisioner')"
for f in $mdx; do
    gawk "$awkprog" $f
done
#+end_src

#+RESULTS:
[[file:../../../ecto/crypto/smallstep/docs/step-cli/step-cli-usage-ca-provisioner.mdx]]

#+call: stepCountOptions(group="../step-cli-usage-ca-provisioner.mdx")

#+RESULTS:
#+begin_example
     32 --root=`file`
     32 --context=`name`
     32 --ca-url=`URI`
     30 --admin-subject=`subject`, --admin-name=`subject`
     30 --admin-provisioner=`name`, --admin-issuer=`name`
     30 --admin-key=`file`
     30 --admin-cert=`chain`
     28 --admin-password-file=`file`, --password-file=`file`
     22 --provisioner=`name`, --issuer=`name`
     20 --remove
     12 --eab-key-reference=`value`
     12 --eab-key-id=`value`
      6 --ca-config=`file`
      2 --x5c-roots=`file`, --x5c-root=`file`
      2 --x509-template=`file`
      2 --x509-template-data=`file`
      2 --x509-min-dur=`duration`
      2 --x509-max-dur=`duration`
      2 --x509-default-dur=`duration`
      2 --url=`value`
      2 --tenant-id=`tenant-id`
      2 --ssh-user-min-dur=`duration`
      2 --ssh-user-max-dur=`duration`
      2 --ssh-user-default-dur=`duration`
      2 --ssh-template=`file`
#+end_example

** =step ca {acme,policy acme}=

#+headers: :var awkprog=awkStepCmdInfo
#+begin_src shell :results output file :file "../step-cli-usage-ca-acme.mdx"
mdx="$(find ca -mindepth 2 -name '*.mdx' -type f -printf '%p\n' \
    | sort \
    | grep -E 'ca(/policy)?/acme')"
for f in $mdx; do
    gawk "$awkprog" $f
done
#+end_src

#+RESULTS:
[[file:../../../ecto/crypto/smallstep/docs/step-cli/step-cli-usage-ca-acme.mdx]]

#+call: stepCountOptions(group="../step-cli-usage-ca-acme.mdx")

#+RESULTS:
#+begin_example
     17 --root=`file`
     17 --context=`name`
     17 --ca-url=`URI`
     17 --admin-subject=`subject`, --admin-name=`subject`
     17 --admin-provisioner=`name`, --admin-issuer=`name`
     17 --admin-password-file=`file`, --password-file=`file`
     17 --admin-key=`file`
     17 --admin-cert=`chain`
     12 --provisioner=`name`, --issuer=`name`
     10 --remove
     10 --eab-key-reference=`value`
     10 --eab-key-id=`value`
      2 --provisioner=`name`
      1 --no-pager
      1 --limit=`value`
#+end_example

** =step ca=

*** =step ca init=

#+headers: :var awkprog=awkStepCmdInfo
#+begin_src shell :results output file :file "../step-cli-usage-ca-init.mdx"
f=ca/init/README.mdx
gawk "$awkprog" $f
#+end_src

#+RESULTS:
[[file:../../../ecto/crypto/smallstep/docs/step-cli/step-cli-usage-ca-init.mdx]]

#+call: stepDumpOptions(group="../step-cli-usage-ca-init.mdx")

#+RESULTS:
#+begin_example
--acme
--address=`address`
--admin-subject=`subject`, --admin-name=`subject`
--authority=`name`
--context=`name`
--credentials-file=`file`
--deployment-type=`name`
--dns=`name`
--helm
--issuer-fingerprint=`fingerprint`
--issuer-provisioner=`name`
--issuer=`url`
--key=`file`
--key-password-file=`file`
--kms-intermediate=`URI`
--kms-root=`URI`
--kms-ssh-host=`URI`
--kms-ssh-user=`URI`
--kms=`type`
--name=`name`
--no-db
--password-file=`file`
--pki
--profile=`name`
--provisioner=`name`
--provisioner-password-file=`file`
--ra=`type`
--remote-management
--root=`file`
--ssh
--with-ca-url=`URI`
#+end_example

*** =step ca certificate=

#+headers: :var awkprog=awkStepCmdInfo
#+begin_src shell :results output file :file "../step-cli-usage-ca-certificate.mdx"
f=ca/certificate/README.mdx
gawk "$awkprog" $f
#+end_src

#+RESULTS:
[[file:../../../ecto/crypto/smallstep/docs/step-cli/step-cli-usage-ca-certificate.mdx]]

#+call: stepDumpOptions(group="../step-cli-usage-ca-certificate.mdx")

#+RESULTS:
#+begin_example
--acme=`url`
--attestation-ca-root=`file`
--attestation-ca-url=`value`
--attestation-uri=`uri`
--ca-config=`file`
--ca-url=`URI`
--console
--contact=`email-address`
--context=`name`
--crv=`curve`, --curve=`curve`
-f, --force
--http-listen=`address`
--k8ssa-token-path=`file`
--kms=`uri`
--kty=`kty`
--nebula-cert=`file`
--nebula-key=`file`
--not-after=`time|duration`
--not-before=`time|duration`
--offline
--password-file=`file`
--provisioner=`name`, --issuer=`name`
--provisioner-password-file=`file`
--root=`file`
--san=`dns|ip|email|uri`
--set-file=`file`
--set=`key=value`
--size=`size`
--standalone
--token=`token`
--tpm-storage-directory=`value`
--webroot=`file`
--x5c-cert=`chain`
--x5c-chain=`file`
--x5c-key=`file`
#+end_example

*** =step ca sign=

#+headers: :var awkprog=awkStepCmdInfo
#+begin_src shell :results output file :file "../step-cli-usage-ca-sign.mdx"
f=ca/sign/README.mdx
gawk "$awkprog" $f
#+end_src

#+RESULTS:
[[file:../../../ecto/crypto/smallstep/docs/step-cli/step-cli-usage-ca-sign.mdx]]

#+call: stepDumpOptions(group="../step-cli-usage-ca-sign.mdx")

#+RESULTS:
#+begin_example
--acme=`url`
--ca-config=`file`
--ca-url=`URI`
--console
--contact=`email-address`
--context=`name`
-f, --force
--http-listen=`address`
--k8ssa-token-path=`file`
--kms=`uri`
--nebula-cert=`file`
--nebula-key=`file`
--not-after=`time|duration`
--not-before=`time|duration`
--offline
--password-file=`file`
--provisioner=`name`, --issuer=`name`
--provisioner-password-file=`file`
--root=`file`
--set-file=`file`
--set=`key=value`
--standalone
--token=`token`
--webroot=`file`
--x5c-cert=`chain`
--x5c-chain=`file`
--x5c-key=`file`
#+end_example

*** =step ca {bootstrap,health}=

#+headers: :var awkprog=awkStepCmdInfo
#+begin_src shell :results output file :file "../step-cli-usage-ca-bootstrap.mdx"
gawk "$awkprog" ca/{bootstrap,health}/README.mdx
#+end_src

#+RESULTS:
[[file:../../../ecto/crypto/smallstep/docs/step-cli/step-cli-usage-ca-bootstrap.mdx]]

#+call: stepDumpOptions(group="../step-cli-usage-ca-bootstrap.mdx")

#+RESULTS:
#+begin_example
--authority=`name`
--ca-url=`URI`
--context=`name`
-f, --force
--fingerprint=`fingerprint`
--install
--profile=`name`
--redirect-url=`url`
--team-authority=`sub-domain`
--team=`ID`
--team-url=`url`
#+end_example


*** =step ca {root,roots,federation}=

#+headers: :var awkprog=awkStepCmdInfo
#+begin_src shell :results output file :file "../step-cli-usage-ca-roots.mdx"
gawk "$awkprog" ca/{root,roots,federation}/README.mdx
#+end_src

#+RESULTS:
[[file:../../../ecto/crypto/smallstep/docs/step-cli/step-cli-usage-ca-roots.mdx]]

#+call: stepDumpOptions(group="../step-cli-usage-ca-roots.mdx")

#+RESULTS:
: --ca-url=`URI`
: --context=`name`
: -f, --force
: --fingerprint=`fingerprint`
*** =step ca {
+ =step ca {rekey,renew,revoke,token}=

#+headers: :var awkprog=awkStepCmdInfo
#+begin_src shell :results output file :file "../step-cli-usage-ca-rekey.mdx"
gawk "$awkprog" ca/{rekey,renew,revoke,token}/README.mdx
#+end_src

#+RESULTS:
[[file:../../../ecto/crypto/smallstep/docs/step-cli/step-cli-usage-ca-rekey.mdx]]

#+call: stepDumpOptions(group="../step-cli-usage-ca-rekey.mdx")

#+RESULTS:
#+begin_example
--ca-config=`file`
--ca-url=`URI`
--crv=`curve`, --curve=`curve`
--daemon
--exec=`command`
--expires-in=`duration`
-f, --force
--kms=`uri`
--kty=`kty`
--offline
--out-cert=`file`
--out-key=`file`
--password-file=`file`
--pid-file=`file`
--pid=`value`
--private-key=`file`
--rekey-period=`duration`
--rekey-period or --expires-in flags.
--root=`file`
--signal=`number`
--size=`size`
#+end_example


*** =step ca admin=

#+headers: :var awkprog=awkStepCmdInfo
#+begin_src shell :results output file :file "../step-cli-usage-ca-admin.mdx"
gawk "$awkprog" ca/admin/*/README.mdx
#+end_src

#+RESULTS:
[[file:../../../ecto/crypto/smallstep/docs/step-cli/step-cli-usage-ca-admin.mdx]]

#+call: stepDumpOptions(group="../step-cli-usage-ca-admin.mdx")

#+RESULTS:
: --admin-cert=`chain`
: --admin-key=`file`
: --admin-password-file=`file`, --password-file=`file`
: --admin-provisioner=`name`, --admin-issuer=`name`
: --admin-subject=`subject`, --admin-name=`subject`
: --ca-url=`URI`
: --context=`name`
: --root=`file`
: --super

** =step crypto=

#+headers: :var awkprog=awkStepCmdInfo
#+begin_src shell :results output file :file "../step-cli-usage-crypto.mdx"
mdx=$(find crypto -mindepth 2 -name '*.mdx' -type f -printf '%p\n' | sort)
for f in $mdx; do
    gawk "$awkprog" $f
done
#+end_src

#+RESULTS:
[[file:../../../ecto/crypto/smallstep/docs/step-cli/step-cli-usage-crypto.mdx]]

#+call: stepCountOptions(group="../step-cli-usage-crypto.mdx")

#+RESULTS:
#+begin_example
     11 --password-file=`file`
      9 --kid=`kid`
      8 --raw
      8 -f, --force
      6 --key=`file`
      6 --jwks=`jwks`
      5 --alg=`algorithm`, --algorithm=`algorithm`
      5 --alg=`algorithm`
      4 --no-password
      4 --insecure
      2 --x5t-cert=`file`
      2 --x5c-cert=`chain`
      2 --ssh
      2 --size=`size`
      2 --pss
      2 --period=`value`
      2 --length=`value`, --digits=`value`
      2 --key=`file`, --x5c-key=`file`, --x5t-key=`file`
      2 --json
      2 --iss=`issuer`, --issuer=`issuer`
      2 --insecure flag and omit the --alg flag.
      2 --format=`format`
      2 --crv=`curve`, --curve=`curve`
      2 --aud=`audience`, --audience=`audience`
      2 --alg=`value`, --algorithm=`value`
#+end_example
** =step ssh=

#+headers: :var awkprog=awkStepCmdInfo
#+begin_src shell :results output file :file "../step-cli-usage-ssh.mdx"
mdx=$(find ssh -mindepth 2 -name '*.mdx' -type f -printf '%p\n' | sort)
for f in $mdx; do
    gawk "$awkprog" $f
done
#+end_src

#+RESULTS:
[[file:../../../ecto/crypto/smallstep/docs/step-cli/step-cli-usage-ssh.mdx]]

#+call: stepCountOptions(group="../step-cli-usage-ssh.mdx")

#+RESULTS:
#+begin_example
     10 --root=`file`
     10 --offline
     10 --context=`name`
     10 --ca-url=`URI`
     10 --ca-config=`file`
      6 --set=`key=value`
      6 --set-file=`file`
      6 --provisioner=`name`, --issuer=`name`
      5 -f, --force
      5 --console
      4 --provisioner-password-file=`file`
      3 --token=`token`
      3 --sshpop-key=`file`
      3 --sshpop-cert=`chain`
      3 --insecure
      2 --verbose, -v
      2 --size=`size`
      2 --provisioner-password-file=`file`, --password-file=`file`
      2 --not-before=`time|duration`
      2 --not-after=`time|duration`
      2 --no-password
      2 --kty=`kty`
      2 --identity=`value`
      2 --host
      2 --format=`format`
#+end_example

** =step {crl,fileserver,oauth,path,api,base64,beta,context}=

#+headers: :var awkprog=awkStepCmdInfo
#+begin_src shell :results output file :file "../step-cli-usage-misc.mdx"
mdx=$(find {crl,fileserver,oauth,path,api,base64,beta,context} -mindepth 2 -name '*.mdx' -type f -printf '%p\n' | sort)
for f in $mdx; do
    gawk "$awkprog" $f
done
#+end_src

#+RESULTS:
[[file:../../../ecto/crypto/smallstep/docs/step-cli/step-cli-usage-misc.mdx]]

Options

#+call: stepCountOptions(group="../step-cli-usage-misc.mdx")

#+RESULTS:
#+begin_example
      3 --root=`file`
      3 --context=`name`
      3 --ca-url=`URI`
      3 --admin-subject=`subject`, --admin-name=`subject`
      3 --admin-provisioner=`name`, --admin-issuer=`name`
      3 --admin-password-file=`file`, --password-file=`file`
      3 --admin-key=`file`
      3 --admin-cert=`chain`
      1 --roots=`roots`
      1 --no-pager
      1 --limit=`value`
      1 --json
      1 --insecure
      1 --from
      1 --format=`format`
      1 -f, --force
      1 --ca=`file`
      1 --audience=`value`
      1 --api-url=`value`
#+end_example

* From Completion
** Basics

Some of this was provided by gemini I guess lol

It may be more useful to extract data from =zsh= completion. Since it's more fully
featured, the data may be more convenient to process.

Display the registered completion specification

#+begin_src shell
source <(step completion bash)
complete -p step
#+end_src

#+RESULTS:
: complete -o bashdefault -o default -F _step_cli_bash_autocomplete step

*** Inherently interactive

Completion relies on variables injected during interaction

#+name: stepCompSpec
#+begin_src shell :results output code :wrap src shell
step completion bash
# echo '' # these are too long
# step kms completion bash
#+end_src

#+RESULTS: stepCompSpec
#+begin_src shell
# bash completion for step
_step_cli_bash_autocomplete() {
        local cur opts base
        COMPREPLY=()
        cur="${COMP_WORDS[COMP_CWORD]}"
        if [[ "$cur" == "-"* ]]; then
                opts=$( ${COMP_WORDS[@]:0:$COMP_CWORD} ${cur} --generate-bash-completion )
        else
                opts=$( ${COMP_WORDS[@]:0:$COMP_CWORD} --generate-bash-completion )
        fi
        COMPREPLY=( $(compgen -W "${opts}" -- ${cur}) )
        return 0
}

complete -o bashdefault -o default -F _step_cli_bash_autocomplete step

#+end_src

** Brute Force

Monkeypatch the function and it echos to the console

#+begin_src shell :results output code :wrap src shell
_step_cli_bash_autocomplete() {
        local cur opts base
        COMPREPLY=()
    echo $cur $COMP_CWORD # ---------------------------------------------
    # $cur contains the final incomplete word
        cur="${COMP_WORDS[COMP_CWORD]}"
        if [[ "$cur" == "-"* ]]; then
        echo ${COMP_WORDS[@]:0:$COMP_CWORD} '::' $opts # -----------------
        # if $cur starts with a dash, pass it in to step ${cur} --generate-bash-completion
                opts=$( ${COMP_WORDS[@]:0:$COMP_CWORD} ${cur} --generate-bash-completion )
        else
        echo ${COMP_WORDS[@]:0:$COMP_CWORD} ${cur} '::' $opts # ----------
        # otherwise call without args
                opts=$( ${COMP_WORDS[@]:0:$COMP_CWORD} --generate-bash-completion )
        fi
        COMPREPLY=( $(compgen -W "${opts}" -- ${cur}) ) # --------------------
    # this completion function uses `compgen -W` for completion response
    #
        return 0
}
#+end_src

*** Setting prompt

this dumps all the statements eval'd. i encountered PS4 when customizing my bash
prompt ... but i guess i missed =set -x= or something

#+begin_src shell
set -x
#+end_src

+ change your shell prompt to an obvious color & remove any dynamic
  functionality (or it dumps)
+ if you're controlling bash from another process (like emacs =comint-mode=), =PS1=
  can't include control characters and must be recognizable.

#+begin_src shell
# IIRC these escape sequences are supposed to be:
# - opened by \001 and followed by \002
# - where \000 would be the null char

# idk if \002 is 100% correct, but you definitely want to open/close context
PS1=$(echo -en '\001\033[01;44;33m\002 <$> \001\033[0m\002')
PS4=$(echo -en '\001\033[00;47;31m\002\t\001\033[0m\002')
#+end_src

+ Tabs can be eaten as commands without worrying about escaping/unescaping.
  - the lines wrap, and so these commands can be filtered then redirected
    elsewhere to maybe be evaluated (idk)
  - as long as the bytes around newlines are =\n\t+= (regexp), then it's trivial
    to spot. it's insufficient though (e.g. if source code is dumped)
+ The standout effect doesn't show up for tabs. i'd be working in terminal more
  than =comint-mode=, =tmux= or =screen=

#+begin_src shell
tput smso | hexdump -C # 1b5b      37 6d :: standout (swap fg/bg)
tput sgr0 | hexdump -C # 1b28 42 1b5b 6d :: reset attributes
tput setaf $n # 1b5b 343n 6d :: set foreground color n
tput setab $n # 1b5b 333n 6d :: set foreground color n
RESTORE=$(echo -en '\001\033[0m\002')
PS4="$(tput setab 2) $RESTORE" # using space instead, tab doesn't get colorized
# PS4="$(tput setab 7)\t$RESTORE"
#+end_src

** Robot

* Other methods

** Tracing

#+begin_example shell
set -x
step # tab
set +x
#+end_example

* Step

#+name: stepFilterSubcmds
| h          |
| help       |
| version    |
| completion |
| beta       |

#+name: stepFilterOptions
| -h        |
| --help    |
| -v        |
| --version |

#+name: stepSubcmds
#+begin_src shell :results output table :var fcmds=stepFilterSubcmds fopts=stepFilterOptions
comm -2 -3 <(step --generate-bash-completion | sort) \
    <(echo ${fcmds[@]} | tr ' ' '\n' | sort) \
    | tr -d '\t'
#+end_src

#+RESULTS: stepSubcmds
| base64      |
| beta        |
| ca          |
| certificate |
| context     |
| crl         |
| crypto      |
| oauth       |
| path        |
| ssh         |

#+name: stepAllSubcmds
#+begin_src shell :results output table :var cmds=stepSubcmds fcmds=stepFilterSubcmds fopts=stepFilterOptions
# first two levels
for c in ${cmds[@]}; do
    comm -2 -3 <(step $c --generate-bash-completion | sort) \
        <(echo ${fcmds[@]} | tr ' ' '\n' | sort) \
        | tr -d '\t'
done | sort | uniq
#+end_src

#+RESULTS: stepAllSubcmds
| acme          |
| admin         |
| bootstrap     |
| bundle        |
| ca            |
| certificate   |
| change-pass   |
| check-host    |
| config        |
| create        |
| current       |
| federation    |
| fingerprint   |
| format        |
| hash          |
| health        |
| hosts         |
| init          |
| inspect       |
| install       |
| jose          |
| jwe           |
| jwk           |
| jws           |
| jwt           |
| kdf           |
| key           |
| keypair       |
| lint          |
| list          |
| login         |
| logout        |
| nacl          |
| needs-renewal |
| otp           |
| p12           |
| policy        |
| provisioner   |
| proxycommand  |
| rand          |
| rekey         |
| remove        |
| renew         |
| revoke        |
| root          |
| roots         |
| select        |
| sign          |
| token         |
| uninstall     |
| verify        |
| winpe         |

#+name: stepSubcmdCompletion
#+begin_src shell :results output table :var cmd="acme" fcmds=stepFilterSubcmds fopts=stepFilterOptions
comm -2 -3 <(step $cmd --generate-bash-completion | sort) \
    <(echo ${fcmds[@]} | tr ' ' '\n' | sort) \
    | tr -d '\t'
#+end_src

#+RESULTS: stepSubcmdCompletion
| base64      |
| beta        |
| ca          |
| certificate |
| context     |
| crl         |
| crypto      |
| oauth       |
| path        |
| ssh         |

#+name: dotFormatNodes
#+begin_src emacs-lisp :var ul=stepSubcmds
(string-join
 (mapcar (lambda (el) (format "\"%s\"" (car el))) ul)
            " ")
#+end_src

#+RESULTS: dotFormatNodes
: "base64" "beta" "ca" "certificate" "context" "crl" "crypto" "oauth" "path" "ssh"

#+name: dotFormatEdges
#+begin_src emacs-lisp :var a="beta" b=stepSubcmdCompletion(cmd="oauth")
(let* ((b (or (and (stringp b) (list (list b))) b))
       (bb (->> b
            (mapcar #'car)
            (mapcar (apply-partially #'format "\"%s\"")))))
  (if b (format "\"%s\" -> {%s}" a (string-join bb ",")) ""))
#+end_src

#+RESULTS: dotFormatEdges

#+begin_src dot :file img/devops/step-cli-completion.svg :noweb yes
digraph G {
    rankdir=LR
    // rankdir=TB
    <<dotFormatNodes(ul=stepSubcmds)>>

    <<dotFormatEdges(a="acme", b=stepSubcmdCompletion(cmd="acme"))>>
    <<dotFormatEdges(a="base64", b=stepSubcmdCompletion(cmd="base64"))>>
    <<dotFormatEdges(a="certificate", b=stepSubcmdCompletion(cmd="certificate"))>>
    <<dotFormatEdges(a="context", b=stepSubcmdCompletion(cmd="context"))>>
    <<dotFormatEdges(a="crl", b=stepSubcmdCompletion(cmd="crl"))>>
    <<dotFormatEdges(a="crypto", b=stepSubcmdCompletion(cmd="crypto"))>>
    <<dotFormatEdges(a="oauth", b=stepSubcmdCompletion(cmd="oauth"))>>
    <<dotFormatEdges(a="path", b=stepSubcmdCompletion(cmd="path"))>>
    <<dotFormatEdges(a="ssh", b=stepSubcmdCompletion(cmd="ssh"))>>
}
#+end_src

#+RESULTS:
[[file:img/devops/step-cli-completion.svg]]

#+begin_src dot :file img/devops/step-ca-completion.svg :noweb yes
digraph G {
    rankdir=LR
    // rankdir=TB
    <<dotFormatNodes(ul=stepSubcmdCompletion(cmd="ca"))>>
    <<dotFormatEdges(a="ca", b=stepSubcmdCompletion(cmd="ca"))>>
}
#+end_src

#+RESULTS:
[[file:img/devops/step-ca-completion.svg]]
