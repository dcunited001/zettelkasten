:PROPERTIES:
:ID:       50d520d1-262a-40fd-8afd-47cf1e6dad62
:END:
#+TITLE: GNUPG: Rotate Yubikey Subkeys And Rekey Secrets
#+CATEGORY: slips
#+TAGS:
* Roam
+ [[id:c2afa949-0d1c-4703-b69c-02ffa854d4f4][Cryptography]]
+ [[id:b987ce8b-c42f-4de2-83c4-350be3cf5de1][GNUPG]]

* Notes
:PROPERTIES:
:header-args+: :var gpg-tangle-dir=(expand-file-name "gpg-tangle-dir" (or (bound-and-true-p ob@gnupg_useful_scripts_to_help_rekey_yubikey_and_rekey_secrets) (setq ob@gnupg_useful_scripts_to_help_rekey_yubikey_and_rekey_secrets (make-temp-file "roam-" t))))
:END:

These are some scripts I wrote while in console emacs on my airgapped system
(see [[https://github.com/dcunited001/ellipsis/tree/master/ellipsis/ellipsis/system/usb-gpg-tools.scm][usb-gpg-tools.scm]] from my dotfiles). Most of the code is derivative from
[[drduh/YubiKey-Guide][drduh/YubiKey-Guide]], but I use about 20% of it (and it's a lot of scrolling lol)

#+begin_quote
It always takes me longer than I'd like. I'm not over-documenting this stuff bc
I see myself as "having epistemic authority" but bc it helps me learn. If I
rekey my GPG, then I want to parse through the work in my bash history, so next
time it will be faster.

Having weak skills here is painful. Thus, the inevitable reflection on wtf i
might do "next time" -- is probably 730 days from now? lol damit

"Airgapped" conveys a connatation of "network-less-ness"? I'm recently
questioning whether that's actually how people work lol. Totally lacking system
state except a LUKS-encrypted disk is a giant PITA.
#+end_quote

If I want guarantees on isolation of key material to the Yubikey, then I need an
"airgapped network." Then the biggest potential leak of secrets are consuming
applications.

+ Anything scripted is easy to lose, hard to track, feels pointless.
+ Iteration is slow. Comparing approaches is tough. Comparing data is just not
  fun when it's encrypted (doesn't matter whether it's in airgapped env.)
+ Files and directories are messy. I use =dd= to copy the LUKS container between
  multiple partitions. I don't do this frequently enough to recall the last one
  used.
+ Drift in design/approach in scripts off the system is difficult to reconcile
  when handling data on the system.

..........



** Overview

Some of these scripts can be tangled into a sourceable script. Setting
=ob@gnupg_useful_scripts_to_help_rekey_yubikey_and_rekey_secrets= changes the
top-level directory.

#+begin_src shell :tangle (expand-file-name "gpg-rekey.sh" ob@gnupg_useful_scripts_to_help_rekey_yubikey_and_rekey_secrets)
# shell :tangle (expand-file-name "gpg-rekey.sh" ob@gnupg_useful_scripts_to_help_rekey_yubikey_and_rekey_secrets)
# some helpful reminders and functionality
#+end_src

I may bundle this with [[https://github.com/dcunited001/ellipsis/tree/master/ellipsis/ellipsis/system/usb-gpg-tools.scm][usb-gpg-tools.scm]].

Any bash function prefixed with =_= is not something I plan to use in the future.
It mainly made editing shell scripts easier in console. I ran them. At least
once. Maybe.

*** Dammit Github

#+begin_quote
Github doesn't render org correctly (not even close). I can understand why it's
not supported. The degree to which support is lacking that is frustrating. If I
had intended to render these as a blog like with =ox-hugo=, I would've planned
more forward/backward migration methods.

Check the raw/code if something is looks like it lacks the sanity for
self-awareness. That is _also NOT syntax highlighted_, which IMO is way more
egregious. You could at least just do that!
#+end_quote

*** Learning GnuPG

Topics that would've helped me learn faster:

+ This [[file:../topics/img/smartcards-components.png][handy diagram]] that maps out CCID interfaces, along with FIDO and many
  other acronyms.

General GPG topics that I found hard familiarize myself with:

+ You can use Kleopatra to get a feel for =gpg= interfaces and esp. some of the
  =gpgsm= functionality, though I'm not sure which
+ =gpgsm= does X509. Didn't know that! I'm not sure what the limitations are. This
  is to some extent in the Kleopatra interface, but it's not fully there.
+ What is =assuan=? I thought this was how GPG pinentry prevents keylogging...
  It's related & not entirely orthogonal.
  - There is nothing cryptic about =assuan=. It is a simple, straightforward wire
    protocol. That's all. I had avoided the docs, trying to prioritize my time
    on the high-level usage.
+ Where are the boundaries b/w =opensc= and =pcsc=? Why =CCID=?

Specific GPG issues:

+ The need to restub your private keys when you switch keys (see =gpgRestub=
  alias). This wasn't too difficult to find. Encountering this can be a problem
  for beginners if they need to switch between the =piv= and =openpgp= apps.
+ What are the implications of =disable-ccid= in =scdaemon=? This is paradoxical,
  since it disables SCDaemon's interactions with CCID... which
+ What is =GPGTTY=?

None of that's really a complaint about GnuPG docs or anything. Each project has
it's culture of documentation: some expect you to be more source-oriented or
rely on authoritative docs first

** Setup disk

#+begin_src shell
herd status
#+end_src

Make sure =herd status= runs. If not, reset RTC (real-time clock), reboot, retest.

Crypto is _always_ time-sensitive. In this case (... don't trust me bro) it should
be okay to set the system and clock time. It's not network-connected, but I
haven't fully traced it through.

#+begin_src shell :tangle (expand-file-name "gpg-rekey.sh" ob@gnupg_useful_scripts_to_help_rekey_yubikey_and_rekey_secrets)
disk=/dev/sdc
part=/dev/sdc1
#+end_src

#+begin_src shell
sudo cryptsetup open /dev/sdc1 gpg1
sudo mount /dev/mapper/gpg1 /mnt/gpg1
sudo mkdir /mnt/gpg1
sudo mount /dev/mapper/gpg1 /mnt/gpg1
#+end_src

** Set environment

#+begin_src shell #+begin_src shell :tangle (expand-file-name "gpg-rekey.sh" ob@gnupg_useful_scripts_to_help_rekey_yubikey_and_rekey_secrets)
export IDENTITY="${IDENTITY:-David Conner <aionfork@gmail.com>}"
export GPGMASTER="${GPGMASTER:-9FCE9B3064CED760}"
export GNUPGHOME="${GNUPGHOME:-$PWD/.gnupg}"
export EXPIRATION="${EXPIRATION:-2y}" # or date
#+end_src

** Useful aliases

This one usually trips me up, esp. when clock is wrong ... Show all the keys.
=gpg ... --with-colons= should show everything

#+begin_src shell #+begin_src shell :tangle (expand-file-name "gpg-rekey.sh" ob@gnupg_useful_scripts_to_help_rekey_yubikey_and_rekey_secrets)
alias gpgKall='gpg -K --keyid-format=long'
alias gpgKshadowed='grep -ore shadowed' # private-keys-v1{,bak}.d
alias gpgKclear='grep -vore shadowed' # private-keys-v1{,bak}.d
alias gpgK='gpg -K --keyid-format=LONG --list-options show-unusable-subkeys'

alias gpgRestub='gpg-connect-agent "scd serialno" "learn --force" /bye'

alias gpgpax='gpg --list-packets' # $priv/somefile.priv.asc
#+end_src

Don't overuse "rngt" without starting =rngd=, especially if generating RSA keys

#+begin_src shell #+begin_src shell :tangle (expand-file-name "gpg-rekey.sh" ob@gnupg_useful_scripts_to_help_rekey_yubikey_and_rekey_secrets)
alias rngdrun=''
alias rngt='cat /dev/random | rngtest -c 1000 -b 100'
# diff --color=always <(gpgkpax $oldasc) <(gpgkpax $newasc) | less -R

# doesn't work
# gpg --with-fingerprint --with-colons \
    #    --keyring $priv/somefile.priv.asc --list-keys
#+end_src

Ensure permissions on a =$GNUPGHOME= directory

#+begin_src shell #+begin_src shell :tangle (expand-file-name "gpg-rekey.sh" ob@gnupg_useful_scripts_to_help_rekey_yubikey_and_rekey_secrets)
gpg_set_perm() {
    [[ -d "$GNUPGHOME" ]] || echo 'Set GNUPGHOME'
    [[ -d "$GNUPGHOME" ]] || return 1

    chown -R $(whoami) $GNUPGHOME
    find $GNUPGHOME -type d -exec chmod 700 \{\} +
    find $GNUPGHOME -type f -exec chmod 600 \{\} +
}
#+end_src

Print identity/fingerprint

#+begin_src shell #+begin_src shell :tangle (expand-file-name "gpg-rekey.sh" ob@gnupg_useful_scripts_to_help_rekey_yubikey_and_rekey_secrets)
# gpg --edit-key $GPGMASTER

# KEYID=$(gpg_id_master)
gpg_id_master() {
    [[ -z "$1" ]] && echo '$1 Required: IDENTITY' && return 1;
    gpg -k --with-colons "$1" \
        | awk -F: '/^pub:/ {print $5; exit}'
}

# KEYFP=$(gpg_fp_master)
gpg_fp_master() {
    [[ -z "$1" ]] && echo '$1 Required: IDENTITY' && return 1;
    gpg -k --with-colons "$1" \
        | awk -F: '/^fpr:/ {print $10; exit}'
}
#+end_src

** Create new subkeys

#+begin_src shell #+begin_src shell :tangle (expand-file-name "gpg-rekey.sh" ob@gnupg_useful_scripts_to_help_rekey_yubikey_and_rekey_secrets)
# =============================================
# gpg --expert --edit-key $GPGMASTER

_gpg_quick_dont() {
    # underscore means probably don't (syntax highlighting > comments)
    gpg --expert --quick-add-key $KEYFP ed25519 sign $EXPIRATION
    gpg --expert --quick-add-key $KEYFP ed25519 encrypt $EXPIRATION
    gpg --expert --quick-add-key $KEYFP rsa4096 auth $EXPIRATION
}
#+end_src

** Export Keys

#+begin_src shell #+begin_src shell :tangle (expand-file-name "gpg-rekey.sh" ob@gnupg_useful_scripts_to_help_rekey_yubikey_and_rekey_secrets)
# =============================================
# export secret keys

_gpg_export_secret() {
    [[ -z "$1" ]] && echo '$1 Required: Key ID' && return 1;
    [[ -z "$2" ]] && echo '$2 Required: Export To' && return 1;

    local keyid="$1"
    local dest="$2"

    [[ ! -d "$dest" ]] && echo "Dest doesn't exist: $dest" && return 1;

    # don't export the Certify key from the airgapped device's storage
    gpg --output $dest/$keyid-Certify.key --armor \
        --export-secret-keys $keyid
    gpg --output $dest/$keyid-Subkeys.key --armor \
        --export-secret-subkeys $keyid
}

_gpg_export_public() {
    [[ -z "$1" ]] && echo '$1 Required: Key ID' && return 1;
    [[ -z "$2" ]] && echo '$2 Required: Export To' && return 1;

    local keyid="$1"
    local dest="$2"

    gpg --output $dest/$keyid-Public.key --armor --export $keyid
}
#+end_src

** Quick tests on exported data

#+begin_src shell #+begin_src shell :tangle (expand-file-name "gpg-rekey.sh" ob@gnupg_useful_scripts_to_help_rekey_yubikey_and_rekey_secrets)
# ---------------------------------------------
# test

# check secret keys
# gpg --list-packets ...

# check public key
# gpg --show-keys $destroot/$dest/$KEYID-Public.key

# maybe backup files
# cp -avR .gnupg/private-keys-v1.d/ $destroot/$dest
#+end_src

** Identify private key files for export


#+begin_src shell #+begin_src shell :tangle (expand-file-name "gpg-rekey.sh" ob@gnupg_useful_scripts_to_help_rekey_yubikey_and_rekey_secrets)
# ---------------------------------------------

# DO _NOT_ EXPORT THE WRONG KEYFILES

# find private keys (in emacs)
# ls -alt $GNUPGHOME/private-keys-v1.d/
#+end_src

+ MAKE SURE EVERY KEYFILE CONTAINS THE TEXT: "shadowed"
+ This isn't the "correct way" to do this, but it's easier. You'll insert these
  files into =~/.gnupg/private-keys-v1.d= when you mount the disk containing
  =card.$serial= onto the workstation where you'll use the new keys.
+ When GPG eats the old private key files, it replaces them with =shadowed=
+ For different types of keys or usage, it's possible that publishing this
  everything is problematic. (e.g. the yubikey serial number)

#+begin_quote
Token: D276000124010000000612345670000 OPENPGP.3 - 12+345+678
Key: (shadowed-private-key (ecc (curve Ed25519)(flags eddsa)
 (q B16N4STYNUMB3RS)
 (shadowed t1-v1 (#D276000124010000000612345670000# OPENPGP.3))))
#+end_quote

** Yubikey Card Setup

run _before_ key transfer & pin setup. read the other caveats!!!

#+begin_src shell #+begin_src shell :tangle (expand-file-name "gpg-rekey.sh" ob@gnupg_useful_scripts_to_help_rekey_yubikey_and_rekey_secrets)
# =============================================

# CARD=$(ykman list -s)

_ykman_gpg_card_kdf() {
    echo '# drduh/YubiKey-Guide'
    echo 'gpg --card-edit # run before key transfer & pin setup'
    echo 'admin'
    echo 'kdf-setup # read the other caveats!!!'
    echo '12345678'
    echo 'quit'
}

# ykman -d $card openpgp reset
#+end_src

Setup pins/touch

#+begin_src shell #+begin_src shell :tangle (expand-file-name "gpg-rekey.sh" ob@gnupg_useful_scripts_to_help_rekey_yubikey_and_rekey_secrets)
# does not handle errors
_ykman_openpgp_setup_pins() {
    [[ -z "$1" ]] && echo '$1 Required: card serial' && return 1;
    local card="$1"
    ykman -d $card openpgp access set-retries 9 9 9
    ykman -d $card openpgp access change-pin
    ykman -d $card openpgp access change-admin-pin
    ykman -d $card openpgp access change-reset-code
}

_ykman_openpgp_setup_touch() {
    [[ -z "$1" ]] && echo '$1 Required: card serial' && return 1;
    local card="$1"
    local ykdec=on; local ykaut=on; local yksig=on; local ykatt=on

    # you don't want this touch policy
    ykman -d $card openpgp keys set-touch dec $ykdec
    ykman -d $card openpgp keys set-touch aut $ykaut
    ykman -d $card openpgp keys set-touch sig $yksig
    ykman -d $card openpgp keys set-touch att $ykatt
    # ykman -d $card openpgp access set-signature-policy -h
}
#+end_src

Prep a directory to export from the card (eventually to a separate disk)

#+begin_src shell :tangle (expand-file-name "gpg-rekey.sh" ob@gnupg_useful_scripts_to_help_rekey_yubikey_and_rekey_secrets)
_ykman_openpgp_backup() {
    [[ -z "$1" ]] && echo '$1 Required: card serial' && return 1;
    local card="$1"
    echo mkdir gnupg.export/card.$card
    # don't copy the other keys until they're "shadowed on the card"
    echo cp -av gnupg.export/$(date +%F)/$KEYID-Public.key" \
        "gnupg.export/card.$card"
}
#+end_src

Setup identity on the card

#+begin_src shell #+begin_src shell :tangle (expand-file-name "gpg-rekey.sh" ob@gnupg_useful_scripts_to_help_rekey_yubikey_and_rekey_secrets)
_ykman_gpg_card_setup() {
    echo 'gpg --card-edit # drduh/YubiKey-Guide'
    echo 'admin'
    echo 'login'
    echo 'name'
    echo ' ... etc'
    echo '$IDENTITY'
    echo '$ADMIN_PIN'
    echo 'quit'
}
#+end_src

Move keys to card

#+begin_src shell #+begin_src shell :tangle (expand-file-name "gpg-rekey.sh" ob@gnupg_useful_scripts_to_help_rekey_yubikey_and_rekey_secrets)
_ykman_gpg_card_transfer() {
    echo 'gpg --edit-key $KEYID # drduh/YubiKey-Guide'
    echo 'key $n'
    echo 'keytocard'
    echo '$type'
    echo '$CERTIFY_PASS'
    echo '$ADMIN_PIN'
    echo 'save'
}
#+end_src

Export the secret keys

#+begin_src shell 
_gpg_shadowed_keys_backup() {
    [[ -z "$1" ]] && echo '$1 Required: card serial' && return 1;
    local card="$1"
    echo mkdir gnupg.export/card.$card
    # don't copy the other keys until they're "shadowed on the card"
    # 
    echo cp -av "gnupg.export/$(date +%F)/$KEYID-Public.pub" \
        "gnupg.export/card.$card"
}
#+end_src

* Importing new keys

#+begin_src shell #+begin_src shell :tangle (expand-file-name "gpg-rekey.sh" ob@gnupg_useful_scripts_to_help_rekey_yubikey_and_rekey_secrets)
# =============================================
# once card is set up and touch policy is correct, transfer keys.

# - before doing so, make copies.
# - create an export with the new shadowed-private-keys ONLY!
# - include the new public key

# setup newly rekeyed card, test
#
# - then get ready to locate/rekey secrets with spare key
#   - ..asdfghjk. use two machines, locate/etc where possible
#   - don't end up in the same situation

# then repeat the gpg keytocard process with the other card
#+end_src


** Setup GPG's SSH Agent to use new keys



#+begin_src shell #+begin_src shell :tangle (expand-file-name "gpg-rekey.sh" ob@gnupg_useful_scripts_to_help_rekey_yubikey_and_rekey_secrets)
gpg_rekey_ssh () {
    # [[ -z "$1" ]] && echo '$1 Required: keygrip' && return 1;
    # local keygrip="$1"
    local alg="$(gpg -K --with-keygrip --with-colons | grep ':a:' | awk -F: '/^ssb:u:/ {print $17}')"
    local keygrip="$(gpg -K --with-keygrip --with-colons | grep ':a:' | awk -F: '/^ssb:u:/ {print $5}')"

    gpg --export-ssh-key $keygrip >> ~/.ssh/authorized_keys
    gpg --export-ssh-key $keygrip >> "~/.ssh/id_$alg.$keygrip.pub"
}
#+end_src

Check SSH configuration

#+begin_src shell #+begin_src shell :tangle (expand-file-name "gpg-rekey.sh" ob@gnupg_useful_scripts_to_help_rekey_yubikey_and_rekey_secrets)
alias sshServerConfAll="sshd -T" # with sudo
alias sshServerConf="sshd -G"
alias sshHostConf="ssh -G" # $host
alias sshCaps='for q in cipher cipher-auth mac kex key key-ca-sign key-cert key-plain protocol-version sig; do echo; echo "### $q"; echo; ssh -Q $q | sort; done'
#+end_src

** Rekey a list of encrypted files

#+begin_src shell #+begin_src shell :tangle (expand-file-name "gpg-rekey.sh" ob@gnupg_useful_scripts_to_help_rekey_yubikey_and_rekey_secrets)
# requires gpgRestub to switch between keys: 'scd serialno' 'learn'
_gpg_rekey_list() {
    # using locate or something
    for g in $@; do
        p=${g%.gpg};
        cp $p.gpg $p.bak.gpg;
        gpg -d $p.bak.gpg | gpg -aer aionfork@gmail.com > $p.gpg
    done;
}

# I ran it on the wrong directory ...... there were two
#
# ... back up the directory first. and `shred -u anydecrypted`
#+end_src

** Print env & state

And print some env state.

+ the top will create =~/.gnupg=, so i commented it out... kinda dumb anyways.

#+begin_src shell #+begin_src shell :tangle (expand-file-name "gpg-rekey.sh" ob@gnupg_useful_scripts_to_help_rekey_yubikey_and_rekey_secrets)
# echo
# echo "============================================="
# echo
# gpgconf --list-dirs
# echo
# echo "============================================="
# echo
# gpg -k
# echo
echo "============================================="
echo
alias
echo
echo 'gpg_id_get() {}'
echo 'gpg_fp_get() {}'
echo
echo "============================================="
echo
echo "IDENTITY: $IDENTITY"
echo "GPGMASTER: $GPGMASTER"
echo "GNUPGHOME: $GNUPGHOME"
echo "EXPIRATION: $EXPIRATION"
echo
echo "setup rngd..."
#+end_src

* Polemic

These notes will not be maintained though** ... not that my content is ever
indexed on Google. I'm probably on the GPT short-list of non-extant identities.

=<emo>=

These are some of the "answers" I now find easily, but that I struggled a lot
with. Everything I do is pointless. Just ask AI. It's not great at this crypto
stuff -- the data footprint was dampened by the need to rely on opsec. Gemini is
surprisingly good at some topics, surely better than whatever's herein.

=</emo>=
