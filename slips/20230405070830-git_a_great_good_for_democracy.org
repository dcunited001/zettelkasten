:PROPERTIES:
:ID:       2241f856-c2b3-43fa-ae4e-a2ebc2760ae3
:END:
#+title: Git: A great good for democracy

* ChatGPT Plagerism

Totally random, but while Git is a bit tough to use, it's actually a good way to
circumvent students using ChatGPT to write essays or produce work. Git or some
kind of /directory-based/ version control to track progress in assignments.
File-based version control is brittle, leaving too wide a gap for plausible
deniability.

While Git and Github as they are would not be appropriate for high-school or
college students, it's pretty easy to imagine how you may wrap the Git interface
in a context-specific GUI where the student doesn't even know they're using git.

Still, this doesn't work for

* Git and Democracy

Many people have joked about using version control for legislation or
policy. It's not a joke.

Also, Git could (and probably should) be used to track changes in laws/bills in
legislatures. Git and Version Control should also augment/replace the Federal
Register -- which absolutely no citizen uses. Most people don't even know the
Federal Register exists -- though they'll talk endlessly about all the
regulations that are/not needed and are/not slowly corroding the foundations of
American economy/environment/society/etc. The Federal Register includes features
that allow people to give feedback to departments/administrations/agencies --
but no citizen who wasn't briefly motivated by lobbyists or some Super PAC knows
what it is.

* The Technical Hurdles Are Cultural

And here lies the slide rule, the use of which produced planes to fight the
Nazis, designed skyscrapers and landed us on the moon. I honestly can't say that
I've ever seen one.

Should we return to using the slide rule? Probably not, but the abacus is
thought to engage kinesthetic and tactile modalities in the brain, augmenting
signals used to for mental arithematic and thereby making arithmetic skills more
robust. Preventing entire feature-classes of signals from experiences yielding
the memories accompany one's development of arithmetic (itself being encoded
into procedural long-term memory) /should/ result in less retention and more
energy expenditure.

** Software as Craftsmanship, Figuratively

The best metaphor for explaining the craftsmanship of software development &
usage is a woodworking shop. When you try to explain how your software is
designed or why you approach the work of software & systems design with the
processes you choose, basically anyone who doesn't want to deal with more than
30 seconds of technical jargon gets a free pass: they don't understand; they're
not paid to understand; they have other tools that do the same thing. These are
all fair responses. And your tools you get out for a project should not be more
complicated than what is required to get things done.

How you approach organizing your workshop changes as you accumulate experience,
but also tools. You may start with the experience, the tools, both or neither.
If you have a mentor, you'll accumulate experience faster. If you save and spend
money wisely, you'll have the tools. You can buy the tools and materials, but
you could only indirectly buy the experience.

How do you organize the large tools in your workspace? Without a mentor, how do
you learn to do this? Where do you go when you have questions? Where do you go
when you don't have the questions you should ask? Do you hear the questions that
others have? How Zen was your Zen when you forgot to remember the first time you
did a thing or made a type of mistake?

Google or various woodworking books can help with organizing a workshop, but
before you know that machines should /or maybe could be/ on castor wheels, you
should probably learn about how to orient the dust ports. Do you know the
largest size of wood you're going to cut or what angle you'll hold it at? If you
bolt equipment down and avoid castor wheels to prevent resonant vibrations from
chipping the workpiece, what do you do when you have to move the router? Does
any of this actually matter or does someone with experience avoid the problem
altogether? Can you afford a second router for circular or template cuts?  Did
you know they exist?

When you built your first website, were you aware of typological patterns you
would gradually internalize that would inform how you'd organize
files/directories? Or did someone spoon feed this knowledge to you? If you've
changed web development frameworks or used a micro-framework, did you simply
reapply the same directory structure?

When your project no longer requires BabelJS or Webrick or Swagger -- jesus
christ any number of the thousands of ever-dying, god-forsaken javascript
"tools" -- did you restructure your assumptions about what was necessary or did
you maintain the same patterns of thought shaped by some technology? And if
there are patterns from technology earlier than your career, did you change
those? Some examples could be trivial or not:

- The "master" branch being a relic of earlier VC systems.
- Transitions between stateful/stateless protocols -- RPC/SOAP vs. REST
- Or the endless cycle of server-side rendering to packed JS & templates, with
  or without native SEO optimization (i'm looking at you AngularJS). This cycle
  itself mirrors that of thin-client/thick-client.

When you took risks in learning "bleeding edge" technologies, dId they pay out?
Were you correct? Did you benefit from that risk and grueling effort with almost
zero mentors? Or did everyone else benefit from almost every one of these
languages/frameworks/patterns?

How about your bad ideas or misplaced creative energy? What about the bad ideas
that are defacto standard in how people work with technology today?

How much of culture shapes the tools people choose in woodworking, software
usage or software design? Are there superior means of learning, automating,
becoming connected to the world that will just never gain critical mass?
Absolutely: Who killed RSS? And why? The GDPR would basically be pointless if
people chose mostly cookieless RSS feeders instead of the browser or newsfeed.

In software design/usage, why do bad ideas outlive good ideas? Good ideas are
sometimes more complicated or more prescriptive in nature. They involve
forsight. Bad ideas leave you with problems, dependence or ignorance. To borrow
a software metaphor, people who are generally ignorant of how the car engine
works who just want to drive it could just as easily put kerosene in their
engine or corn syrup. It doesn't matter if you're tailing 2 feet behind the
person in front of you and cutting people off /as long as it _feels_ like you're
getting somewhere faster/.

Some fairly good tests of whether you did the legwork to establish good processes
for software/systems projects in the past:

- Can you push a button and run the tests?
- Can you push a button a redploy it?
- Can you rebuild it with the exact dependencies?
- Can someone else see it running in 30 seconds or less with minimal overhead or
  boilerplate?
- Can you pick up a project you left two months or two years ago and have it run
  or redeploy exactly as intended?

That last one will bite you in the ass if you haven't done systems or
programming for 5+ years -- but it depends on a few assumptions:

- Do you care about the projects you worked on in the past? Were they just
  something to pass the time, or just work for a client? Were they the distilled
  spirits of your hopes/dreams at the time, catalyzed by your passion?
- Did you give up the pursuit of a real career for something you believed in?
  ZOMG how do you explain your resume gaps?
- Do you know whether you would care to restore something you did in the past?
- Do you believe in your own work as being significant at least to you or
  original/creative?
- And critically: are you a polymath? Would you like to be? How many programming
  languages do you care to work with?

Did you explicitly set for yourself the goal of being a polymath? Did you
succeed? Da Vinci was a bastard, but obviously had a lot of help along the way:
he practically started his first job crowning the Florence Cathedral.

If you'd like to be a polymath, you may find yourself dabbling in esoteric or
relatively unexplored topics. When you deal with large volumes of knowledge from
disparate fields (or like to pretend to do so, of course), then you may want to
systematize your approach to doing so to avoid problems.

You know what's helpful though? When relatively more people are following in
similar paths or at least have similar motivations to determine the paths they
choose to follow. This means that more people strengthen their minds and can
provide you the tools you need along the way. Would I rather learn Tensorflow or
Linear Algebra. Obviously, the latter: it's universal knowledge. One will age
rapidly and the other will always be relevant, regardless of the
framework.

**** TODO connect inspiration/values to network effects (social amplification)

+ the amplification requires that knowledgable people be sufficiently common. it
  requires that they have social access to each other.

**** TODO manage to segue to art




For web-applications

, but they cannot
speak to what you need to hear, individually at that point in your development.



** Technological Innovations Have Resulted In Exponential Increases In Art.

Now think of how changes in the Artist's pallete in the last two centuries has
changed art itself. The old masters were not concerned with toxicity,
lightfastness or mixed-media interactions, though oil was a revolution over egg
tempura. Finding a decent mixable blue or purple or keeping stock of
oils/pigments were far greater concerns. While new color possibilities and media
expanded what was possible, they also convoluted processes related to ideating,
planning and producing artwork. Beyond the benefits, the advent of new
technologies increases the likelihood of mistakes, increases the technical
burden on new artists to master their craft, and distracts artists from focusing
on the art of art itself. Offhand, the only innovation as revolutionary as oil
painting is the aluminum paint tube.

Very few of these innovations significantly reduced the complexity involved in
planning woodworking or artmaking. Instead, the complexity, time investment and
costs have increased as a result of complexity. Furthermore, there are many
technologies or techniques which remain unused or uninvented, though few
innovations in art for example would reduce complexity.

Many artists and critics may point out that this complexity increase the breadth
of techniques/materials/processes that is critical to artistic originality,
expression, etc. This is true, but I want to emphasize increase in minimal
viable core skills required to sustain your passion/costs through the first
2,000 hours in the craft.





** Microsoft locked everyone into being incapable of using a computer

Don't give me that look if you are older than 50 because I know that you
remember using WordPerfect or LotusNotes 1,2,3 and other programs in DOS. Almost
any white collar worker from that time remembers these programs and I'm sure
readily adopted their GUI replacements.

And yes, it was difficult. But it must be nice to pretend that nothing ever
existed before Windows 3.1. People used that terminal/ncurses-based UX/UI en
masse throughout the 1980's and it transformed the economy.  Personally, I would
much rather use an AS/400 in a customer service position than a web application
... or an AS/400-style emulated environment. Why? Because it's 10x faster for
repetitive tasks, many of which will soon no longer exist.

The reason these interfaces are faster is because there is basically no other
way to navigate the interfeaces than to use shortcut-keys. You must learn a
handful of keys along with a very important piece of ancient Chinese wisdom
handed down from the very first graybeard -- keyboard shortcuts exist. It's so
easy for people to be so unaware of hidden functionality that they never
systematically approach searching for extra functionality: sometimes, in some
arbitrary application new to them; occasionally in any application. There are
many, many people who have somehow gotten through life without learning how to
copy and paste, let alone learning how to write an email filter.

** But AI Will Just Manage Our 3D VR Desktops For Us!

I know, I know: Siri, ChatGPT or Robin Williams as the Blue Genie from Alladin
will do it for you ... Do what, exactly? What do you want to be done, precisely?
How do you ask the computer to do things that you cannot name?

> It's easy: the AI does it for you!

It does what for you, exactly? At some point, you have to present the user with
information about what is going to be done.

- When you get an appraisal to get your house painted, at what point do you
  become comfortable with the services, prices and details being offered?
- When you request quotes for a complex product and receive a Bill of Materials,
  do you care what's in it?
- When you want calendar reminders for an important event, do you want to be
  able to expect about which times you will be reminded?

To risk meandering aimlessly though some unrecognizeable philosophy or another
-- the underlying issue here is one of consensus. The bot, the operating system,
the entity, the subcontractor, the customer has some information and you don't.
It's not in your brain-hole. If you want it in your brain, the information must
be transferred. This can be accomplished through:

- email
- "conversation"
- an annoying pop-up warning
- a status bar
- command-line output (stdout/stderr)
- a print-preview
- a bill of materials
- the branch name a Github project declares as the shared upstream branch.
- a three-minute verbal explanation delivered by a synthesized robot voice
  that's not stuck in some uncanny valley.
- a traffic light, where hopefully other drivers see red when you see green red.

Here, each signal being sent conveys information, but furthermore there are
underlying assumptions of consensus in what /the signal/ means or what signals
in this context can mean, etc. Other parties need to be metaphorically "looking"
or "listening" -- i.e. capable of receiving, interpreting, and processing some
signal.

** A Philosophical Detour Averted

Wow, that was close. I moved the content to the end of the draft.

** Business Concerns Rank First In Microsoft's Design Priorities

Windows designed the entire user-interface around distributing licensed software
as exe/msi on multi-user systems with domain-based authentication and roaming
profiles. Microsoft locked people into using the files produced by Microsoft
Office instead of open, text-based files. The configuration interface for
Windows 10/11 is designed around the hypothetical 90 y/o who never personally
used a computer but retired on Microsoft stock. Windows 10 violates all kinds of
design rules: particularly avoiding wasted space, but also

so no one knows how to use a computer. if we're lucky, AI will do it for
us. however, it looks like any significant change in technology that requires
about 5-10% of the population actually be able to use a computer instead of
paying some vendor to manage the complexity for them. the government literally
paid Microsoft to lock everyone into being unskilled at using computers.

> "I think humans are basically tool builders, and the computer is the most
remarkable tool we've ever built." -- Steve Jobs

But... we can't automate anything without paying for one-size fits all software
solutions?

One of the biggest advantages to free software is you have to pay experts to
assist you or manage it for you. This is true of proprietary software as well
(there is no free lunch), but economically it makes more sense for the money
spent on managing software to gravitate towards the labor markets instead of
Wall St. by propping up Microsoft revenues.

But, we are where we are:

** The Philosophical Scenic Route

And here we must combine epistemilogical reasoning with consensus. The former is
concerned with how you know what you know and the latter with the coordination
of agreement on status or information. The math that underlies epistemic games
is about as complicated as any sentence sounds when it contains the words "that
you thought that I thought that..."

Here the normie experiences friction or lag when processing statements with
recursive logic or statements involving statements involving multiple references
to the same words ... This isn't a pejorative statement: computationally hard is
computationally hard. In compiler optimization or JIT debugging, loops and
cycles must be identified and treated differently. This is similar in nature:
the more quickly you identify the potential for epistemic structure or semantic
structure and match it to a previously encountered pattern of recursion, the
more quickly you can apply inductive logic and avoid blowing your stack.

Much of the same math used for machine learning -- vector algebra, linear
independence, entangled/disentangled representations -- can explain why this
logic is computationally hard. We like communication to be succinct because
systems with fewer constraints require less effort to analyze. We normally avoid
recursive/epistemic grammar or self-referential semantics because determining
whether the system of constraints is "closed or well-defined" usually requires
importing more context. It's a norm: people avoid predicates depending on "what
you thought that I thought" because it's known to evoke discomfort, to result in
dismissive responses and to resist interpretation. And it is computationally
hard because the constraints on interpretation require special handling to
determine linear independence -- if you're lucky, you identify one of several
most-efficient spanning trees though you'll need matroids and you may run afoul
of Zorn's Lemma.

#+begin_quote
And that Zorn's Lemma would be related to Spanning Trees was a guess -- BUT [[https://en.wikipedia.org/wiki/Zorn%27s_lemma][IT
IS CORRECT]] GODDAMMIT I HAVE INUTITION ABOUT THIS SHIT AND ZERO HELP. And
there's almost no one who can referee my theses. If you magically guess
correctly enough times, it is not luck. I encountered Zorn's Lemma from an
Exterior Calculus textbook I bought for $150, for which I admittedly need
someone to help me process the notation.

You think it's hard to understand what I write? Imagine trying to learn this
shit in social isolation. That itself should speak volumes about my fucking
mind, though the internet and youtube help quite a lot.

If the things I know that I know sound prohibitively complex, foreboding or
"dangerous" ... just look for all the things I don't know. Or appear not to
know. I'm ignorant of quite a lot.
#+end_quote
