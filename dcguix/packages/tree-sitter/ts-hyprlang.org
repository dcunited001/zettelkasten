:PROPERTIES:
:ID:       81a26cc3-22f3-4332-96c2-c71407d5149d
:END:
#+title: DC Guix: ts-hyprlang

* Roam
+ [[id:b82627bf-a0de-45c5-8ff4-229936549942][Guix]]
+ [[id:aef34489-3943-4c2f-bf88-828f5ea39e16][Tree-sitter]]
+ [[id:b4e1fa85-53ca-467e-aac2-9a4e37b80144][TCL]]
  
* Resources
** hyprlang

Emacs TS mode: [[https://github.com/Nathan-Melaku/hyprlang-ts-mode][Nathan-Melaku/hyprlang-ts-mode]]

TS Grammar: [[https://github.com/tree-sitter-grammars/tree-sitter-hyprlang][tree-sitter-grammars/tree-sitter-hyprlang]]

** TCL

[[https://github.com/tree-sitter-grammars/tree-sitter-tcl][tree-sitter-grammars/tree-sitter-tcl]] the community package. didn't have time
to fix it.

[[https://hg.sr.ht/~cdrozak/tree-sitter-tcl][~cdrozak/tree-sitter-tcl]] an older version, completely separate from the above
project. this one's easier to build.

*** TCL in OCC

#+begin_quote
oops i stumbled on an old idea.
#+end_quote

#+begin_quote
This was a good idea that I would have liked to explore turning into:

- first a basic emacs-driven OpenSCAD (but with more dimensions)
- then a means of sharing simple parts using a package manager ... but with
  parameterizable packages or builds.

e.g. 2080/etc aluminum with: pkg params like length; build params like a
  composite package running a subtracted inner extrusion; composite packages
  that bundle STEP-files by [[https://en.wikipedia.org/wiki/Uniform_Resource_Identifier][URI]] or simple screws/parts.

it would totally fail at anything complex though, but probably worth at least
trying to umm learn things about CAD and whatnot.
#+end_quote

I wanted to hack a bit on OpenCascade's hundreds of TCL test cases.

+ I ported the =syntax-table= from emacs' =tcl-mode= over to =tcl-ts-mode=, which
  worked as a PoC.
+ I had tried it on [[https://github.com/dcunited001/.emacs.guix/blob/master/lib/tcl-ts/test/Penrose.tcl][Penrose.tcl]], which generates a [[https://en.wikipedia.org/wiki/Penrose_triangle][penrose triangle]] -- /the
  output can easily be exported to various formats/.

Without an =ob-tcl= that connects OCC's TCL =wish= repl, the workflow is too
stateful and org-babel isn't the best way to organize code.

- That REPL is fairly standard, so a =comint-mode= derivative already exists. It's
  old. IIRC I had started to test this out and it seemed alright.

It _could_ work for hacking on CAD... _but model parameterization is always at
least as hard as dimensional analysis_. This is /apropos to/ FreeCAD's [[https://wiki.freecad.org/Topological_naming_problem/en][Topological
Naming Problem]], though that's more about the topology than the naming: it
requires flexible data structures to index topological features in a consistent
& extensible manner.

+ Solving the topological naming problem for the program requires the UI relate
  events to vertices/faces/edges/BREPs, then enumerate what's possible and
  culling out what's not.
  - The CAD program must be constructed from the ground up to allow features
    like those from Inventor where you reorder operations. The similarity
    between that UI and the ideas behind Haskell & functional programming are
    profound.
  - A typology of constraints is effectively enumerated by the constraints
    available in CAD: 2D sketch, 3D coordinate relations, datum bases, =GD&T=.
    Only some are valid. FreeCAD's topological naming problem emerged bc
    higher-order morphisms (composition of multiple "inventor drag'n'drops")
    need to rework data structures so indexing is consistent for subsequent
    morphisms that should also be possible.
    - i.e. the CAD program must retain clarity in it's organization of
      topological object/index data to avoid problems _while also_ being capable
      of reorganizing the topological structures.
    - Ever notice how some Inventor operations take more time than others? And
      how some break your project if your intuition doesn't clue you into
      rewinding early with undo?
  - BREPs must be closed manifolds because, among other reasons, it simplifies
    and organizes the combinatorics of enumeration. That's a starting point.
+ If you've ever wondered about algebraic geometry/topology ... it's um hard.
  Why is a 24-cell a unique 4D platonic polytope? IDK.
  - This [[https://arxiv.org/pdf/math/9905023][1999 paper]] came up which is loosely related and "hey!" cool pictures
    ... it really is close though. Only glanced at it though.

So the real problem here: CAD is just hard. Scripts that name features with
dimensional references need to consistently track the "configuration space" of
parameters with less constraints.

TCL is pretty dumb (in a good way), so the code ages well (I think?). It has
some kind of advantages in binding to C/C++ FFI that make it automagic ... no
idea what the TCL/FFI "it-factor" actually is though.

+ It's notably useful for driving automated testing in complicated scenarios,
  particularly those involving electronics. Again, no idea what "it" is that
  made TCL suited to that use.

* Overview


** Main Issues

I had tried getting Guix's private =tree-sitter-grammar= methods from
=./gnu/packages/tree-sitter.scm= to work before, but I wasn't confident enough
about scheme to be sure.

This time around, I was able to get the =(@@ (gnu packages tree-sitter)
tree-sitter-grammar)= imported. It's connections to other modules and definitions
were simpler than I had realized. It's still a bit wonky to use regardless


* Package

#+begin_src scheme :tangle ts-hyprlang.scm
(use-module (ellipsis packages tree-sitter)
            ((guix licenses) #:prefix license:)
            (gnu packages)
            (gnu packages base)
            (gnu packages crates-graphics)
            (gnu packages crates-io)
            (gnu packages node)
            (gnu packages tree-sitter)
            (guix build-system cargo)
            (guix build-system gnu)
            (guix build-system tree-sitter)
            (guix gexp)
            (guix git-download)
            (guix hg-download)
            (guix packages)
            (guix utils)
            (srfi srfi-1))
#+end_src

... =hidden-package= does not do what I assumed it would. it seemed to prevent the
inheriting package from building ... but =-e (@@ ...)= syntax still worked.

+ still not sure whether =(hidden-package ...)= suppresses the package-name even
  if redefined?

#+begin_example shell
# these are /not/ supposed to work at the same time IIRC
guix build -L $HOME/.dotfiles/ellipsis \
  -e '(@@ (ellipsis packages tree-sitter) ts-hyprlang)'
guix build -L $HOME/.dotfiles/ellipsis \
  -e '(@  (ellipsis packages tree-sitter) ts-hyprlang)'
#+end_example

That syntax is great for hacking a package outside of proper scheme module
directories, but falls short when referring to packages by =package-name= like in
=specfications->manifest=, making them tough to compose into profiles.

I think these issues were from duplicate package definitions? Or something about
how scheme identifies an entry point with =-s=. I think the entire module needs to
be evaluated if you refer to the package by =(name "eg-hello")=, whereas the =-e=
evaluation somehow reduces the scope of evaluated code ... ???

#+begin_src scheme :tangle ts-hyprlang.scm
(define tree-sitter-hyprlang
  ;; (hidden-package
  ((@@ (gnu packages tree-sitter) tree-sitter-grammar)
   "hyprlang" "Hyprlang"
   "171p3hj36a1jqflg9xv138445j4m4m16na6bgpm1km3l67jhvl54"
   "3.1.0"
   #:repository-url
   "https://github.com/tree-sitter-grammars/tree-sitter-hyprlang")
  ;;)
  )
#+end_src

| keyword               | defaults                               |
|-----------------------+----------------------------------------|
| #:commit              | v$Tag                                  |
| #:repository-url      | (...formatted-github-ref...)           |
| #:grammar-directories | '(".")                                 |
| #:article             | "a" or "an"                            |
| #:inputs              | (list tree-sitter-ihopenot2many-langs) |
| #:get-cleanup-snippet | tree-sitter-delete-generated-files     |
| #:license             | license:expat                          |

Using =tree-sitter-grammar= is easier from within a direct checkout, like in [[https://guix.gnu.org/manual/en/html_node/The-Perfect-Setup.html][ยง22.3
The Perfect Setup]], but there's often "some assembly required."

Here, I couldn't simply disable the tests, so I'm unsure of whether a patch
would be accepted. Didn't have time, but maybe later. I still need to get
gnus/email set up, which I'm thinking about just running on a server console
session. It may be possible to submit something on codeberg, but idk for now.

#+begin_src scheme :tangle ts-hyprlang.scm
(define-public ts-hyprlang
  (let ((base tree-sitter-hyprlang))
    (package
      (inherit base)
      (name "ts-hyprlang")
      (arguments
       (substitute-keyword-arguments (package-arguments base)
         ;; (delete 'check) from phases doesn't work
         ((#:tests? _ #f) #f))))))
#+end_src

** tree-sitter-tcl

The first tree-sitter lib I built was for =tree-sitter-tcl=. The newer package
fails on tests.

#+begin_example scheme
;; requires npm peerDependencies "tree-sitter": "^0.22.4"

(define-public tree-sitter-tcl
  (let ((commit "8f11ac7206a54ed11210491cee1e0657e2962c47")
        (revision "0"))
  ((@@ (gnu packages tree-sitter) tree-sitter-grammar)
   "tcl" "TCL"
   "0dkxh6bn0kqn1gbyd5qwkg21fm634mxvas3w4ahv6zr5d8f95c96"
   (git-version "1.1.0" revision commit)
   #:commit commit
   #:repository-url
   "https://github.com/tree-sitter-grammars/tree-sitter-tcl")))
#+end_example
