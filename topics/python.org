:PROPERTIES:
:ID:       b4c096ee-6e40-4f34-85a1-7fc901e819f5
:END:
#+TITLE: Python
#+DESCRIPTION: python stuff
#+TAGS:

* Roam
+ [[id:ca4b43cc-90fb-4434-9bca-5d43e28b00ae][blender: build on garuda archlinux]]
+ [[id:8b93d9a6-746f-4480-8ef5-45310e03b783][Fedora: setup AMD gpu for blender/tensorflow]]

* Docs

* Resources
+ [[https://www.adventuresinwhy.com/post/eglot/][eglot+tree-sitter in emacs 29]]
+

* Topics

** Metaprogramming
+ [[https://pypi.org/project/sip/][Python Sip]]

** Modules
+ Load code in a python project: [[https://www.devdungeon.com/content/python-import-syspath-and-pythonpath-tutorial][Python import, sys.path, and PYTHONPATH Tutorial]]

** Data Science

+ [[https://github.com/cupy/cupy/wiki/Projects-using-CuPy][Projects Using CuPy]]

** Environment Management Tools

Everytime I revisit this, it improves significantly ... but it's still a mess
for someone who hasn't coded a lot of python.

[[file:img/python_environment.png]]

It's a well-known issue: see [[https://drewdevault.com/2021/11/16/Python-stop-screwing-distros-over.html][Python: Please stop screwing over Linux distros]],
but honestly it's improved a lot. It mostly results from a combination of
python's popularity, a notebook's need for version-specific requirements and
python's ubiquity, being essential to modern linux/mac systems. This last point
means containerization and locked dependencies are essential.

I've solved this two times in the past two years, only to lack sufficient time
to work with notebooks. Google Colab works well, but lacks the speed/flexibility
& precision I need when the notebook requires external services.  And I've
probably worked though this ten times in the past ten years as the norms shifted
through:

+ vm/linux/mac
+ virtualenv
+ docker: storage requirements are annoying and maintaining image persistence
  through system reinstalls is a bit of a problem (i was really too
  unemployed/isolated to even use Docker, though I initially used it in 2013)
+ pipenv/etc
+ back to virtualenv, since it's core
+ oh poetry: looks a little too high-level essential
+ guix profile + pipenv: works until you need multiple python versions?
+ hmmm oh, poetry! but it doesn't work well for notebook dependencies

You may find some simple solution where you never really have the need for
precision/reproducibility in python environments ... if you're not using tools
like the following,

+ Blender-as-a-Module
+ Tensorflow with CUDA
+ The fucking =LD_LIBRARY_PATH= and =patchelf= thing
+ Builds of Atlas/Lapack, perhaps using AMD's AOCC compiler/optimizer

I think the answer for me in 2023 is just =virtualenv + direnv=, perhaps
including the possibility for poetry where it's found in a package.

Oh and I really don't like jupyter notebooks. The benefits and caveats are
similar to those for "literate programming" -- they're great when you want to
communicate your work or in other limited use cases. But I need autocompletion
and I like REPL's -- oh and brittle/new OS installs basically break anything and
duct tape connecting your editor to your python environments. With guix/nix, you
/maybe/ take slower steps forward, but you basically never take steps backwards.

I guess I basically need a scheme for naming/organizing notebook environments.

*** Direnv + Venv

**** Pros
+ Simple and very core.
+ Direnv is a self-contained Go library, with emphasis on "self-contained."

**** Cons
+ Doesn't necessarily handle Python environments.

*** Poetry ([[https://python-poetry.org/docs/][docs]])

Nice when working on packages. IMO, doesn't really work with notebook
environments.

**** Pros
+ suffient containerization

**** Cons
+ A little cumbersome, especially when managing Guix & Arch envs
+ a new abstraction set has appeared.

*** Guix

If I were working with python often and using Guix, I would create something
like a single channel that only has Guix/Nonguix as channel dependencies.

**** Pros
+ Totally reproducible environments

**** Cons
+ Guix python packages are old. This is in the "cons" for me, but is not too bad
  in itself.

*** Nix

**** Pros
+ Combines well with poetry using [[https://github.com/nix-community/poetry2nix][nix-community/poetry2nix]]

**** Cons
+ Requires Nix, which IMO has advantages/disadvantages wrt Guix.
+ I don't have Nix on my systems. Perhaps in the future.

*** Pipenv ([[https://pipenv.pypa.io/en/latest/index.html][docs]])

**** Pros
+ Works alright.
+ It's a fairly thin set of tools, reuses existing abstractions, mostly.

**** Cons
+ A little cumbersome, especially when managing Guix & Arch env

* Issues

** Installing Python on [[id:b82627bf-a0de-45c5-8ff4-229936549942][Guix]]
*** Via guix packages and guix import ([[https://felsoci.sk/blog/installing-python-modules-on-guix.html][2022]])

=guix import pypi dash-bootstrap-components -r= creates a guix package
description for =dash-bootstrap-components=

*** Guix supports python3, pip3 and virtualenv ([[https://github.com/pjotrp/guix-notes/blob/master/PYTHON.org][2021]])

see [[https://github.com/pjotrp/guix-notes/blob/master/PYTHON.org#isolated-module-installation][pjotr's notes]]



** Packages

*** Builds

+ [[https://pip.pypa.io/en/stable/reference/build-system/pyproject-toml/][pyproject.toml]]

*** Pip Commands
**** TODO determine how to check whether wheel/sdist would be installed

... probably almost always, if it's a popular package. The commands =pip index=
and =pip cache= may help.

+ [[https://realpython.com/python-wheels/][What are python wheels and why should you care?]]
  - you should probably care if you have a decent machine

#+begin_example shell
$ time python -m pip install \
      --no-cache-dir \
      --force-reinstall \
      --no-binary=:all: \
      cryptography
#+end_example

***** Ensure python's pip is running with =python -m pip=

yeh, noob here

**** Parallel Builds

pip does some parallelism by default, but i'm not sure what

+ [[https://pythonspeed.com/articles/faster-pip-installs/][Making pip installs a little less slow]]

*** Data Science
**** SciPy/[[https://cupy.dev/][CuPy]] with AMD [[id:79d41758-7ad5-426a-9964-d3e4f5685e7e][Rocm]]

+ setup drivers in arch
  - =yay -Syu openblas-lapacksudo  opencl-amd-dev=
  - this installs all the ROCm, HIP and miopen packages
+ install scipy and numpy
+ install =cupy-rocm-5.0= by [[https://docs.cupy.dev/en/stable/install.html#building-cupy-for-rocm-from-source][building from source]]
  - ensure environment is set ([[rocm-opencl-runtime][install instructions]])

#+begin_example shell
export CUPY_INSTALL_USE_HIP=1
export ROCM_HOME=/opt/rocm
export HCC_AMDGPU_TARGET=gfx906

# pip install cupy-rocm-5. # specify ???

# instead run
pip install --no-cache-dir --force-reinstall --no-binary=:all: scipy numpy
pip install --no-cache-dir --no-binary=cupy cupy
#+end_example

The last option =--no-binary=:all:= is probably overkill

***** DONE rebuild cupy passing env vars to pip ([[https://docs.cupy.dev/en/stable/install.html#environment-variables][cupy docs]])
CLOSED: [2022-12-15 Thu 00:56]

**** Numba (LLVM JIT compiler, eats python & returns CUDA)
