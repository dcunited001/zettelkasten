:PROPERTIES:
:ID:       cf847bc5-31f7-4bb8-8324-7680a8f2953d
:END:
#+TITLE:     Shell
#+AUTHOR:    David Conner
#+EMAIL:     noreply@te.xel.io
#+DESCRIPTION: notes

* Ideas
** Profile Injection
+ Several options to achieve this:
  - templates (yuck)
  - profile builds (deploys .. yuck)
+ But some kind of portable dependency injection would be convenient
  - input/output redirection with =tee=
  - socket-oriented methods like =socat=

**** Examples of similar techniques
+ metasploit and pen-testing should probably use some of the same tricks:
  - for dynamic config mgmt, decentralization or obfuscation: one must handle
    data streams containing config pieces for other data streams
+ tricks from orchestration frameworks, esp if transmission or routing of
  config/state from =etcd= (or elsewhere) needs to be handed off indirectly to
  scripts/processes.
+ these techs would probably be found in orchestration of serverless functions



* POSIX

** Docs
+ Google [[https://google.github.io/styleguide/shellguide.html][Shell Style Guide]]

** Resources

** Issues

*** Bashisms
+ [[https://linux.die.net/man/1/checkbashisms][Check Bashisms]] script
+ [[https://betterprogramming.pub/24-bashism-to-avoid-for-posix-compliant-shell-scripts-8e7c09e0f49a][24 Bashism To Avoid for POSIX-Compliant Shell Scripts]]

*** Script injection
+ hmmm

** Topics

*** Job Management

**** Killing Child Jobs

From [[https://git.aweirdimagination.net/perelman/kill-child-jobs/src/branch/master/bash.sh][bash.sh]] in a [[kill-child-jobs][kill-child-jobs]] repo that covers compatibility between
bash/dash/ash. Full example with setup [[https://git.aweirdimagination.net/perelman/kill-child-jobs/src/branch/master/all-full-example.sh][all-full-example.sh]]. There's also =./tests=

#+begin_src shell
#!/usr/bin/env bash
set -e

# from:
# example:

kill_child_jobs() {
    # from:  https://unix.stackexchange.com/a/544167
    while kill %% 2>/dev/null; do sleep 0; done
}
#+end_src

*** Commands

**** tee

*** Append to =stdin= stream

+ 3,2,1 output reversed. Nothing outputs until =tee= receives newline. Shell
  hangs, typing =4\n= prepends a line
+ bash stdin gets bound when nothing pipes (doesn't work in org-babel)
  - Any newlines will terminate (even =C-j= to type newline)

#+begin_src sh
tee -a >(echo 1)  | tee -a >(echo 2)  | tee -a >(echo 3)
#+end_src

#+RESULTS:
| 3 |
| 2 |
| 1 |

#+begin_src sh
tee -a >(echo .) >(echo 1)  | tee -a >(echo 2)  | tee -a >(echo "3")
#+end_src

#+RESULTS:
| 3 |
| 2 |
| . |
| 1 |

#+begin_src sh
#+end_src

*** Append clipboard to =gpg= stream

#+begin_src sh
id="aionfork@gmail.com"
d="$(date +%s)"
t=$(($d - 120*24*60*60))
f=fdsa.gpg
tee -a  >(wl-paste) >(gpg -ad $f) |\
    gpg -aer $id --faked-system-time=$t > $f.bak
#+end_src

#+begin_src sh
gpg -dr $id $f.gpg | file -

# --no-throw-keyids may be useful for recovering data later
gpg --list-only --list-packets $f.gpg | grep ':pubkey'

# maybe move these to an airgapped computer,
# - extract tree of paths that needs to be recreated
# - filter what's definitely not mine
# - assume **/*.gpg > *.gpg.dec
# - migrate with dec files stored @ paths
# - ensure **/*.gpg.dec.gpg are decryptable by both keyids...
gpgAllMessages=$(mktemp)
gpgMigrateList=$(mktemp); echo -n ''> $gpgMigrateList
locate '/data/*.gpg/' > $gpgAllMessages
for g in $gpgAllMessages; do
    # todo: read/cut output lines one at a time,
    # cut ':pubkey' keyid,
    # prepend "$g " path
    gpg --list-only --list-packets $g | grep ':pubkey' > $gpgMigrateList
done
#+end_src

**** split and csplit

***** to lsof logs

strace is probably easier

#+begin_src sh
# piping works? but may not be safe idk
lsof -rp "$(pgrep someapp)" | grep -vE "(fontconfig|\.cache)"
csplit -f splitprefix- some-app-output.20240716.log "/=======/" "{*}"
#+end_src

+ =cut= to resplice columns or just =sort -k $keydef= since lsof can't
  predict output (to sort files)
+ then =comm= and/or =diff= on sequential =csplit= output files

*** Redirection

**** Fan in, Fan Out

***** Excerpt slice from man page (one liner)

I needed to compare an example config from =pinfo= with =/etc/pinforc=
on arch, since it differs. I thought it'd be simple, since I swear I
found an option for man to do this... I also thought there was an
option to avoid =cat <(man man)=

Seems like a giant waste of time. if i could efficiently query my
systems like a database, that'd be nice. preferably with zero required
=shinylang --install mcthing= or environment details to manage. it's
all data and bash is glue. ideally, venturing off like this would
require zero time.... but for some reason, i've never encountered most
of this information.

There are a few ways. Get lines from grep

#+begin_src sh
  cat <(man pinfo) | tail -n+"$line1" | tail -n"$(($line2-line1))"
#+end_src

Hard to forward to the next commands. Can't use =xargs= without
getting creative

#+begin_src sh
  cat <(man pinfo)
    | grep -ne 'COL_NORMA' -e 'SAFE-GROUP=nobody'
    | sed -E 's/(.*):.*/\1/g'

  # need FD's if you want to destructure (unless I can use tee)
  # cat -n /etc/pinforc | grep -e 'COL_NORMA' | cut -f1 | ...    
#+end_src

Another option that sounds good in theory (it probably doesn't): use
=join= to output line numbers with =grep=

#+begin_src sh
# just use =cat -n= sincegrep is a PITA
  cat -n <(man pinfo) | grep -ne 'COL_NORMA' |  -e 'SAFE-GROUP=nobody'
#+end_src

Trying with =tee=, but trying to place the commands is like wackamole

#+begin_src sh
  cat -n /etc/pinforc | tee >(grep -e 'COL_NORMA' | cut -f1 | xargs -I'{}' echo fdsa {}) | cat
#+end_src

With =csplit=

#+begin_src sh
  cat <(man pinfo) | csplit - '%COL_NORMAL.*%-1' '/SAFE-GROUP=nobody/+1'
#+end_src

***** retrospective

+ =paste= is ... not useful here
+ =tee= makes it tough to juggle stdout's that fan into into a single
  stdin. implicitly, a =pipe= is isomorphic to a =cat=, so basically
  you lose these special file descriptors at each stage. at the last
  stage (i think) you can duplex output from tee into =stdout= and
  =stderr= ... 
+ =join -1- -2-= can filter by line number. it can receive duplex
  input from stdin & one input can receive from a =<(procsub)=

As for =split and =csplit= almost fan in/out, but won't since the program
would need to dynamically allocate many FD's or reuse one/more. The
receiving pipe would need to be aware of the sending program's state &
output format ... more appropriate for a socket with an hoc protocol
(... also overkill)

Streaming concat JSON to =jq= to make sense of it. This line...
Without org-babel, I'm reaching for a one-liner... If I encounter
=csplit= or =split= again, the notes may be useful. These could
actually help out a ton:

#+begin_src sh
cat **/package.json | jq '.aquery' | csplit '%---%'= using a prefix
#+end_src

... avoids this nasty problematic awk that assumes everything alternates.

#+begin_src awk
BEGIN { count=0 }
($0 ~/^---/) { ++count; }
(count % 2 == 1) { print $0; }
(count % 2 == 0) { next; }  
#+end_src

**** Descriptor Usage

***** Enumerating With =strace=

#+begin_quote
TODO: here, I had planned to use multiple FD's or mkfifo
#+end_quote

This is a bit troublesome, since there are special considerations for strace's
own input/output redirection.

+ How to pipe to process =strace= invokes, but not =strace= itself? No idea
+ How to redirect =strace= subprocess output? Use =stderr= since it's own
  =stdout= produces the logged events

it's always irritated me that +there's no good way+ to write these desktop files.

#+begin_src sh
strace -f -e trace=write,dup2,read,openat man --where xdg-desktop-menu 2>/dev/null
#+end_src



I was looking for an a missing man page listing a CLI tool (maybe one )apropos
to the format description) ... and if not, then I thought to create one by
extract its keys. I guess these KDE and XDG files are modified =ini= format or
something.

+ You just need sed/awk or to expand templates like =*.erb= or =*.jinja=.
+ These are necessary to really get our of a Linux WM what you can't get through
  Win or Mac.
+ Managing these with some idempotentence or immutability would be helpful. It's
  not such a great fit for Ansible though (too much custom config, hard to keep
  in git)


*** System  Calls
**** Comparing =Bash= and =ShinyMcLang=

There is little difference between what Bash offers and the standard set of
system calls available via =glib= -- whether to C/C++ or to higher level
langauges wrapping the standard system calls

+ A good example would be to examine tools like =ansible-vault= or =sops= in
  various languages which leave flexibility over choice of =EDITOR=, but have a
  relatively similar set of processes to do so..
+ Though it may not look like that in each tool's source, they are all
  establishing the invocation of a process, arranging the management of objects
  (defined as abstractions by the kernel) like file descriptors, pid's, etc...

In summary, between Bash's metacharacters and recombinant variations of small
sets of system calls (e.g. found in the most basic of python's batteries) there
is no difference -- other than that things like =&123= or =<(...)= or =$?= or
=%2= are a few characters at most.

In effect, a scripting language offers many advantages:

+ tight control over input/output and over sequencing/timing
+ checking of well-defined types and higher-order abstractions
+ destructured logic that more plainly resembles the domain
+ reusable failure handling
+ more plainly defined extension of code by other callers, since Bash libs have
  a lot of potential for namespace collisions (when it's not easy to relabel
  something as =local= with any level of confidence.)

For interactively working with these objects, few people would use a scripting
language's REPL for much of anything besides REPL-Driven Development.

So then Bash's strength is in gluing these tools together.

*** Parameter Expansion

#+BEGIN_SRC sh
# I couldn't even tell what happened to that idiot savant there
foo=fubar; echo ${foo/fu/faux}
#+END_SRC

#+RESULTS:
: fauxbar

Bash is taught largely by apprenticeship, which does NOT scale. The
teleology of its features are largely understood through experience
... but this only transmits when people have a broad range of
experience.

Judging by publicly available scripts (outside of builds and corporate
automation), you start gathering a few tricks with little perspective
on how they fit into the whole. But if you stay there, Bash would be
painful.

#+begin_quote
Please tell me more about =tmux= and =vim= when you don't use Bash --
nothing against those programs, but IMO, /it should indicate expertise
in Bash/. If not, then you're almost certainly slower if you don't
fill in the gaps with something like Sourcetree or GitKraken. And you
should.
#+end_quote

Many syntax concepts in Bash are so are mundane that it's trivial to
fall asleep when learning them.

When someone's Bash Feature usage profile almost entirely lack a
single category, it usually indicates a lack of understanding of the
corresponding linux concepts -- lacking usage of jobs, process sub,
signals, traps, redirection, mkfifo, procfs in Bash usually indicates
a lack of understanding of process management, etc.

Many of these, like procsub, mkfifo and jobs could be useful at the
shell without a script. Scripts using some features (complex
redirection or jobs org traps) imply a specific line-count ... and
they're pointless to script without input sanitization.

#+begin_quote
Why did I only find out about the =sh-feature.el= functions in like
2022? It's not for lack of documentation. It's because people have no
idea this stuff is there.
#+end_quote

Scripting bash without templates is tough. Proper tooling like
[[https://github.com/bats-core/bats-core][bats-core/bats-core]] takes forever to set up. Adapting scripts to many
circumstances is a PITA and they just don't properly fit into many
projects. For me, generalizing the bash script usually requires a few
lines of code:

+ *to codify error handling:* doubles as documentation)
+ *to remap cases:* more work if you divide up the logic into the wrong
  programs or concepts


Usually about =90%= SLOC in =~/bin= scripts I write:

+ setting defaults/usage
+ enumerating getopts
+ remapping params
+ conditionals to final cal

By specing the connections between the caller's =env= and the expected
=closure= of the subshell/proc easier if rec, then a few, which





#+begin_quote
sidenote on the structure of logic in code: it either

+ branches with some depth /inside/ a single invocations
+ utilizes recursion, in which case it's /the parameters where you
  find the tree/ whereas the function that recurs is fairly flat.

ughhh.. maybe this coding pattern has a name. It's similar to
overloading with polyadic method signatures. e.g.

+ gcd(Int n, Int m)
+ gcd(Int n, Set<Int> mfactors)
+ gcd(Set<Int> nfactors, Set<Int> mfactors)
+ gcd(Set<Int> cofactors)
  

This refers to parameter substition only, not =1..n= recursion though
you would see a tree there as well ... e.g. extract parameters from a
function invocations in stack trace, where you could transform the
strings to types of trees or graphs (via =dot=)

It's important to clarify, since as it applies to Bash scripting,
anything that execs should be fairly flat with most of is logic in a
limited number of processes _AND_ files -- /I'm looking at you Node.js
with your 90,000 file reads./

Therefore: if using recursion for parameter substution, specify that
logic in bash functions intended to poof out of scope after =exec=.
#+end_quote

The Bash syntax provides visually accentuated grammar that summarizing
all the Unix/Linux concepts in a

The Bash syntax is almost literally a shorthand -- which i've
attempted to abreviate in miniscule derived from =~!@#%=.


**** From Bash Manual

+ [[info:bash#Major Differences From The Bourne Shell][info:bash#Major Differences From The Bourne Shell]]
+ [[info:bash#Major Differences From The Bourne Shell][info:bash#Major Differences From The Bourne Shell]]



| Syntax Like                   | POSIX | Name                     |                                        |
|-------------------------------+-------+--------------------------+----------------------------------------|
| =%= =#= =%%= =##=                     | y     | pattern removal expans.  | removes leading or trailing substrings |
| =${#somestring}=                | y     | String length            | returns the length of =${xx}=, is        |
| =${var:$i:$n}=                  | n     | Substring, length =n= at =i= |                                        |
| =${var/$pattern/$replacement} | n     |                          | example:                               |
|                               |       |                          |                                        |

     * The expansion , which expands to the
     substring of =var==s value of length LENGTH, beginning at OFFSET,
     is present (*note Shell Parameter Expansion::).

   * The expansion =${VAR/[/]=PATTERN=[/=REPLACEMENT=]}=, which matches
     PATTERN and replaces it with REPLACEMENT in the value of VAR, is
     available (*note Shell Parameter Expansion::).

   * The expansion =${!PREFIX*}= expansion, which expands to the names
     of all shell variables whose names begin with PREFIX, is available
     (*note Shell Parameter Expansion::).

   * Bash has indirect variable expansion using =${!word}= (*note Shell
     Parameter Expansion::).

   * Bash can expand positional parameters beyond =$9= using =${NUM}=.

   * The POSIX =$()= form of command substitution is implemented (*note
     Command Substitution::), and preferred to the Bourne shell=s =``=
     (which is also implemented for backwards compatibility).


**** From [[https://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_02][POSIX Parameter Expansion]] (via [[https://stackoverflow.com/a/16753536][s/o post]])

+--------------------+----------------------+-----------------+-----------------+
|   Expression       |       parameter      |     parameter   |    parameter    |
|   in script:       |   Set and Not Null   |   Set But Null  |      Unset      |
+--------------------+----------------------+-----------------+-----------------+
| ${parameter:-word} | substitute parameter | substitute word | substitute word |
| ${parameter-word}  | substitute parameter | substitute null | substitute word |
| ${parameter:=word} | substitute parameter | assign word     | assign word     |
| ${parameter=word}  | substitute parameter | substitute null | assign word     |
| ${parameter:?word} | substitute parameter | error, exit     | error, exit     |
| ${parameter?word}  | substitute parameter | substitute null | error, exit     |
| ${parameter:+word} | substitute word      | substitute null | substitute null |
| ${parameter+word}  | substitute word      | substitute word | substitute null |
+--------------------+----------------------+-----------------+-----------------+

Author shows it it in action:

+--------------------+----------------------+-----------------+-----------------+
|   Expression       |  When FOO="world"    |  When FOO=""    |    unset FOO    |
|   in script:       |  (Set and Not Null)  |  (Set But Null) |     (Unset)     |
+--------------------+----------------------+-----------------+-----------------+
| ${FOO:-hello}      | world                | hello           | hello           |
| ${FOO-hello}       | world                | ""              | hello           |
| ${FOO:=hello}      | world                | FOO=hello       | FOO=hello       |
| ${FOO=hello}       | world                | ""              | FOO=hello       |
| ${FOO:?hello}      | world                | error, exit     | error, exit     |
| ${FOO?hello}       | world                | ""              | error, exit     |
| ${FOO:+hello}      | hello                | ""              | ""              |
| ${FOO+hello}       | hello                | hello           | ""              |
+--------------------+----------------------+-----------------+-----------------+


* Direnv
** Docs
+ [[https://github.com/direnv/direnv/wiki][Direnv integrations]]

** Resources
+ [[https://www.pinnsg.com/direnv-take-control-of-your-development-environment/][direnv — Take Control of your Development Environment]] examples using direnv
  for five different types of projects: python (virtualenv), python (pyenv),
  ruby, node, go.

+ [[https://github.com/direnv/direnv/wiki/PS1][Setting shell prompt]]


** Topics

*** Pros/Cons

For modern programming/devops workflows, =direnv= is one of those hard & early
decisions you should make because it will resolve a lot of complexity later on
-- viz. probably don't use it!

I really like the tool, but it's a bit sad that i only started using it around
the time that i became unemployed (2014ish)

Direnv was gold back in the day, but now you have:

+ Docker/Compose :: already 12-factor; better management of volumes, tons of
  reference images & Containerfiles. Cons: ship-in-a-bottle.
+ Local K8S :: good. but cons: ship in a bottle; still works-on-my-machine &
  also what-about-that-cluster.
+ KubeVirt :: better VM orchestration, volume/disk management;
+ Guix/Nix :: direnv will usually create these as one-off profiles, unless you
  put some work into it. This can cause your SSD to accumulate wear (req. running =guix gc=)
+ The =.envrc= for =direnv= can't easily be distributed via =git=, since it's
  usually fairly personal.
+ Terminal Profiles ::  This is basically the same thing, but with less
  portability (& longevity of personal project configuration)
+ Screen/TMux Profiles :: Also basically identical.

*Direnv and VSCode are like oil and water.* The issue is mainly environment setup
and Process invocation in VSCode (which actually gives you an empty bash shell
instead of the default process that inherits environment)

+ VSCode designed to be multiplatform and run on Windows, with or without WSL2
+ implemented in electron/node and must run in a browser (and no one cares about
  BSD or Nix)
+ difficult to get LSP to run on host when project runs on Container/VM (and
  vice versa)
+ VSCode prefers to avoid =pyenv= (read above at "empty bash") and similar tools

*Direnv caveats you should know AoT:*

+ transferability of =.envrc= between paths/hosts
+ you should not evaluate/configure secrets to be available in its environment:
  env. vars, functions, logs and other implementation details (not vulns.)
+ does not do aliases; will not run under another user
+ The =.envrc= may go stale, but not via updates to Direnv plugins (it seems
  well thought out and maintained) ... you actually need to solve this same
  problem on your =~/.config/direnv= scripts -- when you change/alter a script,
  others may break

**** When to use direnv?

On traditional Linux distros, using =direnv= with tools like =pyenv= is fairly
easy. But Fedora/Arch may require different parameters than Nix/Guix or entirely
different implementations in your =~/.config/direnv= ... (see above for why to
not make arbitrary changes here)

Basically, use it when you need:

+ light automation/setup :: you could also
+ native performance or NUMA :: you don't
+ IPC :: just easier than forwarding sockets, esp if you need a repeatable
  process to be quick/dirty.
+ bare-metal hardware :: much easier, definitely simpler, but actually less
  reproducible than isolated devices (virsh + xml) with proper labeling (mgmt of
  content)
+ bare-metal networking :: you shouldn't, but they just don't give you SR-IOV in
  consumer anything
+ management of processes :: i'm not sure how the runtime for Kind is set up to
  fork processes (or whatever) from inside the container

Easier but sometimes more difficult to manage:

+ permissions
+ sprawl (files, data)
+ services & service management

Usually more complex

+ SELinux/AppArmor

PITA

+ namespacing

** Issues


*** TODO Direnv needs to be in =.bashrc= but what about automated tasks?

* Utilities

** Script

This allows you to record input/output streams in a terminal or command. See
=man script=. This command is a little hard to Google.

Log the output of a session. For escape codes (colors/etc) you'll need to =cat
test.typescript= or otherwise specify how to handle them for logged content.

#+begin_example shell
script -q test.typescript
#+end_example

Or run for a particular command

#+begin_example shell
script -qc "ansible -i my.server.local, -m setup my.server.local" ansible.typescript
#+end_example

** Directory Listing
*** Tree

# :results output verbatim

#+begin_src sh :results output none :dir ./jekyll/jekyll-theme-basically-basic
tree -I "vendor" ./_sass
#+end_src

Also possible to write to HTML output using:

#+begin_src sh :results output verbatim :dir ./jekyll/jekyll-theme-basically-basic
# the ignore patterns don't work well. just use a single subdir component...
# use -P $pattern to include and -a to consider hidden files.
tree -I "vendor"
     -H "file:///the/file/path/for/links" > ../theme-sass-files.html
#+end_src


** Awk

*** Docs
+ [[https://www.grymoire.com/Unix/Awk.html][Bruce Barnett's Awk Tutorial]]
+ [[https://www.gnu.org/software/gawk/manual/gawkinet/gawkinet.html][Gawkinet]] (ingest/transform TCP data... hmmmm)
+


*** Resources
+ [[https://jherrlin.github.io/posts/learn-awk/][Learn AWK with Emacs]]
+ [[https://themouseless.dev/posts/awk-guide-examples-mouseless/][Mouseless Dev: Awk Guide Examples]]:

**** Style Guides
+ [[https://github.com/mbbx6spp/styleguides/tree/master/awk][mbbx6spp/styleguides]] suggests snake_case vars


*** Topics

**** Examples



**** GNU Parallel

+ [[https://blog.ronin.cloud/gnu-parallel/#quoting-complex-commands][Parallelising Jobs with GNU Parallel]]

#+begin_src awk
BEGIN { count=0 }
(count == MYVAR)
{print $0}
{print count}
{++count}
#+end_src

*** Print From readthedocs.io

#+begin_src javascript
document.querySelectorAll('nav.wy-nav-side').forEach(el => el.remove());
document.querySelectorAll('footer').forEach(el => el.remove());
document.querySelectorAll('div[role="navigation"]').forEach(el => el.remove());
#+end_src

#+begin_src css
@media screen and (min-width: 1100px) {
  .wy-nav-content-wrap {
    /* background: rgba(0,0,0,0.05); */
  }
}

h1 {
  font-size: 140%;
}

h2 {
  font-size: 120%;
}

.wy-nav-content-wrap {
  margin-left: 0.1em;
}

.wy-nav-content {
  max-width: 100%;
  padding: 0.2em;
}

html {
  /* font-size: 16px; */
  font-size: 11px;
}

.rst-content h1, .rst-content h2, .rst-content .toctree-wrapper > p.caption, .rst-content h3, .rst-content h4, .rst-content h5, .rst-content h6 {
  /* margin-bottom: 24px; */
  margin-bottom: 0.1em;
}

p {
  /* margin-bottom: 24px; */
  margin-bottom: 0.1em;
}

.wy-plain-list-decimal, .rst-content .section ol, .rst-content .section ol.arabic, .rst-content section ol, .rst-content section ol.arabic, .rst-content .toctree-wrapper ol, .rst-content .toctree-wrapper ol.arabic, article ol {
  /* line-height: 24px; */
  /* margin-bottom: 24px; */
  line-height: 1em;
  margin-bottom: 0.1em;
}

.wy-plain-list-decimal li, .rst-content .section ol li, .rst-content .section ol.arabic li, .rst-content section ol li, .rst-content section ol.arabic li, .rst-content .toctree-wrapper ol li, .rst-content .toctree-wrapper ol.arabic li, article ol li {
  /* margin-left: 24px; */
  margin-left: 0.3em;
}

.rst-content pre.literal-block, .rst-content div[class^="highlight"] pre, .rst-content .linenodiv pre {
  /* line-height: 1.4; */
  line-height: 1.2;
}

.rst-content div[class^="highlight"] pre {
  /* padding: 12px 12px; */
  padding: 0.1em;
}

.rst-content pre.literal-block, .rst-content div[class^="highlight"] {
  /* margin: 1px 0 24px 0; */
  margin: 0.1em 1em;
}

.wy-plain-list-disc li, .rst-content .section ul li, .rst-content section ul li, .rst-content .toctree-wrapper ul li, article ul li {
  /* margin-left: 24px; */
  margin: 0.1em 1em;
}

.wy-plain-list-disc, .rst-content .section ul, .rst-content section ul, .rst-content .toctree-wrapper ul, article ul {
  /* margin-bottom: 24px; */
  margin-bottom: 0.1em;
}

b, strong {
  color: darkgreen;
}
.highlight {
  background-color: lemonchiffon;
}

#+end_src

*** Issues
**** Variables
+ Vars don't use ="$DOLLA"= because it makes shell interpolation complicated,
  especially for one-liners using =awk -v my_var=myvalue=

**** Org Babel

+ Org Babel: call awk with loop?
**** Output Redirection

+ [[https://stackoverflow.com/questions/26343823/writing-to-multiple-files-with-awk][Writing to multiple files]]: Awk supports redirection with =>= and =>>= ... just
  track state with a filename var.


* Bash

** Docs
+ [[https://linuxcommandlibrary.com/basic/oneliners][LinuxCommandLibrary: One Liners]]

*** Prompt

+ [[https://www.askapache.com/linux/bash-power-prompt/][Bash Power Prompt]] one-liners
+ Giles Orr [[https://gilesorr.com/bashprompt/prompts/index.html][Bash Prompts]]
+ [[https://tldp.org/HOWTO/Bash-Prompt-HOWTO/index.html][tldp: Bash Prompt HOWTO]] (good, but no previews afaik)

** Resources

+ The [[https://unix.stackexchange.com/questions/587207/why-is-bash-sourcing-bashrc-in-non-interactive-mode-when-working-via-ssh][SSH_SOURCE_BASHRC]] controversy...

*** Articles

*** Basics
+ [[https://www.cs.cmu.edu/~15131/f15/topics/bash/][Practical Ideas for Bash]] (CMU)
+ [[Bash Programming (intro/howto)][Bash Programming (intro/howto)]]
+ [[https://cheat.sh/xargs][xargs cheatsheet]]

*** Advanced Bash-Scripting Guide
+ [[https://tldp.org/LDP/abs/html/bash2.html][Contains high-level changelog for Bash v2.0 to v4.2]]

*** [[https://web.archive.org/web/20000824170847/http://www.ssc.com/ssc/bash/][SSC Bash Reference]]

Nigh impossible to find on the nets. It was fairly common at some point.  A
little tough to print: a =4x1= page layout works though.

Now nearly disappeared from the internet except for a university link. before
2004 because authors wanted $4.95 CoD for it ... which is honestly fair. But
most other bash cheatsheets are inferior.

The webarchive link probably covers Bash v2.0, but I would imagine any newer
Bash versions are a superset of the v2.0 functionality:

#+begin_quote
If you break the build in 1999 ... I want to imagine that every gets a CD in the
mail, but I guess UseNET?

Regardless, version pinning is ... not ... Nevermind, pinning isn't relevant.

Let's ask Slackware/pkgtools(?) ... wiki history on that page only goes back to [[https://docs.slackware.com/slackware:package_management?rev=1356846847][2012]]

Can you pin a patchset? But =patchwork= doesn't exist yet (not that I know what
it does).

Final answer, Regis. Bash v3.0 and v4.0 are supersets of v2.0
#+end_quote

I'm not sure really, but ChatGPT would be no fun here, since "[[https://te.xel.io/posts/2017-10-30-speed-of-thought-sociophysical-postulates-1-to-11.html#emulation-of-ancient-thought-penultimate-metacognition][Emulation of
Ancient Thought Is Penultimate Metacognition]]." Obviously the correct answer is
important, but it is not necessarily the most valuable product of a question.

** Security
+ [[https://unix.stackexchange.com/a/322821][Finding where bash functions are defined]] (and the obfuscation thereof)

** Topics



*** Prompt

**** [[https://wiki.archlinux.org/title/Bash/Prompt_customization][Using =tput= vs raw chars]]

Raw chars will ultimately need to be interpreted by the terminal. the main issue
is =xterm= vs =xterm-256color=. For compat (and to use =tput=), just use the latter.
See [[https://wiki.archlinux.org/title/Bash/Prompt_customization#Terminfo_escape_sequences][terminfo escape sequences]]


**** [[https://superuser.com/questions/301353/escape-non-printing-characters-in-a-function-for-a-bash-prompt/301355#301355][Escaping with =\[= and =\]=]]

**** Shell Prompts

These examples were from before I learned about =PROMPT_COMMAND=

***** From Dotfiles

Update PS1 according to [[https://github.com/direnv/direnv/wiki/PS1][direnv wiki]]

To check capabilities, see =man terminfo= and =infocmp=

#+begin_src sh :tangle .config/sh/rc.d/prompt.sh :shebang #!/bin/sh
export PS_INFO=""
export PS_PROMPT=""

PS_GIT=""
GIT_PS1_SHOWCOLORHINTS=1
GIT_PS1_DESCRIBE_STYLE=branch
GIT_PS1_SHOWUPSTREAM=name

PS_PROMPT="${LYELLOW}\A ${LGREEN}\u${RED}@${LCYAN}\h ${RED}:: ${YELLOW}\w"
if [ -n "$GUIX_ENVIRONMENT" ]; then
    PS_INFO="${LMAGENTA}g${RESTORE}"
fi

if [ "$TERM" = "dumb" ]; then
    PS1='$ '
else
    PS_GIT='$(__git_ps1 "«%s»") '
    PS_INFO="$PS_GIT $PS_INFO"
    PS1="$PS_INFO \n$PS_PROMPT"

    # calc number of cols with $((COLUMNS -n ))
    if [ -n "$PS_GIT" ]; then
       PS1="$PS1"
    fi
    PS1="$PS1${RED}$ ${RESTORE}"
fi

#+end_src

***** Ok, nevermind then

TFW trying to avoid side effects in function (... but then realizing you in bash)

#+begin_src sh :tangle .config/sh/prompt.sh :shebang #!/bin/sh

ps_update() {
    # $1: PS_PROMPT $2: PS_INFO (optional)
    if [ "$TERM" = "dumb" ]; then
        # || [ $# -ge 1 ]
        # || [ -z "${RESTORE}" ] # well that's unfortunate
        return # fail silently
    fi

    if [ -z "$PS_PROMPT" ]; then
       PS_PROMPT="<=> ${RESTORE}"
    fi

    local ps_new="$PS_PROMPT"
    if [ -n "$PS_INFO" ]; then
        psnew="$PS_INFO\n$psnew$"
    fi
    psnew="$psnew ${RED}$ ${RESTORE}"
    echo $psnew

    # using in .envrc makes and it becomes specific to my system.
}

# PS1="$(ps_update \"$PS_INFO\")"
# TERM=dumb
#+end_src

To use in direnv (untested....)

#+begin_example sh
PS_INFO="${PS_INFO}${LGREEN}[ foo ]${RESTORE} "
[[ -n "$(declare -F ps_update)" ]] && psnew="$(ps_update $PS_INFO)"
#+end_example

Reload =direnvrc= with =direnv reload=

**** Terminal Title

None of the suggestions from this [[https://stackoverflow.com/questions/71459823/how-to-change-the-terminal-title-to-currently-running-process][stack overflow]] seem to work.... i thought I
could do this with something mentioned in =man terminfo=... but every fucking term
app is different? that's it ... i'm going to write a terminal emulator called
=ytfnott3rm=

The issue is that there's no way to reconcile the configuration idiosyncracies,
which /yes/ are notoriously difficult with terminal emulators.

OMFG ... just use the network. dotfiles are dead. Serioiusly, I'd like to
actually get some mileage out of window manager configuration.


***** set-title

This apparently works in =alacritty=

#+begin_example shell
function set-title() {
   if [[ -z "$ORIG" ]]; then
     ORIG=$PS1
   fi
   TITLE="\[\e]2;$*\a\]"
   PS1=${ORIG}${TITLE}
 }
#+end_example


*** Colors

#+begin_quote
hmmmmm colors in man are gone except for the standout effect on the status
line. /Some of it/ is still there in vty's. but =!echo $PAGER $MANPAGER and $(which less)=
from within man/less show the expected output AFAIK.
#+end_quote

**** From Dotfiles

Shell colors (stackoverflow)

#+begin_src sh :shebang #!/bin/sh
if [ "$TERM" != "dumb" ]; then
    #export CURSOR_BOX=$(echo -e '\001\033[\017

    export RESTORE=$(echo -en '\001\033[0m\002')
    export STANDOUT=$(echo -en '\001\033[00;44;37m\002')
    export RED=$(echo -en '\001\033[00;31m\002')
    export GREEN=$(echo -en '\001\033[00;32m\002')
    export YELLOW=$(echo -en '\001\033[00;33m\002')
    export BLUE=$(echo -en '\001\033[00;34m\002')
    export MAGENTA=$(echo -en '\001\033[00;35m\002')
    export PURPLE=$(echo -en '\001\033[00;35m\002')
    export CYAN=$(echo -en '\001\033[00;36m\002')
    export LIGHTGRAY=$(echo -en '\001\033[00;37m\002')
    export LRED=$(echo -en '\001\033[01;31m\002')
    export LGREEN=$(echo -en '\001\033[01;32m\002')
    export LYELLOW=$(echo -en '\001\033[01;33m\002')
    export LBLUE=$(echo -en '\001\033[01;34m\002')
    export LMAGENTA=$(echo -en '\001\033[01;35m\002')
    export LPURPLE=$(echo -en '\001\033[01;35m\002')
    export LCYAN=$(echo -en '\001\033[01;36m\002')
    export WHITE=$(echo -en '\001\033[01;37m\002')
else
    export RESTORE=""
    export STANDOUT=""
    export RED=""
    export GREEN=""
    export YELLOW=""
    export BLUE=""
    export MAGENTA=""
    export PURPLE=""
    export CYAN=""
    export LIGHTGRAY=""
    export LRED=""
    export LGREEN=""
    export LYELLOW=""
    export LBLUE=""
    export LMAGENTA=""
    export LPURPLE=""
    export LCYAN=""
    export WHITE=""
fi

export LESS_TERMCAP_mb="${LRED}"
export LESS_TERMCAP_md="${LRED}"
export LESS_TERMCAP_me="${RESTORE}"
export LESS_TERMCAP_se="${RESTORE}"
export LESS_TERMCAP_so="${STANDOUT}"
#export LESS_TERMCAP_so=$'\E[00;44;37m'
export LESS_TERMCAP_ue="${RESTORE}"
export LESS_TERMCAP_us="${LGREEN}"

# fix for less as MANPAGER
# https://bbs.archlinux.org/viewtopic.php?id=287185
export GROFF_NO_SGR=1
#+end_src

And when no colors

+ Protesilaos: [[file:/data/ecto/x.files/protesilaos/dotfiles/shell/.bashrc::Colourise man pages][font & color config for man]]
+ =man termcap= for an explanation of codes
+ example dircolors output: [[file:/data/ecto/x.files/benmezger/dotfiles/dot_dircolors][benmezger dircolors]]

**** Less Termcaps

Source: [[https://unix.stackexchange.com/questions/108699/documentation-on-less-termcap-variables][stackoverflow]]

|---------+----------+------------------------------------|
| termcap | terminfo | desc                               |
|---------+----------+------------------------------------|
| ks      | smkx     | make the keypad send commands      |
| ke      | rmkx     | make the keypad send digits        |
| vb      | flash    | emit visual bell                   |
| mb      | blink    | start blink                        |
| md      | bold     | start bold                         |
| me      | sgr0     | turn off bold, blink and underline |
| so      | smso     | start standout (reverse video)     |
| se      | rmso     | stop standout                      |
| us      | smul     | start underline                    |
| ue      | rmul     | stop underline                     |
|---------+----------+------------------------------------|
*** Misc Helpful Things

Variable formatting

|---------------------------+----------------+-----------------------+---------------------------|
|                           | example        |                       |                           |
|---------------------------+----------------+-----------------------+---------------------------|
| ~${FILENAME#__file}~        | ${PATH#*:*:*:} | pop =n= paths off =$PATH= | removes prefix pattern == |
| ~${"${FILENAME%.sh}"%shim}~ |                |                       | bad substitution          |
| ~${"${FILENAME%.sh}"%shim}~ |                |                       | bad substitution          |
|                           |                |                       |                           |

+ basename $1 .ext :: potential injection when handling unquoted
  input, esp when accepting multiple paramters.
  + without proper =--=  which can always be added by caller
  + =basename -m -s "$extension" $1 $2 $3= when "'$1'" =~ '-- afile'=
  + though there probably be better examples than that 
  


""

+ [[info:bash#Major Differences From The Bourne Shell][info:bash#Major Differences From The Bourne Shell]]

**** Magic Variables

See also "parameter expansion" from POSIX

***** [[https://gist.github.com/wcarhart/23008155c0699b497879595c84294296][wcarhart/bash_tidbits.md]] (gist)

|-----------------+----------------------------+-------------------------------------------------------|
|                 |                            |                                                       |
|-----------------+----------------------------+-------------------------------------------------------|
| check filetype  | ~if [[ "$1" == *$2]]; then~  | a glob?                                               |
| ~script~ command  | pipe to: ~script 'screen -'~ | invoke without attached term (also records a session) |
| ~!! !^ !:2 !:3~   | nth args                   | i always forget the chars for nth args                |
| ~!!:2-4~          | nth args from =2= to =4=       |                                                       |
| ~!!:-4~           | nth args from =0= up to =4=    | includes the command                                  |
| ~!!:0-~           | nth args, except the last  | if you want the last, just use =!!=                     |
| ~echo "bar"{-2,}~ | bar2 bar                   |                                                       |

****** TODO look at other scripts (convert to snippets?)
+ [ ] helpful_array_manipulation
+ [ ] modular_script_template
+ [ ] subcommand_parser (this brought me to the gist, good example, too meta)


*** Arithmetic

With =bc=, calculate the size of all the Kanji SVG's

#+begin_src sh
# git clone https://github.com/wsgac/kanji-mode && cd kanji-mode
ls -al ./kanji | cut -b21-26 \
    | xargs | sed -e 's/ /+/g' \
    | bc
#+end_src

The good news is that this library probably doesn't need many updates, so it's
size in a Guix/Nix store doesn't matter much -- as long as there's an extant
link from a top-level user profile in the store (also potentially a downside)

*** Argument Handling

**** Getopts

+ [[https://www.golinuxcloud.com/bash-getopts/#getopt_vs_getopts][Beginners Guide to Use Getopts]]

Emacs has =sh-insert-getopts= so now I don't need to write a snippet.


**** Getopt

This allows providing short and long options with default values. It's a bit
simpler, but the syntax is more complicated.

+ [[https://stackoverflow.com/questions/402377/using-getopts-to-process-long-and-short-command-line-options][Using getopts to process long and short cmd line options]]

*** Substitution
**** Arrays

#+begin_src bash
echo "# args: $#"
echo "@ args: $@"
echo "* args: $*"

# same symbols in arrays/hashes
foo=("'1'" "'2'" a$'\t'bc)
echo "${#foo} ${#foo[@]} ${#foo[*]}"
bar="${foo[@]}" && echo $bar
bar="${foo[*]}" && echo $bar
#+end_src

#+RESULTS:
| #   | args: | 0 |    |
| @   | args: |   |    |
| *   | args: |   |    |
| 3   | 3     | 3 |    |
| '1' | '2'   | a | bc |
| '1' | '2'   | a | bc |

*** History
+ [[https://www.cherryservers.com/blog/a-complete-guide-to-linux-bash-history][A complete guix to linux bash history]]

** Issues

*** Does bash do a thing?

**** Does bash export environment variables set with =env=

apparently yes

#+begin_src sh
env FOO=bar bash -c 'echo $$ && bash -c "echo $$ $FOO"'
#+end_src

*** Gargarsgs (things that be hard that should not be)

**** Read multiline var into array (or variable)

See this [[https://serverfault.com/questions/72476/clean-way-to-write-complex-multi-line-string-to-a-variable][stack overfault]]

#+begin_example sh
#!/bin/bash

mapfile Pattern <<-eof
        <?xml version="1.0" encoding='UTF-8'?>
        <painting>
          <img src="%s" alt='%s'/>
          <caption>%s, painted in
          <date>%s</date>-<date>%s</date>.</caption>
        </painting>
        eof

while IFS=";" read file alt caption start end ;do
    printf "${Pattern[*]}" "$file" "$alt" "$caption" "$start" "$end"
  done <<-eof
        madonna.jpg;Foligno Madonna, by Raphael;This is Raphael's "Foligno" Madonna;1511;1512
        eof

#+end_example

And the rationale:

#+begin_quote
mapfile read entire here document in an array.

the syntaxe "${Pattern[*]}" do cast this array into a string.

I use IFS=";" because there is no ; in required strings

The syntaxe while IFS=";" read file ... prevent IFS to be modified for the rest of the script. In this, only read do use the modified IFS.

no fork.
#+end_quote

Holy shit, that's a time saver right there.

***** This hack right here...

LOL... it almost works (still no line breaks)

#+begin_example sh
while IFS='' read -r -d '' _usage; do
    _usage=$_usage
done<<EOF
  muh FOE
EOF

echo $_usage
#+end_example

* Zsh


* Fish
