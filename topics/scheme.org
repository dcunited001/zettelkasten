:PROPERTIES:
:ID:       87c43128-92c2-49ed-b76c-0d3c2d6182ec
:END:
#+title: Scheme

+ [[Guix]]

* Docs
+ [[https://www.gnu.org/software/guile/manual/html_node/index.html][Guile Reference]]
+ [[https://www.gnu.org/software/guile/manual/html_node/index.html][Guile Home]]

+ awesome-guile
** Fundamentals

*** Macro-by-example

Via guile-awesome

[[https://legacy.cs.indiana.edu/ftp/techreports/TR206.pdf][(TR206, 1986) Macro-by-example: Deriving Syntactic Transformations from their
Specifications]] This is old, but good bc, as is often the case, it concisely lays
out primative assumptions/explanations (without assuming that everyone in
academia "just gets it"). It defines common/essential scheme ideas in terms of
lambda-calc using the functional =relation: (domain,...) -> range= notation:

+ eval/apply
+ pattern matching
+ binding
+ language-within-language

** GNU
- [[https://www.gnu.org/software/artanis/manual/artanis.pdf][Artanis]]

** Books
- R. Kent Dybvig: [[https://www.scheme.com/tspl4/][The Scheme Programming Language]]
- Abelson/Sussman: [[https://mitpress.mit.edu/sites/default/files/sicp/index.html][Structure & Interpretation of Computer Programs]]
- Steve Litt: [[https://www.troubleshooters.com/codecorn/scheme_guile/hello.htm][Scheme at a Glance]]

* Language

** Basics

** [[https://www.gnu.org/software/guile/manual/html_node/Data-Types.html][Data Types]] (guile)
*** [[https://www.gnu.org/software/guile/manual/html_node/Lists.html][Lists]]

** Async
+ Promises ([[https://www.gnu.org/software/guile/manual/html_node/Delayed-Evaluation.html][Delayed Evaluation]])
  - delay, promise?, force

** SRFI
+ srfi-171 [[https://www.gnu.org/software/guile/manual/html_node/SRFI_002d171.html][Transducers]]
+ srfi-41 [[https://www.gnu.org/software/guile/manual/html_node/Streams.html][Streams]]
+ srfi-37 [[https://www.gnu.org/software/guile/manual/html_node/SRFI_002d37.html][args-fold]]: =getopt_long= program arguments
  - used in guix scripts to parse arguments

* Resources

** Guides
+ [[https://www.draketo.de/proj/py2guile/py2guile.pdf][Going from Python to Guile Scheme]]
+ [[https://wiki.call-cc.org/chicken-for-ruby-programmers][Chicken for Ruby Programmers]]
+ [[https://notabug.org/ZelphirKaltstahl/awesome-guile][ZelphirKaltstahl/awesome-guile]]
+ [[https://gitlab.com/Marie-Joseph/scheme-primer/-/blob/main/scheme-primer.org][spritely/scheme-primer]] (from [[https://spritely.institute/static/papers/scheme-primer.html][here]])
+ [[https://www.bcl.hamilton.ie/~barak/teach/S99/CS257/texts.html][CS 257: Texts, Docs, Scheme Impl and Related Material]]


** Study
+ [[github:flatwhatson/advent-2020][flatwhatson/advent-2020]]
+ [[https://htdp.org/][htdp.org]]

* Ecosystem
** Libraries
*** [[https://spritely.institute/goblins/][Goblins]] (distributed objects)
A [[https://spritely.institute/][Spritely]] implementation for Guile -- like Ruby's [[https://github.com/ruby/drb][DRB]], but in Lisp-1

*** GnuTLS
+ It has a [[https://gnutls.gitlab.io/coverage/master/cyclo.html][cyclomatic complexity report]] generated by [[https://github.com/datacom-teracom/pmccabe][pmccabe]]
  - [[https://github.com/rofl0r/gnulib/blob/master/modules/pmccabe2html][pmccabe2html]]
  - GNU also has [[https://www.gnu.org/software/complexity/manual/][Complexity]]
*** Data Formats

[[https://gitlab.com/joolean/r6rs-protobuf/][joolean/r6rs-protobuf]] (includes codegen, apparently)

* Topics
** DSL's
+ [[Embedding Scheme for a game mission scripting DSL][Embedding Scheme for a Game Mission Scripting DSL]]
+ [[https://github.com/JianyuanXiao/PSCMC][JianyuanXiao/PSCMC]]: a DSL for graphics shaders based on Scheme.

** Parsing/Lexing
+ [[https://www.ccs.neu.edu/home/shivers/papers/scmparse.pdf][Lexer and Parser Generators in Scheme]]

** Extending GNU applications With Scheme
+ gEDA
+ Gimp
  - [[https://technote.fyi/programming/the-gimp/become-a-gimp-script-fu-master-with-guile-aka-scheme/][Become a Gimp Script-Fu Master: with Guile (aka Scheme)]]


** Language
*** Modules

How to filter exports:

#+begin_src scheme
(use-modules ((ice-9 popen)
              #:select ((foo . foo-as-foo2) bar baz)
              #:prefix howtofilterexports:))
#+end_src

*** Features

+ [[https://stackoverflow.com/questions/15892214/scheme-overload-built-in-procedures-general-overloading][Overloading methods]] (s/o)

* Issues


* Geiser

** [[https://elpa.nongnu.org/nongnu/doc/geiser.html][Docs]]
** Resources
** Topics
*** Useful functionality

REPL

|---------+-----+------|
| command | key | desc |
|---------+-----+------|
|         |     |      |
|---------+-----+------|

Scheme

|---------+-----+------|
| command | key | desc |
|---------+-----+------|
|         |     |      |
|---------+-----+------|

+ geiser-doc-look-up-manual, bound to C-c C-d i.
+ modules exported by

Guix

|---------+------------------------+------------------------------|
| command | key                    | desc                         |
|---------+------------------------+------------------------------|
| C-M-x   | geiser-eval-definition | eval top-level form at point |
|---------+------------------------+------------------------------|

** Issues

*** Guix source needs to be compiled
Geiser will try to compile it, but this should be done manually

Follow the directions here to build: [[id:c610536e-71d8-45ad-b320-91696ee56d49][Guix: authenticate local checkout when
using google repo]]

Running =repo sync= will invalidate the relationships b/w compiled guile and the
source. It may cause other problems.

*** Geiser/Guile Imports
**** By default Geiser loads =~/.guile-geiser=

With no =~/.guile*= being loaded:

#+begin_example scheme
(guile)
(system base compile)
(ice-9 session)
(ice-9 regex)
(ice-9 threads)
(value-history)
(geiser emacs)
#+end_example

Adding the colorized module to =~/.guix-profile= and loading =~/.guile-geiser=

#+begin_example diff
2a3,5
> (ice-9 format)
> (ice-9 pretty-print)
> (ice-9 colorized)
#+end_example

Properly handingling colors in emacs requires =(setq geiser-debug-treat-ansi-colors 'colors)=

**** Geiser adds the local project path by default

With the following config

#+begin_src emacs-lisp
(setq geiser-repl-per-project-p t)
(setq geiser-repl-add-project-paths nil)
#+end_src

And starting a repl from the scratch-buffer:

#+begin_example scheme
("/gnu/store/7r466prr45b1v38gzqlbl4gfl0g1vc5k-emacs-geiser-guile-0.28.1/share/emacs/site-lisp/geiser-guile-0.28.1/src"
 "/home/dc/.guix-profile/share/guile/site/3.0"
 "/gnu/store/4gvgcfdiz67wv04ihqfa8pqwzsb0qpv5-guile-3.0.9/share/guile/3.0"
 "/gnu/store/4gvgcfdiz67wv04ihqfa8pqwzsb0qpv5-guile-3.0.9/share/guile/site/3.0"
 "/gnu/store/4gvgcfdiz67wv04ihqfa8pqwzsb0qpv5-guile-3.0.9/share/guile/site"
 "/gnu/store/4gvgcfdiz67wv04ihqfa8pqwzsb0qpv5-guile-3.0.9/share/guile")
#+end_example

When Projects share their repls, then this gets messy. Loading a repl from my
dotfiles diffs the =%load-path= like:

#+begin_example diff
c1,5
< ("/gnu/store/7r466prr45b1v38gzqlbl4gfl0g1vc5k-emacs-geiser-guile-0.28.1/share/emacs/site-lisp/geiser-guile-0.28.1/src"
---
> ("/another/challenger/has/entered/load/path"
>  "/home/dc/.dotfiles"
>  "/home/dc/.dotfiles/ellipsis/"
>  "/gnu/store/7r466prr45b1v38gzqlbl4gfl0g1vc5k-emacs-geiser-guile-0.28.1/share/emacs/site-lisp/geiser-guile-0.28.1/example"
>  "~/.dotfiles/ellipsis/"
#+end_example

And this repl loads different modules ...

Whereas a file like =(define-module (dc home blank))= will just show =(guile)= for
=,imports=, after switching to a file with basic modules:

#+begin_src scheme
(define-module (dc home common)
  #:use-module (srfi srfi-1)
  #:use-module (ice-9 format)

  #:use-module (guix gexp)

  #:use-module (gnu packages)

  #:use-module (gnu services)
  #:use-module (gnu home services)
  #:use-module (gnu home services guix)
  #:use-module (gnu home services fontutils))
#+end_src

Will show the following imports (without loading =~/.guile-geiser=

#+begin_src scheme
(guile)
(value-history)
(srfi srfi-1)
(ice-9 format)
(guix gexp)
(gnu packages)
(gnu services)
(gnu home services)
(gnu home services guix)
(gnu home services fontutils)
#+end_src

With the following config, it may be difficult to keep track of the REPL
buffers, though using the =geiser-mode= functions from the scheme buffer makes
this simpler.

#+begin_src emacs-lisp
(setq geiser-repl-per-project-p t)
(setq geiser-repl-add-project-paths nil)
#+end_src

*** Geiser Xref doesn't function well inside guix profile with links

When Geiser's =%load-path= is something like the following, then

#+begin_example scheme
'("/gnu/store/hp4zdsbw2yl09vxwdk51g9gdcghnm4b6-emacs-geiser-guile-0.28.1/share/emacs/site-lisp/geiser-guile-0.28.1/src"
"/data/ecto/guix/guix"
"/home/dc/.guix-profile/share/guile/site/3.0..."
"...")
#+end_example

Then the list can be popped with ... nevermind, that should prioritize Guile
modules/functions to be located in =/data/ecto/guix/guix=, which can be modified
and recompiled ... I think?

This isn't ideal. For each module in =/data/ecto/guix/guix=, the same module is
defined elsewhere along the =%load-path=. It should be jumping to the source in
that directory, but usually jumps to =$HOME/.config/guix/current=.

