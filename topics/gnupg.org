:PROPERTIES:
:ID:       b987ce8b-c42f-4de2-83c4-350be3cf5de1
:END:
#+TITLE: GNUPG
#+DESCRIPTION:
#+TAGS:
* Roam
+ [[id:c2afa949-0d1c-4703-b69c-02ffa854d4f4][Cryptography]]

* Docs
* Resources

** GPG

*** Configuration

+ [[https://github.com/drduh/config/blob/master/gpg.conf][drduh/config]] gpg.conf
+ [[https://www.gnupg.org/documentation/manuals/gnupg/GPG-Configuration-Options.html][GPG Config Options]] (docs)
+ [[https://www.gnupg.org/documentation/manuals/gnupg/GPG-Esoteric-Options.html][GPG Esoteric Options]] (docs)

*** Source [[https://git.gnupg.org/cgi-bin/gitweb.cgi][git.gnupg.org]]

[[https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob;f=agent/keyformat.txt;hb=HEAD][keyformat.txt]] the format of S-expressions in private keys. It answers all your
questions about life, about the eternal mysteries and about what should be
frequently mentioned by developers online ... but is not.

**** Issues [[https://dev.gnupg.org][dev.gnupg.org]]

*** Using multiple yubikeys

GnuPG will default to using the most recent key for keysigning operations.

#+begin_quote
So just because the filesize doubles when you update your keyring with the
=rsa4096= subkeys that you forgot doesnt mean that it's signing with both
keys. The filesize is actually larger because GPG defaults to the newest public
subkeys and RSA sucks so the files are larger.
#+end_quote

[[https://blogs.gentoo.org/mgorny/2018/05/12/on-openpgp-gnupg-key-management/][Leave it to the Gentoo guys]] to answer your questions. You can use multiple
yubikeys, but only use one set of subkeys.

*** Packets
+ [[https://www.ietf.org/archive/id/draft-koch-openpgp-2015-rfc4880bis-02.html#name-packet-tags][PGP Packet Tags]] (from IETF manual)

Only the session key is included in the gpg message packets. The structure of
the session key is dependent on the encryption algorithm, but it seems these
keys are created per-message.

This command dumps the session key.

#+begin_src sh
gpg -vv --show-session-key --list-packets $gpg_crypted_file
#+end_src

+ The subkey ID will be included unless the =throw-keyid= option is set.

*** Symmetric Encryption

+ [[https://unix.stackexchange.com/questions/560135/how-to-decrypt-file-that-was-symmetrically-encrypted-using-gpg][How to decrypt file that was symmetrically encrypted using GPG?]]
  Particularly, see the answer with the [[https://unix.stackexchange.com/a/662662][batch script]] that uses FD's

*** Private Keys

#+begin_src shell
gpg --list-packets $keyfile

# or
gpg --with-fingerprint --with-colons \
    --keyring $keyfile --list-keys

# or
diff --color=always <(gpg --list-packets $old) <(gpg --list-packets $new) \
    | less -R

# TLDR
gpg -K --list-options show-unusable-subkeys
#+end_src

After creating new subkeys, but before importing to keycard, then copy data to
new =GNUPGHOME=. Collect new shadowed subkeys and combine.

** GPG Agent

See [[https://www.gnupg.org/documentation/manuals/gnupg/Agent-Protocol.html][Agent ASSUAN protocol]] for other things like:

#+begin_example shell
gpg-connect-agent updatestartuptty /bye > /dev/null
#+end_example

Commands need to be enclosed in quotes:

#+begin_example shell
gpg-connect-agent "help getinfo"
#+end_example

Getting a REPL with =gpg-connect-agent= allows =help [cmd]=

And, =/if= you want GPG problems at scale, =/then= you can write scripts. I'm
just curious about questions that are hard to see, like SSH =ControlMaster=.

Getting leads on the above was actually pretty difficult ([[https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob;f=agent/command.c;h=9481f47c3ec0b19af47a4db96b866e1928292caf;hb=HEAD#l3760][./agent/commands.c]]) I
guess since no one customizes anything and the GUI does most of it for them.

*See /Notes on Configuration/ below* in the section on =gpg-agent.conf=.

** Crypto
+ [[https://developers.redhat.com/blog/2017/10/05/entropy-rhel-based-cloud-instances#][Entropy in RHEL-based cloud instances]]
+ [[https://www.random.org/randomness/][Introduction to Randomness and Random Numbers]]

** GPG Integration
+ [[https://alexschroeder.ch/cgit/ugg/about/][The Using GPG Guide]]
+ [[https://git.vdm.dev/knowledge/YubiKey-Guide][VDM Yubikey-Guide]]
+ [[https://github.com/drduh/YubiKey-Guide][drduh/YubiKey-Guide]]

*** Scute: PCKS#11 with =gpg-agent=
+ [[https://www.gnupg.org/documentation/manuals/scute.pdf][Scute manual]]

*** OpenSC: SCDaemon Alternative

[[https://github.com/alonbl/gnupg-pkcs11-scd][alonbl/gnupg-pkcs11-scd]] (link via [[https://docs.digicert.com/en/software-trust-manager/code-signing/sign-with-third-party-signing-tools/gpg-signing/install-gpg-tools/gnupg-pkcs11-scd.html][DigiCert Software Trust Manager (docs)]] which
has their own proprietary alternative to this)

+ example configuration in [[https://github.com/OpenSC/OpenSC/wiki/GnuPG-and-OpenSC][OpenSC/OpenSC/wiki/GnuPG-and-OpenSC]]
  - this uses OpenSC instead of SCDaemon
+ Wiki pages: [[https://github.com/OpenSC/OpenSC/wiki/Using-OpenSC][Using OpenSC]], [[https://github.com/OpenSC/OpenSC/wiki/Using-OpenSC][Overview]]


*** Kleopatra

+ [[https://www.reddit.com/r/yubikey/comments/p1zvac/signature_public_key_not_found_locally/][Signature Public Key not found locally]] for me, it's my encryption
  key. Everything seems normal in =gpg --card-status= and =gpg-card=. However,
  =gpg -d= always iterates through subkeys when it decrypts, which i suspect
  may be the issue.

*** Emacs
+ [[https://www.gnu.org/software/emacs/manual/html_mono/auth.html][auth-source]]

Emacs Wiki ([[https://www.emacswiki.org/emacs/Using_GPG][GPG topic]])

+ [[https://www.emacswiki.org/emacs/Gmail%2c_Gnus_and_GPG][Gmail, Gnus and GPG]]
+ [[https://www.emacswiki.org/emacs/GnuPG][Gnu PG]]
+ [[https://www.emacswiki.org/emacs/AutoEncryption][Auto Encryption]]

Mastering Emacs

+ [[https://www.masteringemacs.org/article/keeping-secrets-in-emacs-gnupg-auth-sources][Keeping Secrets in Emacs with GnuPG and Auth Sources]]

*** Forwarding
+ [[https://rabbithole.wwwdotorg.org/2021/03/03/gpg-agent-fwding-over-ssh.html][GPG Agent Forwarding via SSH]]

*** Thunderbird
+ [[https://support.mozilla.org/en-US/kb/openpgp-thunderbird-howto-and-faq][OpenPGP in Thunderbird: How To and FAQ]]
+ [[https://wiki.mozilla.org/Thunderbird:OpenPGP:Smartcards][Thunderbird, OpenPGP and Smartcards]]

*** KDE
+ [[https://ebzzry.com/en/gsk/][Setting up GPG and SSH in KDE]]

*** Scripting
+ The s/o answers for [[https://unix.stackexchange.com/questions/60213/gpg-asks-for-password-even-with-passphrase][gpg asks for password even with --passphrase]] describe
  using =--batch --passphrase-fd= to get a passphrase from a file descriptor
  =<(pass --command)=

** FIDO2/WebAuthn

They never tell you it's FIDO2 only, FIDO1 doesn't work. This will frustrate
the average person to no end.

About 2 years ago, I had to refer to webauthn docs to get the answer to this
after looking at the console. I usually just assume that it won't enroll
because FIDO1. It needs a proper error message, esp on enrollment. It's
happened a few times, but I was ambivalent about it with my school. They
upgraded to FIDO2 though this year. I figured that it was a matter of time.

The average person already need to be told to have a backup key. This is 2x
FIDO keys. The average person doesn't 2x PIV/OpenPGP but these should be
separate from casual MFA. It's easier to be prepared for losing the key than
to deal with fallout. This would be an appreciably simple way to be secure
that's easier for older people than typical MFA. However, most people already
have "security fatigue" ... if it's not easy to understand why FIDO doesn't
work, then what would otherwise a simpler way for everyone instead becomes
frustrating.

However, I have two different keys and no USB3 ports within arm's reach. I
would prefer FIDO2 across the board, but I guess i'll have to wait.

** Smartcard Integration

*** [[https://pcsclite.apdu.fr/][PCSCD]]

Arch: [[https://gitlab.archlinux.org/archlinux/packaging/packages/pcsclite/-/blob/main/PKGBUILD][pcsclite-1.9.9]]

+ now 2.0.0, which has significant changes

Guix: pcsclite (1.9.8)

+ Related updates have been delivered, so 2.0.0 may be available soon

**** Debugging

+ pcsc-tools includes =pcsc-spy=, but requires configuring IPC to redirect sockets.
+ [[https://ccid.apdu.fr/#CCID_compliant][Check Reader's Compliance to CCID speciication]] (linked from [[https://github.com/LudovicRousseau/PCSC/issues/157][pcscd-lite#157]],
  which is similar to the issue I'm having on Guix)

*** Yubikey Manager

+ Depends on and [[https://pyscard.sourceforge.io/user-guide.html#pyscard-user-guide][pyscard]] (and pscsd). ykman 5..0.0 requires pyscard >= 2.0.


* Topics
* Issues

* Old Dotfiles
:PROPERTIES:
:header-args+:            :tangle-mode (identity #o400) :mkdirp yes
:header-args:conf+:       :tangle-mode (identity #o400) :mkdirp yes
:header-args:sh+:         :tangle-mode (identity #o500) :mkdirp yes
:header-args:bash+:       :tangle-mode (identity #o500) :mkdirp yes
:header-args:scheme+:     :tangle-mode (identity #o700) :mkdirp yes
:header-args:emacs-lisp+: :tangle-mode (identity #o600) :mkdirp yes
:END:

The content from resources (links, etc) is above. That's mainly what you should
refer to. This is all adhoc and has some bad patterns. This file probably
doesn't tangle anymore.

** GPG Environment

The table approach in [[file:ANSIBLE.org][ANSIBLE.org]] is a bit confusing. This is more verbose, yet
more direct. It involves less metaprogramming.

#+begin_src emacs-lisp :eval no :tangle no
(setenv "SECRETS_HOME" ".gnupg.test")
#+end_src

#+name: secretshome
#+begin_src emacs-lisp
(or (getenv "SECRETS_HOME") ".")
#+end_src

*** GPG TTY

For the programs that need to have GPG access, I will configure things like
=GPG_TTY= in the startup script or in the flatpak overrides. I really just don't
trust X11, not that Wayland is much better since it invites an XWayland
dependency for everything.

*** Pinentry

#+name: gpgpinentry
#+begin_src emacs-lisp :tangle no
"pinentry-curses"
#+end_src

#+RESULTS: gpgpinentry
: pinentry-curses

*** Personal Keys

Change these to the fingerprints of your personal keys

#+name: gpgmaster
#+begin_src sh
"0x9FCE9B3064CED760"
#+end_src

#+RESULTS: gpgmaster
: 9FCE9B3064CED760

#+name: gpgsign
#+begin_src sh
"0xB5E0535B23DD6A7A"
#+end_src

#+RESULTS: gpgsign
: B5E0535B23DD6A7A

#+name: gpgcrypt
#+begin_src sh
"0x5AA3269777368E0F"
#+end_src

#+RESULTS: gpgcrypt
: 5AA3269777368E0F

#+name: gpgauth
#+begin_src sh
"0xFC275EE2A3547885"
#+end_src

#+RESULTS: gpgauth
: FC275EE2A3547885

#+begin_src sh :noweb-ref gpgring :noweb yes :noweb-sep ""
export PINENTRY=<<gpgpinentry>>
export GPGMASTER=<<gpgmaster>>
export GPGSIGN=<<gpgsign>>
export GPGCRYPT=<<gpgcrypt>>
export GPGAUTH=<<gpgauth>>
#+end_src

#+RESULTS:

*** Guix Profile

The Guix profile will need to be installed. Unless =GNUPG_PATH= is set when
=init-gpg.sh= is sourced, then the profile is expected to be installed to
=$GUIX_EXTRA/gpgagent/gpgagent=

It makes more sense to do this in a manifest than to add a custom package to a
guix channel. Thankfully the guix transformations are very flexible. See =guix
shell --help-transform= for more information.

#+begin_src scheme :tangle (concat (or (getenv "SECRETS_HOME") ".") "/.config/guix/manifests/gpgagent.scm")
(use-modules (guix packages)
             (guix transformations)
             (guix download)
             (guix git-download)
             (gnu packages base)
             (gnu packages guile)
             (gnu packages gnupg)

             (gnu packages autotools)
             (gnu packages pkg-config)

             (ellipsis packages password-utils))

;; needs to build from master to set alternate config/db
(define shroud-master
  (options->transformation
   '((with-branch . "shroud=master"))))

(packages->manifest
 (list gnupg
       pinentry-tty
       pinentry-gtk-2
       shroud-nox))
#+end_src

The =shroud-nox= package is in another module, so use =-L= when invoking guix
commands.

*** Portable GPG

Honestly, using =guix pack= to create a portable guix profile wasn't beneficial
enough to offset the complexity.  A portible profile is arguably more useful for
Ansible -- especially for hackers operating behind enemy lines, lol -- so I
moved any notes to [[file:ANSIBLE.org::*Guix Profile][ANSIBLE.org.]]

#+begin_quote
Firewalling SSH? oh noes: on what port?

lol i hope you have deep-packet inspection.
#+end_quote
** Init Script

#+begin_src sh :tangle (concat (or (getenv "SECRETS_HOME") ".") "/.gnupg/init-gpg.sh") :shebang "#!/bin/sh" :tangle-mode (identity #o500) :noweb yes
<<gpgring>>
#+end_src

If =SECRETS_HOME= is not set, it's set to =$(pwd)=. Do this before sourcing
=init-gpg.sh=. Another option is to link =$HOME/.gnupg= to
=$SECRETS_HOME/.gnupg= and then you can source the script in a fresh shell.

#+begin_src sh :tangle (concat (or (getenv "SECRETS_HOME") ".") "/.gnupg/init-gpg.sh") :tangle-mode (identity #o500)
if [ -z $SECRETS_HOME ];then
    export SECRETS_HOME="$(pwd)"
    echo "SECRETS_HOME=$SECRETS_HOME"
fi

# if not using on a system where $GNUPGHOME == $SECRETS_HOME/.gnupg
# then make it so before sourcing the script
if [ -z $GNUPGHOME ];then
    export GNUPGHOME=$HOME/.gnupg
    echo "GNUPGHOME=$GNUPGHOME"
fi
export PATH=$SECRETS_HOME/bin:$PATH

# unless there is a specific $GNUPG_PATH, use a guix profile
if [ -z $GNUPG_PATH ];then
    # then load GnuPG profile
    GUIX_EXTRA=$HOME/.guix-extra-profiles
    GUIX_PROFILE=$GUIX_GNUPG_PROFILE
    if [ -z $GUIX_PROFILE ];then
        GUIX_PROFILE=$GUIX_EXTRA/gpgagent/gpgagent
    fi
    source $GUIX_PROFILE/etc/profile
    GNUPG_PATH=$GUIX_PROFILE/bin
fi

# GPG Agent
# see below for startup scripts

# SSH Agent
# should be disabled

# Shroud Database
export SHROUD_CONFIG_FILE=$SECRETS_HOME/.shroud
export SHROUD_DATABASE_FILE=$SECRETS_HOME/.config/shroud/db.gpg
#+end_src

*** SSH Agent (via GPG)

**** Notes

+ The list of approved keys is stored in =~/.gnupg/sshcontrol=

+ If you use a PGP key for SSH auth (requires =Authentication= capability)
  - check for the key (when s/card is loaded) by listing keys or
    checking fingerprints: =ssh-add -l/L=
  - if the GPG is not on a s/card, then add the keygrip to =~/.gpg/sshcontrol=

This would cause GnuPG daemon's =GPG_TTY= variable to be updated on
every SSH command invocation: but allows you to enter the pin from the
same terminal you are ssh-connecting through. 

#+begin_src conf
Match host * exec "gpg-connect-agent UPDATESTARTUPTTY /bye"
#+end_src

*** GPG Agent

**** Start


To start GPG Agent, source the above =init-gpg.sh= script, then run =start-gpg=
or =start-gpg-connect=. My notes say to prefer starting =gpg-agent= via
=gpg-conf= but I honestly can't remember why.

***** With =gpg-connect-agent=

#+begin_src sh :tangle (concat (or (getenv "SECRETS_HOME") ".") "/bin/start-gpg-connect") :shebang "#!/bin/sh" :tangle-mode (identity #o500)
# The TTY should be set by the caller
# export GPG_TTY="$(tty)"
unset SSH_AGENT_PID
export SSH_AUTH_SOCK="/run/user/$UID/gnupg/S.gpg-agent.ssh"
gpg-connect-agent update-startuptty /bye > /dev/null
#+end_src

***** With =gpgconf=

Prefer to start with =gpgconf=

#+begin_src sh :tangle (concat (or (getenv "SECRETS_HOME") ".") "/bin/start-gpg") :shebang "#!/bin/sh" :tangle-mode (identity #o500)
# The TTY should be set by the caller
# export GPG_TTY="$(tty)"
unset SSH_AGENT_PID
export SSH_AUTH_SOCK="$(gpgconf --list-dirs agent-ssh-socket)"
gpgconf --launch gpg-agent
#+end_src

***** Without =ssh=

****** TODO init script without ssh

**** Application Integration

For any given appliation, either its launch scripts or the window manager's
shell should have =GPG_TTY= set. Obviously, the whole point of doing things this
way is so applciations in X11 have minimal awareness of GPG -- this is me being
paranoid, but honestly, it's crazy to think that it's done that way. Of course,
smartcards improve the potential for X11 keylogging.

For flatpak apps:

+ Link =$HOME/.gnupg= to =$SECRETS_HOME/.gnupg=
+ Run =flatpak --env=GPG_TTY=/dev/ttyX org.mozilla.Thunderbird=. This can also
  be included in a script, called after =GPG_TTY= has been established for the
  =gpg-agent=.

#+begin_src sh :tangle (concat (or (getenv "SECRETS_HOME") ".") "/bin/flatpak-gpg-overrides") :shebang "#!/bin/sh" :tangle-mode (identity #o500)
flatpak --user override --env=GPG_TTY=$(tty) org.mozilla.Thunderbird
#+end_src

This apparently works alright, though I needed to paste in the public key to
circumvent the flatpak restrictions on file access.

[[./img/thunderbird-signed.jpg]]

*** Shell Examples

Cut the keys out of the =gpg -k= output.

#+begin_example shell
gpg -k | grep -e "^sub" | cut -b 16-33
#+end_example

Get the environment variables that =gpg= passes to =gpg-agent=. These are the
only variables permitted in =gpg-agent.conf=.

#+begin_src sh :tangle (concat (or (getenv "SECRETS_HOME") ".") "/bin/gpg-agent-env-vars") :shebang "#!/bin/sh" :tangle-mode (identity #o500)
gpg-connect-agent 'getinfo std_env_names' /bye | awk '$1=="D" {print $2}'
#+end_src

Dump the =gpg-agent= environment (throws errors when env vars have no value):

#+begin_src sh :tangle (concat (or (getenv "SECRETS_HOME") ".") "/bin/gpg-agent-env") :shebang "#!/bin/sh" :tangle-mode (identity #o500)
gpg-agent-env-vars |\
    tr -dc '[:alnum:]\n' |\
    xargs -I '___' gpg-connect-agent "getinfo getenv ___" /bye
#+end_src

Troubleshoot =gpg-agent=

#+begin_src sh :tangle (concat (or (getenv "SECRETS_HOME") ".") "/bin/start-gpg-debug") :shebang "#!/bin/sh" :tangle-mode (identity #o500)
# run with --log-file to log
# The TTY should be set by the caller
# export GPG_TTY="$(tty)"
unset SSH_AGENT_PID
export SSH_AUTH_SOCK="$(gpgconf --list-dirs agent-ssh-socket)"
gpg-agent --daemon --no-detach -v -v --debug-level advanced $@
#+end_src

Troubleshoot =gpg-agent= with:

+ =--debug-pinentry=
+ =--debug 1024= which is required

#+begin_src sh :tangle (concat (or (getenv "SECRETS_HOME") ".") "/bin/start-gpg-debug-pinentry") :shebang "#!/bin/sh" :tangle-mode (identity #o500)
# run with --log-file to log
# The TTY should be set by the caller
# export GPG_TTY="$(tty)"
unset SSH_AGENT_PID
export SSH_AUTH_SOCK="$(gpgconf --list-dirs agent-ssh-socket)"
gpg-agent --daemon --no-detach -v -v --debug-pinentry --debug 1024 $@
#+end_src

** GPG

*** GPG Config

**** Defaults

#+begin_src conf :tangle (concat (or (getenv "SECRETS_HOME") ".") "/.gnupg/gpg.conf.defaults")
# Use AES256, 192, or 128 as cipher
personal-cipher-preferences AES256 AES192 AES

# Use SHA512, 384, or 256 as digest
personal-digest-preferences SHA512 SHA384 SHA256

# Use ZLIB, BZIP2, ZIP, or no compression
personal-compress-preferences ZLIB BZIP2 ZIP Uncompressed

# Default preferences for new keys
default-preference-list SHA512 SHA384 SHA256 AES256 AES192 AES ZLIB BZIP2 ZIP Uncompressed

# SHA512 as digest to sign keys
cert-digest-algo SHA512

# SHA512 as digest for symmetric ops
s2k-digest-algo SHA512

# AES256 as cipher for symmetric ops
s2k-cipher-algo AES256

# UTF-8 support for compatibility
charset utf-8

# Show Unix timestamps
fixed-list-mode

# No comments in signature
no-comments

# No version in output
no-emit-version

# Disable banner
no-greeting

# Long hexidecimal key format
keyid-format 0xlong

# Display UID validity
list-options show-uid-validity
verify-options show-uid-validity

# Display all keys and their fingerprints
with-fingerprint

# Display key origins and updates
#with-key-origin

# Cross-certify subkeys are present and valid
require-cross-certification

# Disable caching of passphrase for symmetrical ops
no-symkey-cache

# Enable smartcard
use-agent

# Disable recipient key ID in messages
throw-keyids

# Default/trusted key ID to use (helpful with throw-keyids)
#default-key 0xFF3E7D88647EBCDB
#trusted-key 0xFF3E7D88647EBCDB

# Group recipient keys (preferred ID last)
#group keygroup = 0xFF00000000000001 0xFF00000000000002 0xFF3E7D88647EBCDB

# Keyserver URL
#keyserver hkps://keys.openpgp.org
#keyserver hkps://keyserver.ubuntu.com:443
#keyserver hkps://hkps.pool.sks-keyservers.net
#keyserver hkps://pgp.ocf.berkeley.edu

# Proxy to use for keyservers
#keyserver-options http-proxy=http://127.0.0.1:8118
#keyserver-options http-proxy=socks5-hostname://127.0.0.1:9050

# Verbose output
#verbose

# Show expired subkeys
#list-options show-unusable-subkeys
#+end_src

*** Agent Config

I would strongly recommend avoiding =pinentry-tty= or =pinentry-curses= where
possible. That such friction would occur was obvious, but I thought I understood
more about how things interacted, like =ttyname= and =$(tty)=, such that it
would work as expected.

AFAIK (now), the input redirection (and "grabbing") is sufficient on
pinentry to hopefully avoid keyloggers. This might be the point of the
=pinentry= program entirely... and perhaps uses the assuan protocol for IPC in
additon to a few other pieces to accomplish such.

**** Defaults

#+begin_src conf :tangle (concat (or (getenv "SECRETS_HOME") ".") "/.gnupg/gpg-agent.conf.defaults")
# https://github.com/drduh/config/blob/master/gpg-agent.conf
# https://www.gnupg.org/documentation/manuals/gnupg/Agent-Options.html
enable-ssh-support
allow-preset-passphrase

# force the agent to keep its tty/display while running
# this should be used if pinentry is running in a window manager.
keep-display

# The latter option is more restrictive
ttyname $GPG_TTY
keep-tty

# do NOT use any external passphrase cache
no-allow-external-cache

# do not mark allow clients Root-CA keys as trusted
# (manually change this when accepting new keys; doesn't affect pacman)
no-allow-mark-trusted

# grab/nograb (used on X-servers to avoid X-sniffing attacks)

# Yubikey PIN is cached by the yubikey itself
# - these options don't affect it. you must unplug the key.
default-cache-ttl 60
max-cache-ttl 120

# pinentry-program must be set or gpg-agent expects an X11 compatible one

#pinentry-program /usr/bin/pinentry-tty
#pinentry-program /usr/bin/pinentry-curses

pinentry-program /usr/bin/pinentry
#pinentry-program /usr/bin/pinentry-gtk-2
#pinentry-program /usr/bin/pinentry-x11
#pinentry-program /usr/bin/pinentry-qt
#pinentry-program /usr/local/bin/pinentry-curses
#pinentry-program /usr/local/bin/pinentry-mac
#pinentry-program /opt/homebrew/bin/pinentry-mac
#+end_src

***** On Arch

The systemd user service =gpg-agent.service= has associated =*.socket=
objects. When a user requests a gpg operation, everything should start up as
expected.

+ If this is the intended behavior, the =init-gpg.sh= script should not be
  sourced, as modifies the path to launch Guix gpg.
+ There are potentially compatibility issues between Guix gpg and arch bins/libs
  for =pcscd=, =scdaemon= or =ccid=. The binaries for these should be used as a
  set, esp. given that some package managers will bundle custom or upstream
  patches for =gnupg= packages. I didn't encounter a confirmation of such, but I
  would rather not figure that out months down the road.

****** Determining how gpg/pinentry are being launched

For me, this time, I had moved the yubikey to another USB slot and for some
reason, restarting the agent (which spawns scdaemon) was giving me this:

#+begin_quote
Aug 27 04:34:10 kratos gpg-agent[3816814]: listening on: std=3 extra=6 browser=4 ssh=5
Aug 27 04:34:42 kratos gpg-agent[3818770]: scdaemon[3818770]: detected reader 'Yubico YubiKey OTP+FIDO+CCID 00 00'
Aug 27 04:34:42 kratos gpg-agent[3818770]: scdaemon[3818770]: pcsc_connect failed: sharing violation (0x8010000b)
#+end_quote

I couldn't tell whether the =pinentry= in the config was actually what was
spawning. =gpg-connect-agent= is actually a bit mum on config details, but
check [[https://www.gnupg.org/documentation/manuals/gnupg/GPGSM-Protocol.html#GPGSM-Protocol][ยง5.6 on Server Protocol]] for details.

Check for the =gpg= agent, =pinentry.*= and =scdaemon= processes. If it's got
these, then any command passing through the gpg socket that should expect a
smartcard pin will hang. It may be asking for the pin on another TTY.

After checking for the processes, get a call to =git -T git@github.com= to
hang for pin input. Then, depending on the pinentry process, you can start to
infer what kind of issue it is.

#+begin_src sh
# the pgrep should return a single result
pstree -H "$(pgrep pinentry)"
#+end_src

Or just check =journalctl --user -xb= for info.

Judging by the size of the binary, =/usr/bin/pinentry= on arch does something
else. There's barely enough to pack ELF headers into

#+begin_quote
-rwxr-xr-x 1 root root    369 Aug 29  2022 /usr/bin/pinentry
-rwxr-xr-x 1 root root  63864 Aug 29  2022 /usr/bin/pinentry-curses
-rwxr-xr-x 1 root root  51576 Aug 29  2022 /usr/bin/pinentry-emacs
-rwxr-xr-x 1 root root  76128 Aug 29  2022 /usr/bin/pinentry-gnome3
-rwxr-xr-x 1 root root  84320 Aug 29  2022 /usr/bin/pinentry-gtk-2
-rwxr-xr-x 1 root root 182816 Aug 29  2022 /usr/bin/pinentry-qt
-rwxr-xr-x 1 root root  55672 Aug 29  2022 /usr/bin/pinentry-tty
#+end_quote

......... oh ok, it's a shell. I really just want to make sure the config
options i have set are actually being applied.

**** Notes on Configuration

***** Notifications

****** log-file

This can be used for =notify-send=

******* TODO configure notify-send to show interesting events

e.g. failed pinentry attempts

After all, my dotfiles are online. I'm practically asking for it. I'm putting a
lot of trust into this tool and it solves a lot of problems for me. Between GPG
Agent for SSH and the Yubikey, it's aspirin for my paranoia -- which can
otherwise be useful if I don't waste my time/energy.

***** Pinentry

****** allow-pinentry-notify

Configuring =gpg-agent= with =allow-pinentry-notify= will include requests to
authenticate in the output, if it is logged.

I'm not sure whether it's a good idea, but something like [[https://github.com/ryran/tail2notify/blob/master/tail2notify][ryran/tail2notify]] can
monitor the =gpg-agent= output for requests to auth (and potentially
failures). Naturally, this would require that the GPG agent is aware of the
=DISPLAY=.

Commits:

+ GnuPG: [[https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=commitdiff;h=7052a0d77cf8f3a445b252a809d29be445788625][gpg: More diagnostics for a launched pinentry]]
+ Pinentry: [[https://git.gnupg.org/cgi-bin/gitweb.cgi?p=pinentry.git;a=commitdiff;h=02a4f2fa0d8c8a63e72b9b9924b2817bfacce09a][core: Allow to query info about the emacn integration]]

Resources

+ [[https://superuser.com/questions/1744237/gpg-notify-before-password-prompt-in-terminal][GPG Notify before password prompt in terminal]]

****** keep-tty and keep-display

Use =keep-display= and =keep-tty= to prevent the agent from being accessed from
another shell/display.


*** SCDaemon Config

The daemon is failing when =pcscd= and =scdaemon= already have a connection to
the Yubikey for the PIV/SSH application. (TODO: verify that this is the problem)

The =shared-access= option is dangerous according to the =scdaemon= manpages,
since the process caches information from the card.

#+begin_src conf :tangle (concat (or (getenv "SECRETS_HOME") ".") "/.gnupg/scdaemon.conf.defaults")
reader-port Yubico Yubi
#+end_src

**** Shared Access with PCSCD

#+begin_example conf
reader-port Yubico Yubi
disable-ccid

# not libpcsc D lite.so.1 ... results in "error in libcrypto"
pcsc-driver /usr/lib/libpcsclite.so.1

# the gnupg manual seems to warn against this. it's not working for me though
# this could be from how scdaemon starts/stops, though it definite stops when i
# kill gpg-agent
# pcsc-shared

# shared-access # this is an older option for scdaemon, not in 2.2.41
#+end_example

*** SSH Control

Running =ssh-add= while GPG is running as an =ssh-agent= will:

- Prompt for the ssh key passphrase, decrypt it, and test for vaildity.
- Ask for a new passphrase. You could simply use the same passphrase ... but you
  do need one.
- The SSH key's keygrip is added into the =$GNUPGHOME/sshcontrol= file.
- It then stores the SSH key into the GPG private key format into
  =$GNUPGHOME=.

Without a passphrase, it's essentially unprotected as a string of octal
characters. It was pretty difficult to find a definitive answer on this.  People
will tell you to enter one, but I was kinda hoping it would be encrypted by the
GPG auth or encryption subkey.

The  [[https://git.gnupg.org/cgi-bin/gitweb.cgi?p=gnupg.git;a=blob;f=agent/keyformat.txt;hb=HEAD][keyformat]] is described here.

Also, the =sshcontrol= file can be edited to add a priority to SSH keys, so when
SSH's post-modern interpretation of your =ssh_config= ignores things like
=IdentitiesOnly=, you may not be able to prevent it from doing that, but you can
make it try your keys in a specific order ...

*** Managing SSH Key Passphrases

Anything that can send =stdout= to some command's =stdin= can be used to
retrieve passphrases without creating shell history, which is about as
sufficient as I can imagine at this level...

... nevermind, you need to use =<<<= or =<<HEREDOC= to avoid echoing the
passphrase in the process list, according to [[https://unix.stackexchange.com/questions/317298/what-are-the-steps-needed-to-cache-passphrases-entered-via-pinentry-using-gpg-pr][this s/o]]

Shroud is configured below for this purpose.

**** Testing SSH Keys

#+begin_src

#+end_src

*** Interacting with Yubikey PIV module from =gpg-agent=

Oh, and there /IS/ a way to get GPG's =ssh-agent= emulation to interact with the
Yubikey =PIV= application ... so maybe learning all about that wasn't a complete
waste of time?

The =keyformat.txt= file indicates that the =Scute= module will handle this, but
I still need to look into it.

** Shroud

This is a password/secrets management tool. In the =gnupg-agent.scm=
profile, =shroud-nox= references a package in [[https://github.com/dcunited001/ellipsis/blob/master/ellipsis/packages/password-utils.scm][dcunited001/ellipsis]],
which is not [yet?] a channel.

For this kind of secrets management, shroud is a good choice:

+ Minimal dependencies: guile scheme, gpg
+ GPG integration: and this means smartcard integration.
+ In memory: GPG means the secrets are pulled into RAM and then gone.

Alternatives considered:

+ tomb :: This is a nice one, but requires zsh. I don't fully trust
  zsh and would prefer to avoid the dependency.
+ pwsafe :: I couldn't find a Guix package without X11/GTK
  dependencies. There are several packages, but it's a bit confusing.
+ file-system-based tools :: LUKS is secure ... until you mount
  it. Other tools like truecrypt/veracrypt/fscrypt are similar. I
  don't want to have to trust even my own user. If it is mounted as a
  file-system, then other processes can impersonate my user and access
  the data.
  - with GPG-based tools, if my yubikey is required, then it is much
    more difficult for processes to impersonate authorization.

*** Config

The environment variables configured in =init-gpg.sh= require the master branch
of shroud. The defaults are below:

+ SHROUD_CONFIG_FILE :: ~/.shroud
+ SHROUD_DB_HOME :: ~/.config/shroud/db.gpg

 Write the list of identities to =.shroud=

#+begin_src scheme :tangle (concat (or (getenv "SECRETS_HOME") ".") "/.shroud.defaults")
'((user-id . "myemail@fdsa.com"))
#+end_src

The keys are stored in a fairly plain scheme dictionary. It can be opened in
vanilla emacs and edited as plain text, so long as emacs knows out to reach its
=gpg-agent= socket.

Password files cannot easily be diffed. Since this is a plain dictionary and you
have a reasonable programming language, then it's significantly easier to merge
changes from multiple copies of password files on various hosts ... without the
cloud.

#+begin_example scheme
(((id . "id3nt") (contents ("asdf" . "asdf")
                           ("abcd" . "asdf")
                           ("fdsa" . "jhkl"))))
#+end_example

You can add keys and values from the command line:

#+begin_example shell
shroud hide $identity $key=$value
#+end_example

And you can retrieve multiple keys from the dictionary. If they don't exist,
nothing is returned.

#+begin_src sh
shroud show $identity # to show them all
shroud show $identity | cut -f1 # to cut all the
shroud show $identity "ssh123" # to select the passphrase
#+end_src

To pipe them into SSH or GPG operations, you may need to use file descriptors
depending on how the commands handle =stdout= or =stdin=

#+begin_src
shroud show $identity "ssh123" | gpg
#+end_src

References to these file descriptors can be stored in Bash, but if they are more
than ephemeral ... something somewhere may also have permissions to read from
them, so prefer anonymous FD's.

*** Storing passphrases

Get the fingerprint with

#+begin_src sh :eval no
pubkey=~/.ssh/key.pub
pubkey_fpr="$(ssh-keygen -lf $pubkey -E sha256 | cut -f2 -d' ')"
identity=me@me.com
#+end_src

Store the passphrase with =read -r=

#+begin_src sh :eval no
read -r passphrase
shroud hide $identity $pubkey_fpr=$passphrase
#+end_src

Or store a random passphrase:

#+begin_src sh :eval no
pplength=12
shroud hide $identity $pubkey_fpr=$(gpg --gen-random --armor 0 16 | cut -b$pplength)
#+end_src

It's also totally possible to just edit the file in emacs using =C-u C-M-!= to
insert the output off commands.

Add to GPG with:

#+begin_src sh :eval no
# ok ssh-add only accepts passwords from the program set as the SSH_ASKPASS variable
# but this does not work when managed by gpg-agent
#+end_src

Unlock in GPG with:

#+begin_src

#+end_src

**** Select keygrip from GPG

#+begin_src sh
keyfile=~/.ssh/key
pubfile=$keyfile.pub
keysha=$(ssh-keygen -E sha256 -lf $pubfile | cut -f2 -d' ')
keygrip=$(gpg-connect-agent "KEYINFO --ssh-list --ssh-fpr=sha256" /bye | \
              head -n-1 | grep $keysha | cut -f3 -d' ')
#+end_src

**** Preset Passphrase in GPG

Here's what =preset_passphrase= does:

#+begin_src sh :output verbatim
gpg-connect-agent "help preset_passphrase" /bye | head -n-1
#+end_src

#+RESULTS:
: # PRESET_PASSPHRASE [--inquire] <string_or_keygrip> <timeout> [<hexstring>]
: #
: # Set the cached passphrase/PIN for the key identified by the keygrip
: # to passwd for the given time, where -1 means infinite and 0 means
: # the default (currently only a timeout of -1 is allowed, which means
: # to never expire it).  If passwd is not provided, ask for it via the
: # pinentry module unless --inquire is passed in which case the passphrase
: # is retrieved from the client via a server inquire.

I think the =gpg-preset-passphrase= tool is required for this to work, but the
executable is missing for me on both arch & guix.

#+begin_src sh :eval no

#+end_src

Otherwise, this should work, but is still returning =Err 67108933 not implemented <GPG Agent>=:

#+begin_src sh :eval no
# get $keygrip
shroudpass=$(shroud show $identity $keysha)
gpg-connect-agent "preset_passphrase $keygrip 0 $shroudpass" /bye
#+end_src

**** To Delete SSH Keys from GPG

Find the SSH key:

#+begin_src sh :eval no
# get $keygrip
gpg-connect-agent "DELETE_KEY $keygrip" /bye

# or rm ~/.gnupg/private-keys-v1.d/$keygrip.key
#+end_src

** Pass

*** Advantages

Beyond the KISS and ecosystem, there are a few process-related advantages to
pass:

**** Pass is designed around the filesystem

This mirrors the tree of groups. Working with multiple formats will require
tree traversal ... so Bash is helpful, though Python is recommended.

**** Pass is helpful as a unit of exchange

When converting between one password format and another. As long as there is a
CLI for a password manager that will output passwords metadata to =STDOUT= or
reads them via =readline=, then you can migrate from it.

**** Writing to the pass format doesn't require secrets

This means you can read from your =pwsafe= or =1password= and write to the
pass format with the public key.

+ Then when you send data over the network, you just need to expect to have
  secrets available there -- i.e. you won't need specific software on that
  system & you don't need to worry about ports/DNS unblocked/monitored. You
  will likely need a GnuPG keyring available on that system to access the
  public key (see [[https://lists.gnupg.org/pipermail/gnupg-users/2010-March/038555.html][this]]).
+ If public keys are a problem, you can use a =GNUPGHOME= within =/tmp= or
  something. Or =pass-age= may work better here, since there's less metadata
  assoc with the keys.

If you don't have the =pass= binary available, it's just the file system, so
something like =MUH_SECRET=$(gpg -d $muh_file | head -n1)= works

**** Pass works well for a single user

The file-based nature of pass means the git diffs can help you understand
which secrets have changed.

+ Except for the file-system metadata which exposes a bit of info about how
  you organize secrets, then info about usernames/etc isn't exposed.
+ As long as you have =throw-keyids= set when you write secrets, then it's
  impossible to what public keys encrypted the files (though it will slow you
  down a bit).

**** You can store secrets in Git without a Forge

Using some of the Remote URL's available to =git=, you don't necessarily need
to merge your updates to secrets into a Git Forge (see [[https://git-scm.com/book/en/v2/Git-on-the-Server-The-Protocols][Git Protocols]])

+ You should identitfy which remote available to your git checkouts is the
  most authoritative: a "source of truthiness." You will likely need SSH
  public keys set up on the machines you're moving to though.
+ Unlike most git workflows, however, this is a decentralized workflow. Still,
  each checkout should have a =master= branch and (because the commits involve
  opaque whole-file encrypted data) then your work should occur on a branch
  other than master. For other small branches where the =pull.rerere= works,
  then you can usually work on a single branch, but there's no easy way for
  merge/rebase conflicts to be resolved via diff content here.

**** The Memory Footprint of Secrets Read Via Pass Is Easier to Manage

When the processes that have read GPG secrets are terminated, then things like
an open =dbus= can't really expose you, though an unterminated =gpg-agent= or
open socket may.

+ When you read secrets into environment variables, then they may be exported
  to child processes or even available in the =ps= output (or the =/proc=
  equivalent). The =docker= and =docker-compose= means of using =.env= files
  is probably safe (from the aforementioned mechanisms of secrets extraction),
  but that process has been standardized ... it involves quite a bit of
  tooling where code quality has many eyeballs.
+ However, AFAIK, using the =<(process substitution)= creates FD's that expire
  quickly, provided that the reading process can determine that the FD is no
  longer needed for that process. This assertion depends on whether the kernel
  can tell that a process has no remaining links to file descriptors -- and if
  so, again, code quality ... since likely the process would need to say "hey
  kernel, i'm done with this". Maybe NodeJS binaries with sensible handling
  for FD's will do this, but most do not support procsub. Microsoft is a fan.

So TL;DR; the processes you want to have read the secret will have it in
memory.  When those processes end, the memory can no longer be accessed.

*** Emacs

These packages seem minimalistic & helpful:

+ [[password-store.el]] in the same git repo as =password-store= itself.
+ auth-source-pass
+ [[https://github.com/NicolasPetton/pass/tree/master][NicolasPetton/pass]] this provides =pass-view-mode= which helps manage the
  secrets in Emacs, though you likely want this functionality enabled on an
  as-needed basis.

*** Migration

**** TODO From pwSafe

Describe migrating via Loxodo

** Emacs

*** Loading the profile

Either Link =~/.emacs.d= to =$SECRETS_HOME= or, using chemacs, run:

#+begin_src sh :eval no
emacs --with-profile '((user-emacs-directory . (getenv "SECRETS_HOME")))'
#+end_src

*** Guix packages:

***** TODO setup a portable emacs profile

Which will be of limited utility if: any bin tools or path deps don't work/interact properly on the system

*** Babel

The essentials

#+begin_src emacs-lisp :tangle (concat (or (getenv "SECRETS_HOME") ".") "/.emacs.d/init.el")
(setq org-directory "~/org"
      org-adapt-indentation nil
      org-src-preserve-indentation t)

(defun read-only-when-pgp ()
  (when (and (fboundp #'buffer-file-name)
             (buffer-file-name)
             (string-match "\\.key$" (buffer-file-name)))
    (read-only-mode)))

(add-to-list 'after-change-major-mode-hook #'read-only-when-pgp t)
#+end_src

And if you want lispy to be configured:

#+begin_example emacs-lisp
(when (bound-and-true-p lispy-mode)
  (cl-dolist (hook '(scheme-mode-hook
                     emacs-lisp-mode-hook
                     lisp-data-mode-hook
                     ielm-add))
    (add-hook hook #'lispy-mode)))

(advice-add 'lispy-goto-symbol-elisp :override #'xref-find-definitions '(name "dc/nanon"))
#+end_example

*** Tangling

**** File Ownership/Permissions

I couldn't find options to specify file owner/group when tangling
files. The permissions of these files are critical. GPG/Agent and SSH
will refuse to function if the permissions are not set correctly. When
the permissions are not in =400,600,700=, then the group should
probably be set to =wheel=.

** Entropy

I don't know what I'm doing, so you've been warned lol. It generates keys very
fast though, so I guess it works?

*** Add an entropy source

Use [[Entropy s][Yubikey as entropy source]]. GPG agent should already be running.

Create a new cert in slot 9a (this will replace the existing 9a PIV cert!)

#+begin_src sh :eval no
ykman piv keys generate --algorithm ECCP256 9a pubkey.pem
#+end_src

Run =rngd= in background using Yubikey as =/dev/random= source:

#+begin_src sh :eval no
rngd -x hwrng -x tpm -x rdrand -x jitter -n pkcs11 -b -W 4096 -f
#+end_src

Options:

+ -x :: disables an existing rng source. =rngd -l= to list
+ -n pkcs11 :: specifiy the pkcs11 source
+ -b :: run =rngd= in the background
+ -W 4096 :: specify the intended entropy size
+ -f :: keep running even when full

***** TODO verify whether =-o /tmp/yubirng= as output is required

*** Test with =rngtest=

Compare lines with =FIPS 140-2 successes/failures=. It should be very close to 100%.

#+begin_src sh :eval no
cat /dev/random | rngtest -c 1000
#+end_src


** System Time

When using =usb-gpg-tools= in the [[https://github.com/dcunited001/ellipsis/tree/master/ellipsis/ellipsis][ellipsis channel]], esp. if airgapped, you need
to ensure the system time is correct. If the battery's been empty for long
periods of time, the =LocalRTC= time resets/drifts. This affects the results of
most crypto & signing operations. In the past, i've manually set the time with
=timedatectl=, which seemed to work. Booting a different network-connected Linux
ISO will persist on reboot.

To fix this:

+ use a Linux ISO and connect NTP to update time in the booted Linux.
+ check with =date= and =timedatectl show=
+ when it's correct, use =timedatectl --adjust-system-clock= to be sure (i don't
  think this writes)

** Backups

You should never have an active/connected network device when working with these
file systems. The system should have been booted offline and have remained
offline the entire time. It should never connect to the network before being
reset. Ideally, it should be a system that has no disks other than what is
necessary.

The goal is to get the keys onto the yubikey where they are safe. They can also be generated on the yubikey itself.

*** Digital

Flash storaget is thought to become less reliable with time if its CMOS is not powered (i.e. if you don't plug it in for long periods of time)

**** Test the flash storage with F3

F3 isn't really a comprehensive test, but this will help you preempt problems with counterfeit flash storage. It will mainly tell you if there are bad sectors where =f3brew= wrote data, but could not read it.

=f3brew= will destructively write to the entire disk!

#+begin_src sh :eval no
f3brew /dev/sdX
#+end_src

This will take a long time. It will prompt you to disconnect/reconnect the storage device. At the end, it will tell you, in hex, how much data was written.

**** Provision the flash partitions for RAID -1

Calculate the partition sizes. Check the number of sectors =n=.

#+begin_src sh :eval no
LC_ALL=C fdisk -l /dev/sdX
#+end_src

Take =m = (n/4) % 2048=, since =cfdisk= will round partition sizes down to the nearest multiple of =2048=

Use =cfdisk= to test the partition sizes. You should end up with four. Ensure that the partition sizes, to the sector, are identical.

#+begin_src sh :eval no
cfdisk -z /dev/sdX
#+end_src

Just create the partitions. Use =mkfs.ext2= to format them later.

**** Create a partition and backup the files

Format the first partition with =mkfs.ext2=.

#+begin_src sh :eval no
mkfs.ext2 /dev/sdX1 -L gpg-$(date +%F)
#+end_src

For further data redundancy, you can use btrfs which can totally duplicate its data and metadata. This will reduce the total disk size by +50%.

#+begin_src sh :eval no
mkfs.btrfs -L gpg-$(date +%F) -d dup -m dup
#+end_src

When mounting, you should ensure =readonly= and =noatime= are consistently
applied to prevent unintentional mutation of the data, which will keep the disk copies in sync unless they are intentionally modified.

#+begin_src sh :eval no
cryptsetup luksOpen /dev/sdXn backupn
mount -r -o noatime /dev/mapper/backupn /mnt/backupn -o noatime
#+end_src

**** Duplicate the partitions

View the partitions with =lsblk= and copy the images from =/dev/sdX1= to =/dev/sdX2= and =/dev/sdY1= and so forth.

#+begin_src sh :eval no
# i'm not sure whether bs=1M will affect the block structure of the disk
dd if=/dev/sdX1 of=/dev/sdX2 status=progress
#+end_src

This will not affect the partition labels which exist inside the LUKS volumes.
If you want to mount them with the labels, then change with with =e2label
/dev/sdXn newLabel= while the LUKS volume is open.

**** Close the luks device

Since the partition is not inside an LVM2 volume, you can simply use =dmsetup info= to query the block device mappings to find the name and:

#+begin_src sh :eval no
umount /mnt/backupn
cryptsetup luksClose backupn
#+end_src

Working with multiple identical partitions is a bit tricky, esp. when they do
contain LVM2 volumes. At any point, you should not attempt to mount devices with
the same LUKS block device ID's or PV/LV ID's. Ensure that they are completely
unmounted with =dmsetup info= et alias.

*** Paperkey

Paperkey is included on the image and will export the password-protected GPG
keys to a txt file, which you can print. If unlike me you have more than a 5
digit salary and you print them out, they can be placed in a safety deposit box.

This gives you an option to generate new keys and issue/use revocation certs, in
case the backup is lost.

**** Backup

Export an unarmored copy of the master secret to a secure disk.

#+begin_src sh :eval no
gpg --export-secret-keys $KEYID > $GNUPGHOME/mastersub.unarmored.key
paperkey --secret-key .gnupg/mastersub.unarmored.key --output mastersub.paperkey.txt
#+end_src

Print it and then clear your printer's internal cache...


** Scripting

#+begin_src emacs-lisp

#+end_src

*** Utility Functions

hmmmm ... =almost-surely-most-positive-fixnum=?

#+begin_src emacs-lisp
(format "%X" (* 1 most-positive-fixnum))         ;"1FFFFFFFFFFFFFFF"
(format "%X" (* 2 most-positive-fixnum))         ;"3FFFFFFFFFFFFFFE"
(format "%X" (* 4 most-positive-fixnum))         ;"7FFFFFFFFFFFFFFC"
(format "%X" (* 8 most-positive-fixnum))         ;"FFFFFFFFFFFFFFF8"
(format "%X" (* 16 most-positive-fixnum))       ;"1FFFFFFFFFFFFFFF0"
(format "%X" (+ 1 (* 16 most-positive-fixnum))) ;"1FFFFFFFFFFFFFFF1"
#+end_src

Well =integer-width= is set to =65536=. That's interesting.

Generate octal or other formats

#+begin_src emacs-lisp
(defun rand-formatted (format &optional nchars)
  (if-let* ((nbits (or (and (equal format "o") 3)
                       (and (equal format "X") 4)))
            (nmax (or (and nchars
                           (expt 2 (* nbits nchars)))
                      (* 2 most-positive-fixnum)))
            (nrand (random nmax)))
      (progn
        (message "%s %s %s" nbits nmax nrand)
        ;; nrand
        (format (concat "%" format) nrand))
    (user-error "something not right")))
#+end_src

Generate MD5 Hex

#+begin_src emacs-lisp
(let* ((hash-str (reverse "fdab123ce"))
       (nchars (length hash-string)))
  (cl-loop for i from 1 to (- (length hash-str) 1)
           iter-by 2
           thereis (< (- nchars i) 2)
           collect))
#+end_src

#+RESULTS:

 ... or not

#+begin_quote
i could write this in clojure in like 5 seconds ... does cl-reduce give you the
index? well it doesn't allow you to really accumulate.
#+end_quote

So =hexdump= it is ... i forgot about that and didn't realize it has plenty of
[[https://stackoverflow.com/questions/34328759/how-to-get-a-random-string-of-32-hexadecimal-digits-through-command-line][formatting options]]. Thanks command line.

#+begin_src sh :results verbatim
bytes=32
chunk_bytes=2
chunks="$(($bytes/$chunk_bytes))"

# for hex, luckily octal doesn't need to be interpolated
hd_hex_formatter="%0$((2 * chunk_bytes))X"
hd_expr="$((chunks - 1))/$chunk_bytes \"$hd_hex_formatter:\""
hd_expr="$hd_expr 1/$chunk_bytes \"$hd_hex_formatter \n\""

echo $hd_expr
hexdump -vn"$bytes" -e "$hd_expr" /dev/urandom
#+end_src

#+RESULTS:
: 15/2 "%04X:" 1/2 "%04X \n"
: 693A:02C4:757A:2E97:6D02:0DA2:BCBD:0332:0D32:681A:5677:19B8:173B:4F1E:27F9:2D53

*** Join Across Command Output

Unfortunately the =join= command only allows one input to be piped in. So
=mktemp -d= can be used to get around that, but this probably shouldn't be
used. Still I haven't gotten much practice with these commands or file
descriptors, so I'd like to document using them for my own purposes...

The =gpg-connect-agent= command =KEYINFO=  outputs in this format:

=KEYINFO <keygrip> <type> <serialno> <idstr> <cached> <protection> <fpr>=

The =ssh-add -l -E MD5= command outputs in this format

=<algorithm> MD5:<ssh-frg> <key comment>= or =ssh-add -l= outputs with =SHA256=

So we can guarantee spacing of fields and join against them, the goal being to
guarantee the uniqueness of a key's fingerprint.

#+begin_src sh

gpg-connect-agent "KEYINFO --ssh-list --ssh-fpr" /bye | \
    head -n-1 | \

#+end_src

***** TODO complete join example

*** Select with md5 instead

(incomplete)

#+begin_src sh :eval no
regexMD5='MD5:([[:xdigit:]:]+)'

gpg-connect-agent "KEYINFO --ssh-list --ssh-fpr" /bye | \
    head -n-1 | \
    sed -E "s/^.*$regexMD5.*$/\1/g" \

# either named or nested captures don't seem to work...
#    sed -e 's/^.*MD5\(?<fgr>\(:[0-9a-f]\{2\}\)\)/\k<fgr>/'
#    sed -e 's/^.*MD5\(\(:[0-9a-f]\{2\}\)\)/\1/'
#+end_src

#+RESULTS:

**** Help on KEYINFO commands

#+begin_src sh :results verbatim :exports both
gpg-connect-agent "help KEYINFO" /bye
#+end_src

#+RESULTS:
#+begin_example
# KEYINFO [--[ssh-]list] [--data] [--ssh-fpr[=algo]] [--with-ssh] <keygrip>
#
# Return information about the key specified by the KEYGRIP.  If the
# key is not available GPG_ERR_NOT_FOUND is returned.  If the option
# --list is given the keygrip is ignored and information about all
# available keys are returned.  If --ssh-list is given information
# about all keys listed in the sshcontrol are returned.  With --with-ssh
# information from sshcontrol is always added to the info. Unless --data
# is given, the information is returned as a status line using the format:
#
#   KEYINFO <keygrip> <type> <serialno> <idstr> <cached> <protection> <fpr>
#
# KEYGRIP is the keygrip.
#
# TYPE is describes the type of the key:
#     'D' - Regular key stored on disk,
#     'T' - Key is stored on a smartcard (token),
#     'X' - Unknown type,
#     '-' - Key is missing.
#
# SERIALNO is an ASCII string with the serial number of the
#          smartcard.  If the serial number is not known a single
#          dash '-' is used instead.
#
# IDSTR is the IDSTR used to distinguish keys on a smartcard.  If it
#       is not known a dash is used instead.
#
# CACHED is 1 if the passphrase for the key was found in the key cache.
#        If not, a '-' is used instead.
#
# PROTECTION describes the key protection type:
#     'P' - The key is protected with a passphrase,
#     'C' - The key is not protected,
#     '-' - Unknown protection.
#
# FPR returns the formatted ssh-style fingerprint of the key.  It is only
#     printed if the option --ssh-fpr has been used.  If ALGO is not given
#     to that option the default ssh fingerprint algo is used.  Without the
#     option a '-' is printed.
#
# TTL is the TTL in seconds for that key or '-' if n/a.
#
# FLAGS is a word consisting of one-letter flags:
#       'D' - The key has been disabled,
#       'S' - The key is listed in sshcontrol (requires --with-ssh),
#       'c' - Use of the key needs to be confirmed,
#       '-' - No flags given.
#
# More information may be added in the future.
OK
#+end_example
