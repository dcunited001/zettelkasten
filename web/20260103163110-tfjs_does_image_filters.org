:PROPERTIES:
:ID:       7b89f91a-7b79-4ec4-898e-802804e2ed02
:header-args+: :dir "./tfjs-does-image-filters" :var ob@tfjsBuild="./tfjs-does-image-filters"
:END:
#+TITLE: TFJS Does Image Filters
#+CATEGORY: web
#+TAGS:

* Roam
+ [[id:fbf026c8-6c89-4ad3-a72e-2d693371c76a][Machine Learning]]
+ [[id:4c629c53-91b5-45eb-bb45-7dd0aca51123][Tensorflow]]
+ [[id:4ab045b9-ea4b-489d-b49e-8431b70dd0a5][Data Science]]

* Resources

* Overview :noexport:

** Setup

The build directory

#+name: ob@tfjsBuild
#+begin_src emacs-lisp
(org-roam-node-slug (org-roam-node-at-point))
#+end_src

#+RESULTS: ob@tfjsBuild
: tfjs_does_image_filters

Specifying a file to tangle into. The block is named german =bau= because it's
unique, short and related to construction. =#+call: bau(f​=​"fdsa.js")= will return
the filename so typing out portable destinations to tangle into isn't excruciating

#+name: bau
#+headers: :var f=""
#+begin_src emacs-lisp :sync yes
(if (string-empty-p f)
    (org-roam-node-slug (org-roam-node-at-point))
  ;; i just don't want the full path in output
  ;; (expand-file-name f (org-roam-node-slug (org-roam-node-at-point)))
  (format "./%s/%s" (org-roam-node-slug (org-roam-node-at-point)) f))
#+end_src

#+RESULTS: bau
: tfjs_does_image_filters

#+call: bau(f="asdf.js")

#+RESULTS:
: ./tfjs_does_image_filters/asdf.js

*** Files

These need to be tangled once into the =./tfjs-does-image-filters= directory.
However, I will be _weaving_ the files, since I want nice features like completion
where possible. Detangling the files is primarily intended to provide some
documentation of what I did.

|------------------+---------+-------------------------------------------------------|
| File             | Type    | Purpose                                               |
|------------------+---------+-------------------------------------------------------|
| network.ipynb    | jupyter | Builds one or more networks                           |
| network.h5       | ??      | Contains state for the network/model                  |
| erode.webgpu.js  | js      | The =erode= operation as a custom WebGPU compute shader |
| dilate.webgpu.js | js      | The =dilate= operation                                  |
| index.js         | js      | The main javascript                                   |
| ../obreset.css   | css     |                                                       |
| index.css        | css     | Resets for org-babel's css and the site's css         |
| index.html       | html    | The page and canvas layout                            |
|------------------+---------+-------------------------------------------------------|

It's possible that I would...

#+name: index.html
#+begin_src html :tangle (org-sbe bau (f $"index.html")) :comments link
<html>
  <head>
    <!-- Load TensorFlow.js -->
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs/dist/tf.min.js"> </script>
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs-backend-webgpu/dist/tf-backend-webgpu.js"></script>
  </head>

  <body>
#+end_src

#+begin_src html :tangle (org-sbe bau (f $"index.html")) :comments link
  <!-- Place your code in the script tag below. You can also use an external .js file -->
  <script>
    // Define a model for linear regression.
    const model = tf.sequential();
    model.add(tf.layers.dense({units: 1, inputShape: [1]}));

    // Prepare the model for training: Specify the loss and the optimizer.
    model.compile({loss: 'meanSquaredError', optimizer: 'sgd'});

    // Generate some synthetic data for training.
    const xs = tf.tensor2d([1, 2, 3, 4], [4, 1]);
    const ys = tf.tensor2d([1, 3, 5, 7], [4, 1]);

    // Train the model using the data.
    model.fit(xs, ys).then(() => {
      // Use the model to do inference on a data point the model hasn't seen before:
      // Open the browser devtools to see the output
      model.predict(tf.tensor2d([5], [1, 1])).print();
    });
  </script>
</body>
</html>
#+end_src
