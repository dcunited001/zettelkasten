:PROPERTIES:
:ID:       95fc3cfe-a41b-4175-b2b0-9a4ed1acff59
:END:
#+TITLE: Bash Binds
#+TAGS:
#+EMAIL:     aionfork@gmail.com
#+DESCRIPTION: notes
#+OPTIONS: ':nil *:t -:t ::t <:t \n:nil ^:t arch:headline
#+OPTIONS: author:nil c:nil d:(not "LOGBOOK") date:nil
#+OPTIONS: e:t email:nil f:t inline:t num:nil p:nil pri:nil stat:t
#+OPTIONS: tags:t tasks:t tex:t timestamp:nil todo:t |:t
#+OPTIONS: toc:nil
#+OPTIONS: html-style:link
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="bash-binds.css" />
# #+BIND: org-html-htmlize-output-type nil
#+SELECT_TAGS:
#+EXCLUDE_TAGS: noexport
#+KEYWORDS:
#+LANGUAGE: en

The completion keybinds use mnemonic symbols for each category. =@= for hostname,
=/= pathsep for files, =!= bang for commands. Known hosts won't complete if they are
hashed, which they probably should be. Most of Bash syntax has similar mnemonics
in the syntax for keys & string expansions, but it sounds a bit weird explaining
it.

* Emacs Bindings

#+begin_export html
<pre>
#+end_export

#+begin_verse
 abort *C-g*, *C-x C-g*, *M-C-g*       _digit_                                     _insert_                                   spell-correct-word *C-x s*             
 accept-line *C-j*, *C-m*            ├── argument *M--*                          ├── comment *M-#*                          start-kbd-macro *C-x (*                  
                                 ├── argument *M-0*                          ├── completions *M-**                      tilde-expand *M-&*                       
 _backward_                        ├── argument *M-1*                          └── last-argument *M-.*, *M-_*                                          
 ├── char *C-b*, *<left>*            ├── argument *M-2*                                                                   _transpose_                             
 ├── delete *C-h*                  ├── argument *M-3*                          _kill_                                     ├── chars *C-t*                         
 ├── _kill_                        ├── argument *M-4*                          ├── line *C-k*                             └── words *M-t*                         
 │   ├── line *C-x C-?*            ├── argument *M-5*                          └── word *C-<delete>*, *M-d*                                                       
 │   └── word *M-C-h*              ├── argument *M-6*                                                                   undo *C-_*, *C-x C-u*                      
 └── word *M-b*, *M-<left>*          ├── argument *M-7*                          _next_                                                                           
                                 ├── argument *M-8*                          └── history *C-n*, *M-<down>*                _unix_                                  
 _beginning-of_                    └── argument *M-9*                                                                   ├── line-discard *C-u*                  
 ├── history *M-<*, *<pgup>*                                                   _non-incremental_                          └── word-rubout *C-w*                   
 └── line *C-a*, *<home>*            display-shell-version *C-x C-v*             ├── forward-search-history *M-n*                                                 
                                 downcase-word *M-l*                         └── reverse-search-history *M-p*           upcase-word *M-u*                                   
 call-last-kbd-macro *C-x e*       dynamic-complete-history *M-C-i*                                                                           
 capitalize-word *M-c*             edit-and-execute-command *C-x C-e*          operate-and-get-next *C-o*                 _yank_ *C-y*                                                      
                                                                                                                    ├── last-arg *M-.*, *M-_*                 
 _character-search_ *C-]*            _end_                                       _possible_                                 ├── nth-arg *M-C-y*                     
 └── backward *M-C-] $char*        ├── kbd-macro *C-x )*                       ├── command-completions *C-x!*             └── pop *M-y*                           
                                 └── _of-history_ *M->*, history *M-<pgdown>*    ├── completions *M-*, *M-?*                              
 _clear_                               └── line *C-e*, line *<end>*              ├── filename-completions ~C-x *~                 
 ├── display *M-C-l*                                                         ├── hostname-completions *C-x@*                 
 └── screen *C-l*                  exchange-point-and-mark *C-x C-x*           ├── username-completions *C-x~*                 
                                 execute-named-command *M-x*                 └── variable-completions *C-x$*                 
 _complete_ *C-i*, *<esc> <esc>*                                                                                               
 ├── command *M-!*                 _forward_                                   _previous_                                      
 ├── filename *M-*                 ├── char *C-f*, *M-<right>*                   └── history *C-p*, *M-<up>*                       
 ├── hostname *M-@*                ├── search-history *C-s*                                                                  
 ├── into-braces *M-{*             ├── word *M-f*                              quoted-insert *C-q*, *C-v*, *<insert>*              
 ├── username *M-~*                └── word *M-<right>*                        re-read-init-file *C-x C-r*                      
 └── variable *M-$*                                                          reverse-search-history *C-r*                    
                                 _glob_                                      revert-line *M-C-r*, *M-r*                        
 _delete_                          ├── complete-word *M-g*                     set-mark *C-@*, *M-"*                             
 ├── char *C-d*, *<delete>*          ├── expand-word *C-x**                                                                    
 └── horizontal-space *M-\*        └── list-expansions *C-xg*                  _shell_                                         
                                                                           ├── backward-word *M-C-b*                       
                                 history-expand-line *M-^*                   ├── expand-line *M-C-e*                         
                                                                           ├── forward-word *M-C-f*                        
                                                                           ├── kill-word *M-C-d*                      
                                                                           └── transpose-words *M-C-t*                
#+end_verse

#+begin_export html
</pre>
#+end_export

* Self-Insert

Hitting =C v= or =<insert>= runs =quoted-insert $key= which inserts the escape
sequence for =$key= into the terminal. Running =quoted-insert= on these keys in
sequence enters the following into the terminal. Successive =C v= keybinds seem to
be handled recursively.

|----------+-------+-----+---------+---------+---------+---------+---------+---------|
|          | 000   | 001 | 010     | 011     | 100     | 101     | 110     | 111     |
|          |       |   S | M       | M S     | C       | C S     | C M     | C M S   |
|----------+-------+-----+---------+---------+---------+---------+---------+---------|
| <insert> | =^[[2~= |     | =^[[2;3~= | =^[[2;4~= | =^[[2;5~= | =^[[2;6~= | =^[[2;7~= | =^[[2;8~= |
| C v      | =^v=    |     | =^[V=     |         |         |         |         |         |
|----------+-------+-----+---------+---------+---------+---------+---------+---------|
The terminal application will intercept =C v= before it's given to the window
manager (something like this), so you need to use =C S v= to paste.

In =xkb=, the =shift= modkey causes alphanumeric keybinds to be interpreted as their
raw character codes. =C S v= literally inserts =C V= and =AltGr ;= into =¶=. Thus, I
removed =self-insert= & =do-lowercase-version= binds from this reference.

* Escape Sequences

|----+------+----+--------+-----+--------+------+-------+-------+-------|
| F1 | =^[OP= | F5 | =^[[15~= | F9  | =^[[20~= | home | =^[[H=  | del   | =^[[3~= |
| F2 | =^[OQ= | F6 | =^[[17~= | F10 | =^[[21~= | end  | =^[[F=  | bksp  | =^?=    |
| F3 | =^[OR= | F7 | =^[[18~= | F11 | =^[[23~= | pgup | =^[[5~= | bktab | =^[[Z=  |
| F4 | =^[OS= | F8 | =^[[19~= | F12 | =^[[24~= | pgdn | =^[[6~= | esc   | =^[=    |
|----+------+----+--------+-----+--------+------+-------+-------+-------|
* Quality of Life Keybinds

#+begin_export html
<pre>
#+end_export

#+begin_verse
abort *C-g*                     digit-argument *M [0-9-]*             print-last-kbd-macro
capitalize-word *M-c*           downcase-word *M l*                   quoted-insert *C-v*, *<insert>*
                              dynamic-complete-history *M C i*      undo *C _*
character-search *C ] $char*    edit-and-execute-command *C xC e*     undo *C xC u*
└── backward *M C ] $char*      exchange-point-and-mark *C xC x*      upcase-word *M-u*

complete                      glob                                yank
├── command *M !*               ├── complete-word *M g*               ├── nth-arg *M C y*
├── filename ~M \*~             ├── expand-word *C x*                 └── pop *M y*
├── hostname *M @*              └── list-expansions *C xg*
├── into-braces *M {*
├── username *M ~*              insert
└── variable *M $*              ├── completions *<esc>* ***
                              └── last-argument *M .*, *M _*
#+end_verse

#+begin_export html
</pre>
#+end_export


* Keybind Combos

**** To avoid the strange =unix-word-rubout=

Keybinds involving =C-w= require setting:

=bind '"\C-@":set-mark'=

=bind '"\e ":set-mark'=

=bind '"\C-w":kill-region'=

=bind '"\ew":copy-region-as-kill'=

**** From middle of file or url path  =C-@ M-C ] <space> C-x C-x C-w=

Jump to last space, cut region, leaving the remainder of the path.

Then =C-a varname=value; C-x C-x <right>=

**** From midline =C-@ C-] | C-] | C-x C-x C-w=

Set mark with =C-@=, search forward the next two =|= chars, then
=exchange-point-and-mark= with =C-x C-x=.

This highlights the region. Then =C-w= to cut the text with =kill-region=.

**** From midline ==C-k C-a C-y=

Swap order of commands

**** From midline =C-k C-a C-] | C-] | ... C-y=

cut to end of line, search through line for =|= char and insert the tail of a bash
pipeline. Simply repeating =C-]= doesn't work.

**** From midline =C-a export VAR=value;=

Prefix command with environment var

**** From midline =C-k # C-y=

Kill to end of line, insert =#= and paste. =C-y= to =yank=. Commented command content
is still in history.

**** Running =print-last-keyboard-macro= ...

Shows you what's recorded. You can make composite functions.


* Unmapped by default

#+begin_export html
<pre>
#+end_export

#+begin_verse
alias-expand-line     _dump_                          _kill_                               _previous_                    
arrow-key-prefix      ├── functions                 ├── region                         └── screen-line               
                      ├── macros                    └── whole-line                                                   
_backward_              └── variables                                                    print-last-kbd-macro          
└── byte                                            magic-space                        redraw-current-line           
                      emacs-editing-mode                                                                             
bash-vi-complete      export-completions            _menu_                               _shell_                         
                      fetch-history                 ├── complete                       └── backward-kill-word        
_copy_                                                └── complete-backward                                            
├── backward-word     _forward_                                                          skip-csi-sequence             
├── forward-word      ├── backward-delete-char      _next_                               tab-insert                    
└── region-as-kill    └── byte                      └── screen-line                    tty-status                    
                                                                                       universal-argument            
dabbrev-expand        _history_                       _non-incremental_
                      ├── and-alias-expand-line     ├── forward-search-history-again   _unix_
_delete_                ├── search-backward           └── reverse-search-history-again   └── filename-rubout
└── char-or-list      ├── search-forward
                      └── substring                 old-menu-complete
                          ├── search-backward       overwrite-mode
                          └── search-forward
#+end_verse

#+begin_export html
</pre><br><br><br>
#+end_export

* Vi Bindings

#+begin_example
For vi bindings ... you're on your own.
#+end_example

#+begin_export html
<pre>
#+end_export

#+begin_verse
*vi*                  *vi*                           *vi*                       *vi*
├── append          ├── char-search              ├── forward              ├── redo
│   ├── eol         ├── column                   │   ├── bigword          ├── replace
│   └── mode        ├── complete                 │   └── word             ├── rubout
├── arg-digit       ├── delete-to                ├── fword                ├── search-again
├── back-to-indent  ├── edit-and-execute-command ├── fWord                ├── set-mark
├── backward        ├── editing-mode             ├── goto-mark            ├── subst
│   ├── bigword     ├── end                      ├── insert-beg           ├── tilde-expand
│   └── word        │   ├── bigword              ├── insertion-mode       ├── undo
├── bword           │   └── word                 ├── match                ├── unix-word-rubout
├── bWord           ├── eof-maybe                ├── movement-mode        └── yank
└── change          ├── eword                    ├── next-word                ├── arg
    ├── case        ├── eWord                    ├── overstrike-delete        ├── pop
    ├── char        ├── fetch-history            ├── prev-word                └── to
    └── to          └── first-print              └── put
#+end_verse

#+begin_export html
</pre>
#+end_export


* noexport :noexport:

I really can't do this correctly twice. difficult to keep track of state & i
haven't used vi bindings much in bash. =set -o vi= doesn't seem to set much by
default

#+begin_src css :tangle bash-binds.css
/* org reset --------------------------------------------- */
body { font-size: 0.9em; margin: 0.1em; padding: 0em }
p { font-size: 0.9em; }
th { background-color: seagreen; color: #F6F6F6; }
table { border: 1px solid darkgreen; border-radius: 3px; }
th,td { border: 1px solid darkgreen; padding: 0.2em; font-size: 0.9em; }
#content { max-width: 100% !important }
code { color: indigo; }
h1,h2,h3,h4,h5 { margin: 0.2em; padding: 0.1em}
ul,ol { margin: 0.1em; }

dd { margin: 0.1em 2em; }
li { margin: 0.1em;font-size: 0.9em; }

/* cheatsheet --------------------------------------------- */
table { display: table; margin: auto; }
pre { background: inherit; border: none; padding: 0.2em; margin: 0.2em auto; display:table; }
h2 { color: darkblue; font-size: 1.1em; line-height: 1.1em; text-align: center; margin: 0.2em auto; }
h5 { color: darkgreen; line-height: 1.1em; margin: 0.1em auto; }
p { margin: 0.1em }

/* this rule is needed twice for some reason */
p.verse b { color: darkgreen !important; }
p.verse b { color: darkgreen; }
p.verse i { color: darkblue !important; }
p.verse span.underline { color: maroon !important; }  /* font-weight: 550; */
/* p.verse b { color: darkgreen; } */
p.verse { font-family: monospace; line-height: 0.7em; padding: 0; margin: 0.2em}; }
#+end_src

** Extracting

#+begin_src shell
set -o emacs
alias bashbinds2="bind -p \
    | tr -d ':\"' \
    | sed -e 's/^# /#/g/ \
    | sed -e 's/ (not bound)//g' \
    | sed -e 's/\\\\e/M /g' \
    | sed -e 's/\\\\C-/C /g' \
    | grep -v 'self-insert'"

# dear god that's messy

# paste <(bashbinds2 | rev | cut -f1 -d' ' | rev) \
#     <(bashbinds2 | rev | cut -f2- -d' ' | rev) \
#     | sed -E 's/\s+#.*//g' | sed -E 's/^#//g'

# paste <(bashbinds2 | rev | cut -f1 -d' ' | tr '-' '/' | rev | sed -E 's/$/\//g') \
#     <(bashbinds2 | rev | cut -f2- -d' ' | rev) \
#     | sed -E 's/\s+#.*//g' | sed -E 's/^#//g' \
#     | tree --noreport --fromfile .

# still requires some manual cleanup
paste <(bashbinds2 | rev | cut -f1 -d' ' | tr '-' '/' | rev | sed -E 's/$/\//g') \
    <(bashbinds2 | rev | cut -f2- -d' ' | rev) \
    | sed -E 's/\s+#.*//g' | sed -E 's/^#//g' | tr -d '  ' \
    | tree --noreport --fromfile .
#+end_src

still requires some manual cleanup

+ replace =[5A= with =<right>=, delete similar
+ replace =[5B= with =<up>=, delete similar
+ replace =[5C= with =<right>=, delete similar
+ replace =[5D= with =<left>=, delete similar


** xkb

Without additional =xkb= levels, =A AltGr $key= will insert chars into
=alacritty= that cause application panic

#+begin_example text
The application panicked (crashed).
Message:  called `Result::unwrap()` on an `Err` value: "\x9F"
Location: library/std/src/env.rs:871
#+end_example

