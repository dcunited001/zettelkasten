<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2025-12-23 Tue 15:29 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Riastradh's Lisp Style Rules</title>
<meta name="description" content="Apple
notes" />
<meta name="generator" content="Org Mode" />
<style type="text/css">
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<link rel="stylesheet" type="text/css" href="riastradh-scheme-style-guide.css" />
</head>
<body>
<div id="content" class="content">
<h1 class="title">Riastradh's Lisp Style Rules</h1>
<p>
(note: i haven't fully checked over whether my text-munging screws up the
examples. also need to fix the syntax highlighting)
</p>

<p class="verse">
   Copyright (C) 2007&#x2013;2011 Taylor R. Campbell<br />
<br />
   CC BY-NC-SA 3.0<br />
<br />
   This work is licensed under a Creative Commons<br />
   Attribution-NonCommercial-ShareAlike 3.0 Unported License:<br />
   <a href="http://creativecommons.org/licenses/by-nc-sa/3.0/">http://creativecommons.org/licenses/by-nc-sa/3.0/</a>.<br />
</p>

<p>
This is a guide to Lisp style, written by Taylor R. Campbell, to
describe the standard rules of Lisp style as well as a set of more
stringent rules for his own style.  This guide should be useful for
Lisp in general, but there are [or will be in the final draft] parts
that are focussed on or specific to Scheme or Common Lisp.
</p>

<p>
This guide is written primarily as a collection of rules, with
rationale for each rule.  (If a rule is missing rationale, please
inform the author!)  Although a casual reader might go through and read
the rules without the rationale, perhaps reasoning that reading of the
rationale would require more time than is available, such a reader
would derive little value from this guide.  In order to apply the rules
meaningfully, their spirit must be understood; the letter of the rules
serves only to hint at the spirit.  The rationale is just as important
as the rules.
</p>

<p>
There are many references in this document to <code>Emacs</code>, <code>GNU Emacs</code>,
<code>Edwin</code>, and so on.  In this document, <code>Emacs</code> means any of a class of
editors related in design to a common ancestor, the <code>EMACS</code> editor macros
written for <code>TECO</code> on <code>ITS</code> on the <code>PDP-10</code> in the middle of the nineteen
seventies.  All such editors &#x2013; or <code>all Emacsen</code>, since <code>Emacsen</code> is
the plural of <code>Emacs</code> &#x2013; have many traits in common, such as a very
consistent set of key bindings, extensibility in Lisp, and so on.  <code>GNU
Emacs</code> means the member of the class of editors collectively known as
Emacsen that was written for the GNU Project in the middle of the
nineteen eighties, and which is today probably the most popular Emacs.
<code>Edwin</code> is MIT Scheme's Emacs, which is bundled as part of MIT Scheme,
and not available separately.  There are other Emacsen as well, such as
Hemlock and Climacs, but as the author of this document has little
experience with Emacsen other than GNU Emacs and Edwin, there is little
mention of other Emacsen.
</p>

<p>
This guide is a work in progress.  To be written:
</p>

<ul class="org-ul">
<li>Indentation rules for various special operators.</li>
<li>Philosophical rambling concerning naming.</li>
<li>Rules for breaking lines.</li>
<li>Many more examples.</li>
<li>A more cohesive explanation of the author's principles for composing
programs, and their implications.</li>
<li>Rules for writing portable code.</li>
<li>Some thoughts concerning extensions to the lexical syntax.</li>
<li>Rules for writing or avoiding macros.</li>
<li>Some unfinished rationale.</li>
<li>More on documentation.</li>
<li>The <code>Dependencies</code> subsection of the <code>General Layout</code> section should
be put in a different section, the rest of which has yet to be
written, on organization of programs, module systems, and portable
code.</li>
</ul>

<p>
Feedback is welcome; address any feedback by email to the host
mumble.net's user <code>campbell</code>, or by <code>IRC</code> to Riastradh in the #scheme
channel on Freenode (irc.freenode.net).  Feedback includes reports of
typos, questions, requests for clarification, and responses to the
rationale, except in the case of round brackets versus square
brackets, the argument surrounding which is supremely uninteresting
and now not merely a dead horse but a rotting carcass buzzing with
flies and being picked apart by vultures.
</p>

<p>
As this document has grown, the line between standard Lisp rules and
the author's own style has been blurred.  The author is considering
merging of the partition, but has not yet decided on this with
certainty.  Opinions on the subject are welcome &#x2013; is the partition
still useful to keep the author's biases and idiosyncrasies out of the
standard rules, or has the partition with its arbitrary nature only
caused disorganization of the whole document?
</p>

<p>
Unfortunately, this document is entirely unscientific.  It is at best a
superstition or philosophy, but one that the author of this document
has found to have improved his programs.  Furthermore, the author is
somewhat skeptical of claims of scientific analyses of these matters:
analyzing human behaviour, especially confined to the set of excellent
programmers who often have strong opinions about their methods for
building programs, is a very tricky task.
</p>
<div id="outline-container-org35c66bc" class="outline-2">
<h2 id="org35c66bc">Standard Rules</h2>
<div class="outline-text-2" id="text-org35c66bc">
<p>
These are the standard rules for formatting Lisp code; they are
repeated here for completeness, although they are surely described
elsewhere.  These are the rules implemented in Emacs Lisp modes, and
auxiliary utilities such as Paredit.
</p>

<p>
The rationale given here is merely the author's own speculation of the
origin of these rules, and should be taken as nothing more than it.
The reader shall, irrespective of the author's rationale, accept the
rules as sent by the reader's favourite deity, or Cthulhu if no such
deity strikes adequate fear into the heart of the reader.
</p>
</div>
<div id="outline-container-org079217f" class="outline-3">
<h3 id="org079217f">Parentheses</h3>
<div class="outline-text-3" id="text-org079217f">
</div>
<div id="outline-container-org571c285" class="outline-4">
<h4 id="org571c285">Terminology</h4>
<div class="outline-text-4" id="text-org571c285">
<p>
This guide avoids the term <i>parenthesis</i> except in the general use of
<i>parentheses</i> or <i>parenthesized</i>, because the word's generally accepted
definition, outside of the programming language, is a statement whose
meaning is peripheral to the sentence in which it occurs, and <b>not</b> the
typographical symbols used to delimit such statements.
</p>

<p>
The balanced pair of typographical symbols that mark parentheses in
English text are <i>round brackets</i>, i.e. ( and ).  There are several
other balanced pairs of typographical symbols, such as <i>square
brackets</i> (commonly called simply <code>brackets</code> in programming circles),
i.e. [ and ]; <i>curly braces</i> (sometimes called simply <code>braces</code>), i.e. {
and }; <i>angle brackets</i> (sometimes <code>brokets</code> (for <code>broken brackets</code>)),
i.e. &lt; and &gt;.
</p>

<p>
In any balanced pair of typographical symbols, the symbol that begins
the region delimited by the symbols is called the <i>opening bracket</i> or
the <i>left bracket</i>, such as ( or [ or { or &lt;.  The symbol that ends
that region is called the <i>right bracket</i> or the <i>closing bracket</i>,
such as &gt; or } or ] or ).
</p>
</div>
</div>
<div id="outline-container-org51f23c5" class="outline-4">
<h4 id="org51f23c5">Spacing</h4>
<div class="outline-text-4" id="text-org51f23c5">
<p>
If any text precedes an opening bracket or follows a closing bracket,
separate that text from that bracket with a space.  Conversely, leave
no space after an opening bracket and before following text, or after
preceding text and before a closing bracket.
</p>

<p>
<b>Unacceptable:</b>
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #446844;">(</span><span style="color: #3232cc;">foo(</span><span style="color: #661966;">bar baz</span><span style="color: #3232cc;">)quux</span><span style="color: #446844;">)</span>
<span style="color: #446844;">(</span><span style="color: #3232cc;">foo (</span> <span style="color: #661966;">bar baz </span><span style="color: #3232cc;">)</span> <span style="color: #3232cc;">quux</span><span style="color: #446844;">)</span>
</pre>
</div>

<p>
<b>Acceptable:</b>
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #446844;">(</span><span style="color: #3232cc;">foo (</span><span style="color: #661966;">bar baz</span><span style="color: #3232cc;">)</span> <span style="color: #3232cc;">quux</span><span style="color: #446844;">)</span>
</pre>
</div>

<p>
<b>Rationale:</b>  This is the same spacing found in standard typography of
European text.  It is more aesthetically pleasing.
</p>
</div>
</div>
<div id="outline-container-org0dfcf28" class="outline-4">
<h4 id="org0dfcf28">Line Separation</h4>
<div class="outline-text-4" id="text-org0dfcf28">
<p>
Absolutely do <b>not</b> place closing brackets on their own lines.
</p>

<p>
<b>Unacceptable:</b>
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #446844;">(</span><span style="color: #3232cc;">define</span><span style="color: #3232cc;"> (</span><span style="color: #661966;">factorial</span><span style="color: #661966;"> x</span><span style="color: #3232cc;">)</span>
  <span style="color: #3232cc;">(</span><span style="color: #661966;">if</span><span style="color: #661966;"> (</span><span style="color: #684454;">&lt; x 2</span><span style="color: #661966;">)</span>
      <span style="color: #661966;">1
      (</span><span style="color: #684454;">* x (</span><span style="color: #446844;">factorial (</span><span style="color: #3232cc;">- x 1
                      </span><span style="color: #446844;">)</span>
           <span style="color: #684454;">)</span>
      <span style="color: #661966;">)</span>
  <span style="color: #3232cc;">)</span>
<span style="color: #446844;">)</span>
</pre>
</div>

<p>
<b>Acceptable:</b>
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #446844;">(</span><span style="color: #3232cc;">define</span><span style="color: #3232cc;"> (</span><span style="color: #661966;">factorial</span><span style="color: #661966;"> x</span><span style="color: #3232cc;">)</span>
  <span style="color: #3232cc;">(</span><span style="color: #661966;">if</span><span style="color: #661966;"> (</span><span style="color: #684454;">&lt; x 2</span><span style="color: #661966;">)</span>
      <span style="color: #661966;">1
      (</span><span style="color: #684454;">* x (</span><span style="color: #446844;">factorial (</span><span style="color: #3232cc;">- x 1</span><span style="color: #446844;">)</span><span style="color: #684454;">)</span><span style="color: #661966;">)</span><span style="color: #3232cc;">)</span><span style="color: #446844;">)</span>
</pre>
</div>

<p>
<b>Rationale:</b>  The parentheses grow lonely if their closing brackets are
  all kept separated and segregated.
</p>
</div>
<div id="outline-container-org4a0a31d" class="outline-5">
<h5 id="org4a0a31d">Exceptions to the Above Rule Concerning Line Separation</h5>
<div class="outline-text-5" id="text-org4a0a31d">
<p>
Do not heed this section unless you know what you are doing.  Its title
does <b>not</b> make the unacceptable example above acceptable.
</p>

<p>
When commenting out fragments of expressions with line comments, it may
be necessary to break a line before a sequence of closing brackets:
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #446844;">(</span><span style="color: #3232cc;">define</span><span style="color: #3232cc;"> (</span><span style="color: #661966;">foo</span><span style="color: #661966;"> bar</span><span style="color: #3232cc;">)</span>
  <span style="color: #3232cc;">(</span><span style="color: #661966;">list (</span><span style="color: #684454;">frob bar</span><span style="color: #661966;">)</span>
        <span style="color: #661966;">(</span><span style="color: #684454;">zork bar</span><span style="color: #661966;">)</span>
        <span style="color: #4af227cc4af2;">;; </span><span style="color: #4af227cc4af2;">(zap bar)
</span><span style="color: #4af227cc4af2;">        </span><span style="color: #3232cc;">)</span><span style="color: #446844;">)</span>
</pre>
</div>

<p>
This is acceptable, but there are other alternatives.  In Common Lisp,
one can use the read-time conditional syntax, <code>#+</code> or <code>#-</code>, with a
feature conditional that is guaranteed to be false or true &#x2013; <code>#+(OR)</code>
or <code>#-(AND) --</code>; for example,
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #446844;">(</span><span style="color: #3232cc;">define</span><span style="color: #3232cc;"> (</span><span style="color: #661966;">foo</span><span style="color: #661966;"> bar</span><span style="color: #3232cc;">)</span>
  <span style="color: #3232cc;">(</span><span style="color: #661966;">list (</span><span style="color: #684454;">frob bar</span><span style="color: #661966;">)</span>
        <span style="color: #661966;">(</span><span style="color: #684454;">zork bar</span><span style="color: #661966;">)</span>
        <span style="color: #661966;">#+</span><span style="color: #661966;">(</span><span style="color: #684454;">or</span><span style="color: #661966;">)</span> <span style="color: #661966;">(</span><span style="color: #684454;">zap bar</span><span style="color: #661966;">)</span><span style="color: #3232cc;">)</span><span style="color: #446844;">).</span>
</pre>
</div>

<p>
Read-time conditionals are expression-oriented, not line-oriented, so
the closing brackets need not be placed on the following line.  Some
Scheme implementations, and <code>SRFI 62</code>, also support expression comments
with <code>#;</code>, which are operationally equivalent to the above read-time
conditionals for Common Lisp:
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #446844;">(</span><span style="color: #3232cc;">define</span><span style="color: #3232cc;"> (</span><span style="color: #661966;">foo</span><span style="color: #661966;"> bar</span><span style="color: #3232cc;">)</span>
  <span style="color: #3232cc;">(</span><span style="color: #661966;">list (</span><span style="color: #684454;">frob bar</span><span style="color: #661966;">)</span>
        <span style="color: #661966;">(</span><span style="color: #684454;">zork bar</span><span style="color: #661966;">)</span>
        <span style="color: #4af227cc4af2;">#;
         (zap bar</span><span style="color: #4af227cc4af2;">)</span><span style="color: #3232cc;">)</span><span style="color: #446844;">)</span>
</pre>
</div>

<p>
The expression is placed on another line in order to avoid confusing
editors that do not recognize S-expression comments; see the section
titled <code>Comments</code> below for more details.  However, the <code>#;</code> notation
is not standard &#x2013; it appears in neither the <code>IEEE 1178</code> document nor in
the <code>R5RS</code> &#x2013;, so line comments are preferable for portable Scheme code,
even if they require breaking a line before a sequence of closing
brackets.
</p>

<p>
Finally, it is acceptable to break a line immediately after an opening
bracket and immediately before a closing bracket for very long lists,
especially in files under version control.  This eases the maintenance
of the lists and clarifies version diffs.  Example:
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #446844;">(</span><span style="color: #3232cc;">define</span><span style="color: #3232cc;"> </span><span style="color: #3232cc;">colour-names</span><span style="color: #3232cc;">         </span><span style="color: #4f984f9895e4;">;</span><span style="color: #4f984f9895e4;">Add more colour names to this list!
</span><span style="color: #4f984f9895e4;">  </span><span style="color: #3232cc;">'(</span>
    <span style="color: #661966;">blue
    cerulean
    green
    magenta
    purple
    red
    scarlet
    turquoise
    </span><span style="color: #3232cc;">)</span><span style="color: #446844;">)</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgb658008" class="outline-4">
<h4 id="orgb658008">Parenthetical Philosophy</h4>
<div class="outline-text-4" id="text-orgb658008">
<p>
The actual bracket characters are simply lexical tokens to which little
significance should be assigned.  Lisp programmers do not examine the
brackets individually, or, Azathoth forbid, count brackets; instead
they view the higher-level structures expressed in the program,
especially as presented by the indentation.  Lisp is not about writing
a sequence of serial instructions; it is about building complex
structures by summing parts.  The composition of complex structures
from parts is the focus of Lisp programs, and it should be readily
apparent from the Lisp code.  Placing brackets haphazardly about the
presentation is jarring to a Lisp programmer, who otherwise would not
even have seen them for the most part.
</p>
</div>
</div>
</div>
<div id="outline-container-org5eb1028" class="outline-3">
<h3 id="org5eb1028">Indentation and Alignment</h3>
<div class="outline-text-3" id="text-org5eb1028">
<p>
The operator of any form, i.e. the first subform following the opening
round bracket, determines the rules for indenting or aligning the
remaining forms.  Many names in this position indicate special
alignment or indentation rules; these are special operators, macros, or
procedures that have certain parameter structures.
</p>

<p>
If the first subform is a non-special name, however, then if the second
subform is on the same line, align the starting column of all following
subforms with that of the second subform.  If the second subform is on
the following line, align its starting column with that of the first
subform, and do the same for all remaining subforms.
</p>

<p>
In general, Emacs will indent Lisp code correctly.  Run <code>C-M-q</code>
<code>(indent-sexp)</code> on any code to ensure that it is indented correctly, and
configure Emacs so that any non-standard forms are indented
appropriately.
</p>

<p>
<b>Unacceptable:</b>
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #446844;">(</span><span style="color: #3232cc;">+ (</span><span style="color: #661966;">sqrt -1</span><span style="color: #3232cc;">)</span>
  <span style="color: #3232cc;">(</span><span style="color: #661966;">* x y</span><span style="color: #3232cc;">)</span>
  <span style="color: #3232cc;">(</span><span style="color: #661966;">+ p q</span><span style="color: #3232cc;">)</span><span style="color: #446844;">)</span>

<span style="color: #446844;">(</span><span style="color: #3232cc;">+
   (</span><span style="color: #661966;">sqrt -1</span><span style="color: #3232cc;">)</span>
   <span style="color: #3232cc;">(</span><span style="color: #661966;">* x y</span><span style="color: #3232cc;">)</span>
   <span style="color: #3232cc;">(</span><span style="color: #661966;">+ p q</span><span style="color: #3232cc;">)</span><span style="color: #446844;">)</span>
</pre>
</div>

<p>
<b>Acceptable:</b>
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #446844;">(</span><span style="color: #3232cc;">+ (</span><span style="color: #661966;">sqrt -1</span><span style="color: #3232cc;">)</span>
   <span style="color: #3232cc;">(</span><span style="color: #661966;">* x y</span><span style="color: #3232cc;">)</span>
   <span style="color: #3232cc;">(</span><span style="color: #661966;">+ p q</span><span style="color: #3232cc;">)</span><span style="color: #446844;">)</span>

<span style="color: #446844;">(</span><span style="color: #3232cc;">+
 (</span><span style="color: #661966;">sqrt -1</span><span style="color: #3232cc;">)</span>
 <span style="color: #3232cc;">(</span><span style="color: #661966;">* x y</span><span style="color: #3232cc;">)</span>
 <span style="color: #3232cc;">(</span><span style="color: #661966;">+ p q</span><span style="color: #3232cc;">)</span><span style="color: #446844;">)</span>
</pre>
</div>

<p>
<b>Rationale:</b>  The columnar alignment allows the reader to follow the
  operands of any operation straightforwardly, simply by scanning
  downward or upward to match a common column.  Indentation dictates
  structure; confusing indentation is a burden on the reader who wishes
  to derive structure without matching parentheses manually.
</p>
</div>
<div id="outline-container-org7fd60a5" class="outline-4">
<h4 id="org7fd60a5">Non-Symbol Indentation and Alignment</h4>
<div class="outline-text-4" id="text-org7fd60a5">
<p>
The above rules are not exhaustive; some cases may arise with strange
data in operator positions.
</p>
</div>
<div id="outline-container-org01468f1" class="outline-5">
<h5 id="org01468f1">Lists</h5>
<div class="outline-text-5" id="text-org01468f1">
<p>
Unfortunately, style varies here from person to person and from editor
to editor.  Here are some examples of possible ways to indent lists
whose operators are lists:
</p>

<p>
Questionable:
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #446844;">(</span><span style="color: #3232cc;">(</span><span style="color: #661966;">car x</span><span style="color: #3232cc;">)</span>                            <span style="color: #4f984f9895e4;">;</span><span style="color: #4f984f9895e4;">Requires hand indentation.
</span><span style="color: #4f984f9895e4;">   </span><span style="color: #3232cc;">(</span><span style="color: #661966;">cdr x</span><span style="color: #3232cc;">)</span>
   <span style="color: #3232cc;">foo</span><span style="color: #446844;">)</span>

<span style="color: #446844;">(</span><span style="color: #3232cc;">(</span><span style="color: #661966;">car x</span><span style="color: #3232cc;">)</span> <span style="color: #3232cc;">(</span><span style="color: #661966;">cdr x</span><span style="color: #3232cc;">)</span>                    <span style="color: #4f984f9895e4;">;</span><span style="color: #4f984f9895e4;">GNU Emacs
</span><span style="color: #4f984f9895e4;"> </span><span style="color: #3232cc;">foo</span><span style="color: #446844;">)</span>
</pre>
</div>

<p>
<b>Preferable:</b>
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #446844;">(</span><span style="color: #3232cc;">(</span><span style="color: #661966;">car x</span><span style="color: #3232cc;">)</span>                            <span style="color: #4f984f9895e4;">;</span><span style="color: #4f984f9895e4;">Any Emacs
</span><span style="color: #4f984f9895e4;"> </span><span style="color: #3232cc;">(</span><span style="color: #661966;">cdr x</span><span style="color: #3232cc;">)</span>
 <span style="color: #3232cc;">foo</span><span style="color: #446844;">)</span>

<span style="color: #446844;">(</span><span style="color: #3232cc;">(</span><span style="color: #661966;">car x</span><span style="color: #3232cc;">)</span> <span style="color: #3232cc;">(</span><span style="color: #661966;">cdr x</span><span style="color: #3232cc;">)</span>                    <span style="color: #4f984f9895e4;">;</span><span style="color: #4f984f9895e4;">Edwin
</span><span style="color: #4f984f9895e4;">         </span><span style="color: #3232cc;">foo</span><span style="color: #446844;">)</span>
</pre>
</div>

<p>
<b>Rationale:</b>  The operands should be aligned, as if it were any other
  procedure call with a name in the operator position; anything other
  than this is confusing because it gives some operands greater visual
  distinction, allowing others to hide from the viewer's sight.  For
  example, the questionable indentation
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #446844;">(</span><span style="color: #3232cc;">(</span><span style="color: #661966;">car x</span><span style="color: #3232cc;">)</span> <span style="color: #3232cc;">(</span><span style="color: #661966;">cdr x</span><span style="color: #3232cc;">)</span>
 <span style="color: #3232cc;">foo</span><span style="color: #446844;">)</span>
</pre>
</div>

<p>
can make it hard to see that <code>FOO</code> and <code>(CDR X)</code> are both operands here
at the same level.  However, GNU Emacs will generate that indentation
by default.  (Edwin will not.)
</p>
</div>
</div>
<div id="outline-container-orgd3aca80" class="outline-5">
<h5 id="orgd3aca80">Strings</h5>
<div class="outline-text-5" id="text-orgd3aca80">
<p>
If the form in question is meant to be simply a list of literal data,
all of the subforms should be aligned to the same column, irrespective
of the first subform.
</p>

<p>
<b>Unacceptable:</b>
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #446844;">(</span><span style="color: #5d5a5d5abb55;">"foo"</span> <span style="color: #5d5a5d5abb55;">"bar"</span> <span style="color: #5d5a5d5abb55;">"baz"</span> <span style="color: #5d5a5d5abb55;">"quux"</span> <span style="color: #5d5a5d5abb55;">"zot"</span>
       <span style="color: #5d5a5d5abb55;">"mumble"</span> <span style="color: #5d5a5d5abb55;">"frotz"</span> <span style="color: #5d5a5d5abb55;">"gargle"</span> <span style="color: #5d5a5d5abb55;">"mumph"</span><span style="color: #446844;">)</span>
</pre>
</div>

<p>
Questionable, but acceptable:
</p>

<div class="org-src-container">
<pre class="src src-scheme">    <span style="color: #446844;">(</span><span style="color: #3232cc;">3 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3 2 3 8 4 6 2 6 4
       3 3 8 3 2 7 9 5 0 2 8 8 4 1 9 7 1 6 9 3 9 9 3</span><span style="color: #446844;">)</span>
</pre>
</div>

<p>
<b>Acceptable:</b>
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #446844;">(</span><span style="color: #5d5a5d5abb55;">"foo"</span> <span style="color: #5d5a5d5abb55;">"bar"</span> <span style="color: #5d5a5d5abb55;">"baz"</span> <span style="color: #5d5a5d5abb55;">"quux"</span> <span style="color: #5d5a5d5abb55;">"zot"</span>
 <span style="color: #5d5a5d5abb55;">"mumble"</span> <span style="color: #5d5a5d5abb55;">"frotz"</span> <span style="color: #5d5a5d5abb55;">"gargle"</span> <span style="color: #5d5a5d5abb55;">"mumph"</span><span style="color: #446844;">)</span>

<span style="color: #446844;">(</span><span style="color: #5d5a5d5abb55;">"foo"</span>
 <span style="color: #5d5a5d5abb55;">"bar"</span> <span style="color: #5d5a5d5abb55;">"baz"</span> <span style="color: #5d5a5d5abb55;">"quux"</span> <span style="color: #5d5a5d5abb55;">"zot"</span>
 <span style="color: #5d5a5d5abb55;">"mumble"</span> <span style="color: #5d5a5d5abb55;">"frotz"</span> <span style="color: #5d5a5d5abb55;">"gargle"</span> <span style="color: #5d5a5d5abb55;">"mumph"</span><span style="color: #446844;">)</span>
</pre>
</div>

<p>
<b>Rationale:</b>  Seldom is the first subform distinguished for any reason,
  if it is a literal; usually in this case it indicates pure data, not
  code.  Some editors and pretty-printers, however, will indent
  unacceptably in the example given unless the second subform is on the
  next line anyway, which is why the last way to write the fragment is
  usually best.
</p>
</div>
</div>
</div>
</div>
<div id="outline-container-org8f6516b" class="outline-3">
<h3 id="org8f6516b">Names</h3>
<div class="outline-text-3" id="text-org8f6516b">
<p>
Naming is subtle and elusive.  Bizarrely, it is simultaneously
insignificant, because an object is independent of and unaffected by
the many names by which we refer to it, and also of supreme
importance, because it is what programming &#x2013; and, indeed, almost
everything that we humans deal with &#x2013; is all about.  A full
discussion of the concept of name lies far outside the scope of this
document, and could surely fill not even a book but a library.
</p>

<p>
Symbolic names are written with English words separated by hyphens.
Scheme and Common Lisp both fold the case of names in programs;
consequently, camel case is frowned upon, and not merely because it is
ugly.  Underscores are unacceptable separators except for names that
were derived directly from a foreign language without translation.
</p>

<p>
<b>Unacceptable:</b>
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #446844;">XMLHttpRequest
foreach
append_map</span>
</pre>
</div>

<p>
<b>Acceptable:</b>
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #446844;">xml-http-request
for-each
append-map</span>
</pre>
</div>
</div>
<div id="outline-container-org1a5fd18" class="outline-4">
<h4 id="org1a5fd18">Funny Characters</h4>
<div class="outline-text-4" id="text-org1a5fd18">
<p>
There are several different conventions in different Lisps for the use
of non-alphanumeric characters in names.
</p>
</div>
<div id="outline-container-org9774207" class="outline-5">
<h5 id="org9774207">Scheme</h5>
<div class="outline-text-5" id="text-org9774207">
</div>
<div id="outline-container-orga3b7787" class="outline-6">
<h6 id="orga3b7787">Question Marks: Predicates</h6>
<div class="outline-text-6" id="text-orga3b7787">
<p>
Affix a question mark to the end of a name for a procedure whose
purpose is to ask a question of an object and to yield a boolean
answer.  Such procedures are called <code>predicates</code>.  Do not use a
question mark if the procedure may return any object other than a
boolean.
</p>

<p>
<b>Examples:</b>  <code>pair?</code> <code>procedure?</code> <code>proper-list?</code>
</p>

<p>
<b>Non-examples:</b>  member assoc any every
</p>

<p>
Pronounce the question mark as if it were the isolated letter <code>p</code>.  For
example, to read the fragment <code>(PAIR? OBJECT)</code> aloud, say: <code>pair-pee
object.</code>
</p>
</div>
</div>
<div id="outline-container-org09da186" class="outline-6">
<h6 id="org09da186">Exclamation Marks: Destructive Operations</h6>
<div class="outline-text-6" id="text-org09da186">
<p>
Affix an exclamation mark to the end of a name for a procedure (or
macro) whose primary purpose is to modify an object.  Such procedures
are called <code>destructive</code>.
</p>

<p>
<b>Examples:</b> set-car! append!
</p>

<p>
Avoid using the exclamation mark willy nilly for just <b>any</b> procedure
whose operation involves any kind of mutation or side effect; instead,
use the exclamation mark to identify procedures that exist <b>solely</b> for
the purpose of destructive update (e.g., <code>SET-CAR!</code>), or to distinguish a
destructive, or potentially destructive (in the case of linear-update
operations such as <code>APPEND!</code>), variant of a procedure of which there also
exists a purely functional variant (e.g., <code>APPEND</code>).
</p>

<p>
Pronounce the exclamation mark as <code>bang</code>.  For example, to read the
fragment <code>(APPEND! LIST TAIL)</code> aloud, say: <code>append-bang list tail</code>.
</p>
</div>
</div>
<div id="outline-container-orgc832aa8" class="outline-6">
<h6 id="orgc832aa8">Asterisks: Variants, Internal Routines, Mutable Globals</h6>
<div class="outline-text-6" id="text-orgc832aa8">
<p>
Affix an asterisk to the end of a name to make a variation on a theme
of the original name.
</p>

<p>
<b>Example:</b> <code>let -&gt; let*</code>
</p>

<p>
Prefer a meaningful name over an asterisk; the asterisk does not
explain what variation on the theme the name means.
</p>

<p>
Affix an asterisk to the beginning of a name to make an internal
routine for that name.  Again, prefer a meaningful name over an
asterisk.
</p>

<p>
Affix asterisks to the beginning and end of a globally mutable
variable.  This allows the reader of the program to recognize very
easily that it is badly written!
</p>
</div>
</div>
<div id="outline-container-org3cb414d" class="outline-6">
<h6 id="org3cb414d"><code>WITH-</code> and <code>CALL-WITH-</code>: Dynamic State and Cleanup</h6>
<div class="outline-text-6" id="text-org3cb414d">
<p>
Prefix <code>WITH-</code> to any procedure that establishes dynamic state and
calls a nullary procedure, which should be the last (required)
argument.  The dynamic state should be established for the extent of
the nullary procedure, and should be returned to its original state
after that procedure returns.
</p>

<p>
<b>Examples:</b> <code>with-input-from-file</code> <code>with-output-to-file</code>
</p>

<p>
Exception:  Some systems provide a procedure <code>(WITH-CONTINUATION
  &lt;continuation&gt; &lt;thunk&gt;)</code>, which calls <code>&lt;thunk&gt;</code> in the given
continuation, using that continuation's dynamic state.  If <code>&lt;thunk&gt;</code>
returns, it will return to <code>&lt;continuation&gt;</code>, not to the continuation of
the call to <code>WITH-CONTINUATION</code>.  This is acceptable.
</p>

<p>
Prefix <code>CALL-WITH-</code> to any procedure that calls a procedure, which
should be its last argument, with some arguments, and is either somehow
dependent upon the dynamic state or continuation of the program, or
will perform some action to clean up data after the procedure argument
returns.  Generally, <code>CALL-WITH-</code> procedures should return the values
that the procedure argument returns, after performing the cleaning
action.
</p>

<p>
<b>Examples:</b>
</p>

<ul class="org-ul">
<li><code>CALL-WITH-INPUT-FILE</code> and <code>CALL-WITH-OUTPUT-FILE</code> both accept a
pathname and a procedure as an argument, open that pathname (for
input or output, respectively), and call the procedure with one
argument, a port corresponding with the file named by the given
pathname.  After the procedure returns, <code>CALL-WITH-INPUT-FILE</code> and
<code>CALL-WITH-OUTPUT-FILE</code> close the file that they opened, and return
whatever the procedure returned.</li>

<li><code>CALL-WITH-CURRENT-CONTINUATION</code> is dependent on the continuation
with which it was called, and passes as an argument an escape
procedure corresponding with that continuation.</li>

<li><code>CALL-WITH-OUTPUT-STRING</code>, a common but non-standard procedure
definable in terms of <code>OPEN-OUTPUT-STRING</code> and <code>GET-OUTPUT-STRING</code> from
<code>SRFI 6 (Basic String Ports)</code>, calls its procedure argument with an
output port, and returns a string of all of the output written to
that port.  Note that it does not return what the procedure
argument returns, which is an exception to the above rule.</li>
</ul>

<p>
Generally, the distinction between these two classes of procedures is
that <code>CALL-WITH-...</code> procedures should not establish fresh dynamic
state and instead pass explicit arguments to their procedure arguments,
whereas <code>WITH-...</code> should do the opposite and establish dynamic state
while passing zero arguments to their procedure arguments.
</p>
</div>
</div>
</div>
</div>
</div>
<div id="outline-container-org9b75429" class="outline-3">
<h3 id="org9b75429">Comments</h3>
<div class="outline-text-3" id="text-org9b75429">
<p>
Write heading comments with at least four semicolons; see also the
section below titled <code>Outline Headings</code>.
</p>

<p>
Write top-level comments with three semicolons.
</p>

<p>
Write comments on a particular fragment of code before that fragment
and aligned with it, using two semicolons.
</p>

<p>
Write margin comments with one semicolon.
</p>

<p>
The only comments in which omission of a space between the semicolon
and the text is acceptable are margin comments.
</p>

<p>
<b>Examples:</b>
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #7f4f4a;">;;;; </span><span style="color: #7f4f4a;">Frob Grovel
</span>
<span style="color: #7f4f4a;">;;; </span><span style="color: #7f4f4a;">This section of code has some important implications:
</span><span style="color: #7f4f4a;">;;;   </span><span style="color: #7f4f4a;">1. Foo.
</span><span style="color: #7f4f4a;">;;;   </span><span style="color: #7f4f4a;">2. Bar.
</span><span style="color: #7f4f4a;">;;;   </span><span style="color: #7f4f4a;">3. Baz.
</span>
<span style="color: #446844;">(</span><span style="color: #3232cc;">define</span><span style="color: #3232cc;"> (</span><span style="color: #661966;">fnord</span><span style="color: #661966;"> zarquon</span><span style="color: #3232cc;">)</span>
  <span style="color: #4f984f9895e4;">;; </span><span style="color: #4f984f9895e4;">If zob, then veeblefitz.
</span><span style="color: #4f984f9895e4;">  </span><span style="color: #3232cc;">(</span><span style="color: #661966;">quux zot
        mumble             </span><span style="color: #4af227cc4af2;">;</span><span style="color: #4af227cc4af2;">Zibblefrotz.
</span><span style="color: #4af227cc4af2;">        </span><span style="color: #661966;">frotz</span><span style="color: #3232cc;">)</span><span style="color: #446844;">)</span>
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-orgc6892a7" class="outline-2">
<h2 id="orgc6892a7">Riastradh's Non-Standard Rules</h2>
<div class="outline-text-2" id="text-orgc6892a7">
<p>
Three principles guide this style, roughly ordered according to
descending importance:
</p>

<ol class="org-ol">
<li>The purpose of a program is to describe an idea, and not the way
that the idea must be realized; the intent of the program's meaning,
rather than peripheral details that are irrelevant to its intent,
should be the focus of the program, <b>irrespective</b> of whether a
human or a machine is reading it.  [It would be nice to express this
principle more concisely.]</li>

<li>The sum of the parts is easier to understand than the whole.</li>

<li>Aesthetics matters.  No one enjoys reading an ugly program.</li>
</ol>
</div>
<div id="outline-container-orgc17db83" class="outline-3">
<h3 id="orgc17db83">General Layout</h3>
<div class="outline-text-3" id="text-orgc17db83">
<p>
This section contains rules that the author has found generally helpful
in keeping his programs clean and presentable, though they are not
especially philosophically interesting.
</p>

<p>
Contained in the rationale for some of the following rules are
references to historical limitations of terminals and printers, which
are now considered aging cruft of no further relevance to today's
computers.  Such references are made only to explain specific measures
chosen for some of the rules, such as a limit of eighty columns per
line, or sixty-six lines per page.  There is a real reason for each of
the rules, and this real reason is not intrinsically related to the
historical measures, which are mentioned only for the sake of
providing some arbitrary measure for the limit.
</p>
</div>
<div id="outline-container-org6e6180e" class="outline-4">
<h4 id="org6e6180e">File Length</h4>
<div class="outline-text-4" id="text-org6e6180e">
<p>
If a file exceeds five hundred twelve lines, begin to consider
splitting it into multiple files.  Do not write program files that
exceed one thousand twenty-four lines.  Write a concise but
descriptive title at the top of each file, and include no content in
the file that is unrelated to its title.
</p>

<p>
<b>Rationale:</b>  Files that are any larger should generally be factored
  into smaller parts.  (One thousand twenty-four is a nicer number than
  one thousand.)  Identifying the purpose of the file helps to break it
  into parts if necessary and to ensure that nothing unrelated is
  included accidentally.
</p>
</div>
</div>
<div id="outline-container-orge4e5613" class="outline-4">
<h4 id="orge4e5613">Top-Level Form Length</h4>
<div class="outline-text-4" id="text-orge4e5613">
<p>
Do not write top-level forms that exceed twenty-one lines, except for
top-level forms that serve only the purpose of listing large sets of
data.  If a procedure exceeds this length, split it apart and give
names to its parts.  Avoid names formed simply by appending a number
to the original procedure's name; give meaningful names to the parts.
</p>

<p>
<b>Rationale:</b>  Top-level forms, especially procedure definitions, that
  exceed this length usually combine too many concepts under one name.
  Readers of the code are likely to more easily understand the code if
  it is composed of separately named parts.  Simply appending a number
  to the original procedure's name can help only the letter of the
  rule, not the spirit, however, even if the procedure was taken from a
  standard algorithm description.  Using comments to mark the code with
  its corresponding place in the algorithm's description is acceptable,
  but the algorithm should be split up in meaningful fragments anyway.
</p>

<p>
Rationale for the number twenty-one:  Twenty-one lines, at a maximum
of eighty columns per line, fits in a GNU Emacs instance running in a
24x80 terminal.  Although the terminal may have twenty-four lines,
three of the lines are occupied by GNU Emacs: one for the menu bar
(which the author of this guide never uses, but which occupies a line
nevertheless in a vanilla GNU Emacs installation), one for the mode
line, and one for the minibuffer's window.  The writer of some code
may not be limited to such a terminal, but the author of this style
guide often finds it helpful to have at least four such terminals or
Emacs windows open simultaneously, spread across a twelve-inch laptop
screen, to view multiple code fragments.
</p>
</div>
</div>
<div id="outline-container-org1b3483d" class="outline-4">
<h4 id="org1b3483d">Line Length</h4>
<div class="outline-text-4" id="text-org1b3483d">
<p>
Do not write lines that exceed eighty columns, or if possible
seventy-two.
</p>

<p>
<b>Rationale:</b>  Following multiple lines that span more columns is
  difficult for humans, who must remember the line of focus and scan
  right to left from the end of the previous line to the beginning of
  the next line; the more columns there are, the harder this is to do.
  Sticking to a fixed limit helps to improve readability.
</p>

<p>
Rationale for the numbers eighty and seventy-two:  It is true that we
have very wide screens these days, and we are no longer limited to
eighty-column terminals; however, we ought to exploit our wide
screens not by writing long lines, but by viewing multiple fragments
of code in parallel, something that the author of this guide does
very often.  Seventy-two columns leave room for several nested layers
of quotation in email messages before the code reaches eighty
columns.  Also, a fixed column limit yields nicer printed output,
especially in conjunction with pagination; see the section
<code>Pagination</code> below.
</p>
</div>
</div>
<div id="outline-container-org8fcc63d" class="outline-4">
<h4 id="org8fcc63d">Blank Lines</h4>
<div class="outline-text-4" id="text-org8fcc63d">
<p>
Separate each adjacent top-level form with a single blank line (i.e.
two line breaks).  If two blank lines seem more appropriate, break the
page instead.  Do not place blank lines in the middle of a procedure
body, except to separate internal definitions; if there is a blank
line for any other reason, split the top-level form up into multiple
ones.
</p>

<p>
<b>Rationale:</b>  More than one blank line is distracting and sloppy.  If
  the two concepts that are separated by multiple blank lines are
  really so distinct that such a wide separator is warranted, then
  they are probably better placed on separate pages anyway; see the
  next section, <code>Pagination</code>.
</p>
</div>
</div>
<div id="outline-container-org62d8edf" class="outline-4">
<h4 id="org62d8edf">Pagination</h4>
<div class="outline-text-4" id="text-org62d8edf">
<p>
Separate each file into pages of no more than sixty-six lines and no
fewer than forty lines with form feeds (ASCII <code>#x0C</code>, or <code>^L</code>, written in
Emacs with <code>C-q C-l</code>), on either side of which is a single line break
(but not a blank line).
</p>

<p>
<b>Rationale:</b>  Keeping distinct concepts laid out on separate pages
  helps to keep them straight.  This is helpful not only for the
  writer of the code, but also for the reader.  It also allows readers
  of the code to print it onto paper without fiddling with printer
  settings to permit pages of more than sixty-six lines (which is the
  default number for many printers), and pagination also makes the
  code easier to navigate in Emacs, with the <code>C-x [</code> and <code>C-x ]</code> keys
  (<code>backward-page</code> and <code>forward-page</code>, respectively).  To avoid
  excessively small increments of page-by-page navigation, and to
  avoid wasting paper, each page should generally exceed forty lines.
</p>

<p>
<code>C-x l</code> in Emacs will report the number of lines in the page on which
the point lies; this is useful for finding where pagination is
necessary.
</p>
</div>
</div>
<div id="outline-container-org59c39d0" class="outline-4">
<h4 id="org59c39d0">Outline Headings</h4>
<div class="outline-text-4" id="text-org59c39d0">
<p>
Use Emacs's Outline Mode to give titles to the pages, and if
appropriate a hierarchical structure.  Set <code>outline-regexp</code> (or
<code>outline-pattern</code> in Edwin) to <code>"\f\n;;;;+ "</code>, so that each form feed
followed by an line break followed by at least four semicolons and a
space indicates an outline heading to Emacs.  Use four semicolons for
the highest level of headings in the hierarchy, and one more for each
successively nested level of hierarchy.
</p>

<p>
<b>Rationale:</b>  Not only does this clarify the organization of the code,
  but readers of the code can then navigate the code's structure with
  Outline Mode commands such as <code>C-c C-f</code>, <code>C-c C-b</code>, <code>C-c C-u</code>, and
  <code>C-c C-d</code> (forward, backward, up, down, respectively, headings).
</p>
</div>
</div>
<div id="outline-container-org3226e42" class="outline-4">
<h4 id="org3226e42">Dependencies</h4>
<div class="outline-text-4" id="text-org3226e42">
<p>
When writing a file or module, minimize its dependencies.  If there are
too many dependencies, consider breaking the module up into several
parts, and writing another module that is the sum of the parts and that
depends only on the parts, not their dependencies.
</p>

<p>
<b>Rationale:</b>  A fragment of a program with fewer dependencies is less
  of a burden on the reader's cognition.  The reader can more easily
  understand the fragment in isolation; humans are very good at local
  analyses, and terrible at global ones.
</p>
</div>
</div>
</div>
<div id="outline-container-org30cbd21" class="outline-3">
<h3 id="org30cbd21">Naming</h3>
<div class="outline-text-3" id="text-org30cbd21">
<p>
This section requires an elaborate philosophical discussion which the
author is too ill to have the energy to write at this moment.
</p>

<p>
Compose concise but meaningful names.  Do not cheat by abbreviating
words or using contractions.
</p>

<p>
<b>Rationale:</b>  Abbreviating words in names does not make them shorter;
  it only makes them occupy less screen space.  The reader still must
  understand the whole long name.  This does not mean, however, that
  names should necessarily be long; they should be descriptive.  Some
  long names are more descriptive than some short names, but there are
  also descriptive names that are not long and long names that are not
  descriptive.  Here is an example of a long name that is not
  descriptive, from SchMUSE, a multi-user simulation environment
  written in MIT Scheme:
</p>

<p>
<code>frisk-descriptor-recursive-subexpr-descender-for-frisk-descr-env</code>
</p>

<p>
Not only is it long (sixty-four characters) and completely
impenetrable, but halfway through its author decided to abbreviate
some words as well!
</p>

<p>
Do not write single-letter variable names.  Give local variables
meaningful names composed from complete English words.
</p>

<p>
<b>Rationale:</b>  It is tempting to reason that local variables are
  invisible to other code, so it is OK to be messy with their names.
  This is faulty reasoning: although the next person to come along and
  use a library may not care about anything but the top-level
  definitions that it exports, this is not the only audience of the
  code.  Someone will also want to read the code later on, and if it is
  full of impenetrably terse variable names without meaning, that
  someone will have a hard time reading the code.
</p>

<p>
Give names to intermediate values where their expressions do not
adequately describe them.
</p>

<p>
<b>Rationale:</b>  An <code>expression</code> is a term that expresses some value.
  Although a machine needs no higher meaning for this value, and
  although it should be written to be sufficiently clear for a human to
  understand what it means, the expression might mean something more
  than just what it says where it is used.  Consequently, it is helpful
  for humans to see names given to expressions.
</p>

<p>
<b>Example:</b>  A hash table <code>HASH-TABLE</code> maps foos to bars; <code>(HASH-TABLE/GET
  HASH-TABLE FOO #F)</code> expresses the datum that HASH-TABLE maps FOO to,
  but that expression gives the reader no hint of any information
  concerning that datum.  (LET ((BAR (HASH-TABLE/GET HASH-TABLE FOO
  #F))) &#x2026;)  gives a helpful name for the reader to understand the
  code without having to find the definition of HASH-TABLE.
</p>

<p>
Index variables such as i and j, or variables such as A and D naming
the car and cdr of a pair, are acceptable only if they are completely
unambiguous in the scope.  For example,
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #446844;">(</span><span style="color: #3232cc;">do</span><span style="color: #3232cc;"> (</span><span style="color: #661966;">(</span><span style="color: #684454;">i 0 (</span><span style="color: #446844;">+ i 1</span><span style="color: #684454;">)</span><span style="color: #661966;">)</span><span style="color: #3232cc;">)</span>
    <span style="color: #3232cc;">(</span><span style="color: #661966;">(</span><span style="color: #684454;">= i (</span><span style="color: #446844;">vector-length vector</span><span style="color: #684454;">)</span><span style="color: #661966;">)</span><span style="color: #3232cc;">)</span>
  <span style="color: #3232cc;">(</span><span style="color: #661966;">frobnicate (</span><span style="color: #684454;">vector-ref vector i</span><span style="color: #661966;">)</span><span style="color: #3232cc;">)</span><span style="color: #446844;">)</span>
</pre>
</div>

<p>
is acceptable because the scope of i is very clearly limited to a
single vector.  However, if more vectors are involved, using more
index variables such as j and k will obscure the program further.
</p>

<p>
Avoid functional combinators, or, worse, the point-free (or
<code>point-less</code>) style of code that is popular in the Haskell world.  At
most, use function composition only where the composition of functions
is the crux of the idea being expressed, rather than simply a procedure
that happens to be a composition of two others.
</p>

<p>
<b>Rationale:</b>  Tempting as it may be to recognize patterns that can be
  structured as combinations of functional combinators &#x2013; say, <code>compose
  this procedure with the projection of the second argument of that
  other one</code>, or <code>(COMPOSE FOO (PROJECT 2 BAR))</code> &#x2013;, the reader of the
  code must subsequently examine the elaborate structure that has been
  built up to obscure the underlying purpose.  The previous fragment
  could have been written <code>(LAMBDA (A B) (FOO (BAR B)))</code>, which is in
  fact shorter, and which tells the reader directly what argument is
  being passed on to what, and what argument is being ignored, without
  forcing the reader to search for the definitions of FOO and BAR or
  the call site of the final composition.  The explicit fragment
  contains substantially more information when intermediate values are
  named, which is very helpful for understanding it and especially for
  modifying it later on.
</p>

<p>
The screen space that can be potentially saved by using functional
combinators is made up for by the cognitive effort on the part of the
reader.  The reader should not be asked to search globally for usage
sites in order to understand a local fragment.  Only if the structure
of the composition really is central to the point of the narrative
should it be written as such.  For example, in a symbolic integrator
or differentiator, composition is an important concept, but in most
code the structure of the composition is completely irrelevant to the
real point of the code.
</p>

<p>
If a parameter is ignored, give it a meaningful name nevertheless and
say that it is ignored; do not simply call it <code>ignored</code>.
</p>

<p>
In Common Lisp, variables can be ignored with <code>(DECLARE (IGNORE ...))</code>.
Some Scheme systems have similar declarations, but the portable way to
ignore variables is just to write them in a command context, where
their values will be discarded, preferably with a comment indicating
this purpose:
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #446844;">(</span><span style="color: #3232cc;">define</span><span style="color: #3232cc;"> (</span><span style="color: #661966;">foo</span><span style="color: #661966;"> x y z</span><span style="color: #3232cc;">)</span>
  <span style="color: #3232cc;">x z                         </span><span style="color: #4f984f9895e4;">;</span><span style="color: #4f984f9895e4;">ignore
</span><span style="color: #4f984f9895e4;">  </span><span style="color: #3232cc;">(</span><span style="color: #661966;">frobnitz y</span><span style="color: #3232cc;">)</span><span style="color: #446844;">)</span>
</pre>
</div>

<p>
<b>Rationale:</b>  As with using functional combinators to hide names,
  avoiding meaningful names for ignored parameters only obscures the
  purpose of the program.  It is helpful for a reader to understand
  what parameters a procedure is independent of, or if someone wishes
  to change the procedure later on, it is helpful to know what other
  parameters are available.  If the ignored parameters were named
  meaninglessly, then these people would be forced to search for call
  sites of the procedure in order to get a rough idea of what
  parameters might be passed here.
</p>

<p>
When naming top-level bindings, assume namespace partitions unless in a
context where they are certain to be absent.  Do not write explicit
namespace prefixes, such as <code>FOO:BAR</code> for an operation <code>BAR</code> in a module
FOO, unless the names will be used in a context known not to have any
kind of namespace partitions.
</p>

<p>
<b>Rationale:</b>  Explicit namespace prefixes are ugly, and lengthen names
  without adding much semantic content.  Common Lisp has its package
  system to separate the namespaces of symbols; most Schemes have
  mechanisms to do so as well, even if the RnRS do not specify any.  It
  is better to write clear names which can be disambiguated if
  necessary, rather than to write names that assume some kind of
  disambiguation to be necessary to begin with.  Furthermore, explicit
  namespace prefixes are inadequate to cover name clashes anyway:
  someone else might choose the same namespace prefix.  Relegating this
  issue to a module system removes it from the content of the program,
  where it is uninteresting.
</p>
</div>
</div>
<div id="outline-container-orgee71481" class="outline-3">
<h3 id="orgee71481">Comments</h3>
<div class="outline-text-3" id="text-orgee71481">
<p>
Write comments only where the code is incapable of explaining itself.
Prefer self-explanatory code over explanatory comments.  Avoid
<code>literate programming</code> like the plague.
</p>

<p>
<b>Rationale:</b>  If the code is often incapable of explaining itself, then
  perhaps it should be written in a more expressive language.  This may
  mean using a different programming language altogether, or, since we
  are talking about Lisp, it may mean simply building a combinator
  language or a macro language for the purpose.  <code>Literate programming</code>
  is the logical conclusion of languages incapable of explaining
  themselves; it is a direct concession of the inexpressiveness of the
  computer language implementing the program, to the extent that the
  only way a human can understand the program is by having it rewritten
  in a human language.
</p>

<p>
Do not write interface documentation in the comments for the
implementation of the interface.  Explain the interface at the top of
the file if it is a single-file library, or put that documentation in
another file altogether.  (See the <code>Documentation</code> section below if the
interface documentation comments grow too large for a file.)
</p>

<p>
<b>Rationale:</b>  A reader who is interested only in the interface really
  should not need to read through the implementation to pick out its
  interface; by putting the interface documentation at the top, not
  only is such a reader's task of identifying the interface made
  easier, but the implementation code can be more liberally commented
  without fear of distracting this reader.  To a reader who is
  interested in the implementation as well, the interface is still
  useful in order to understand what concepts the implementation is
  implementing.
</p>

<p>
<b>Example:</b> <a href="http://mumble.net/~campbell/scheme/skip-list.scm">http://mumble.net/~campbell/scheme/skip-list.scm</a>
</p>

<p>
In this example of a single-file library implementing the skip list
data structure, the first page explains the purpose and dependencies
of the file (which are useful for anyone who intends to use it, even
though dependencies are really implementation details), and the next
few pages explain the usage of skip lists as implemented in that
file.  On the first page of implementation, <code>Skip List Structure</code>,
there are some comments of interest only to a reader who wishes to
understand the implementation; the same goes for the rest of the
file, none of which must a reader read whose interest is only in the
usage of the library.
</p>

<p>
Avoid block comments (i.e. <code>#| ... |#)</code>.  Use S-expression comments (<code>#;</code>
in Scheme, with the expression to comment on the next line; <code>#+(OR)</code> or
<code>#-(AND)</code> in Common Lisp) to comment out whole expressions.  Use blocks
of line comments for text.
</p>

<p>
<b>Rationale:</b>  Editor support for block comments is weak, because it
  requires keeping a detailed intermediate parse state of the whole
  buffer, which most Emacsen do not do.  At the very least, <code>#|| ... ||#</code>
  is better, because most Emacsen will see vertical bars as symbol
  delimiters, and lose trying to read a very, very long symbol, if they
  try to parse #| &#x2026; |#, whereas they will just see two empty symbols
  and otherwise innocuous text between them if they try to parse <code>#||
  ... ||#</code>.  In any case, in Emacs, <code>M-x comment-region RET</code>, or <code>M-;
  (comment-dwim)</code>, is trivial to type.
</p>

<p>
The only standard comments in Scheme are line comments.  There are
SRFIs for block comments and S-expression comments, but support for
them varies from system to system.  Expression comments are not hard
for editors to deal with because it is safe not to deal with them at
all; however, in Scheme S-expression comments, which are written by
prefixing an expression with <code>#;</code>, the expression to be commented
should be placed on the next line.  This is because editors that do
not deal with them at all may see the semicolon as the start of a
line comment, which will throw them off.  Expression comments in
Common Lisp, however, are always safe.
</p>

<p>
In Common Lisp, the two read-time conditionals that are guaranteed to
ignore any form following them are <code>#+(OR)</code> and <code>#-(AND)</code>.  <code>#+NIL</code>
is sometimes used in their stead, but, while it may appear to be an
obviously false conditional, it actually is not.  The feature
expressions are read in the <code>KEYWORD</code> package, so <code>NIL</code> is read not as
<code>CL:NIL</code>, i.e. the boolean false value, but as <code>:NIL</code>, a keyword symbol
whose name happens to be <code>NIL</code>.  Not only is it not read as the
boolean false value, but it has historically been used to indicate a
feature that might be enabled &#x2013; in JonL White's New Implementation
of Lisp!  However, the New Implementation of Lisp is rather old these
days, and unlikely to matter much&#x2026;until Alastair Bridgewater writes
Nyef's Implementation of Lisp.
</p>
</div>
</div>
<div id="outline-container-org5aa2dd9" class="outline-3">
<h3 id="org5aa2dd9">Documentation</h3>
<div class="outline-text-3" id="text-org5aa2dd9">
<p>
On-line references and documentation/manuals are both useful for
independent purposes, but there is a very fine distinction between
them.  Do not generate documentation or manuals automatically from the
text of on-line references.
</p>

<p>
<b>Rationale:</b> <i>On-line references</i> are quick blurbs associated with
  objects in a running Lisp image, such as documentation strings in
  Common Lisp or Emacs Lisp.  These assume that the reader is familiar
  with the gist of the surrounding context, but unclear on details;
  on-line references specify the details of individual objects.
</p>

<p>
<i>Documentation</i> and <i>manuals</i> are fuller, organized, and cohesive
documents that explain the surrounding context to readers who are
unfamiliar with it.  A reader should be able to pick a manual up and
begin reading it at some definite point, perusing it linearly to
acquire an understanding of the subject.  Although manuals may be
dominated by reference sections, they should still have sections that
are linearly readable to acquaint the reader with context.
</p>
</div>
</div>
<div id="outline-container-org153ddc4" class="outline-3">
<h3 id="org153ddc4">Round and Square Brackets</h3>
<div class="outline-text-3" id="text-org153ddc4">
<p>
Some implementations of Scheme provide a non-standard extension of the
lexical syntax whereby balanced pairs of square brackets are
semantically indistinguishable from balanced pairs of round brackets.
Do not use this extension.
</p>

<p>
<b>Rationale:</b>  Because this is a non-standard extension, it creates
  inherently non-portable code, of a nature much worse than using a
  name in the program which is not defined by the R5RS.  The reason
  that we have distinct typographical symbols in the first place is to
  express different meaning.  The only distinction between round
  brackets and square brackets is in convention, but the precise nature
  of the convention is not specified by proponents of square brackets,
  who suggest that they be used for <code>clauses</code>, or for forms that are
  parts of enclosing forms.  This would lead to such constructions as
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #446844;">(</span><span style="color: #3232cc;">let</span><span style="color: #3232cc;"> [</span><span style="color: #661966;">(</span><span style="color: #684454;">x 5</span><span style="color: #661966;">)</span> <span style="color: #661966;">(</span><span style="color: #684454;">y 3</span><span style="color: #661966;">)</span><span style="color: #3232cc;">]</span> <span style="color: #3232cc;">...</span><span style="color: #446844;">)</span>
</pre>
</div>

<p>
<b>or</b>
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #446844;">(</span><span style="color: #3232cc;">let</span><span style="color: #3232cc;"> (</span><span style="color: #661966;">[</span><span style="color: #684454;">x 5</span><span style="color: #661966;">]</span> <span style="color: #661966;">[</span><span style="color: #684454;">y 3</span><span style="color: #661966;">]</span><span style="color: #3232cc;">)</span> <span style="color: #3232cc;">...</span><span style="color: #446844;">)</span>
</pre>
</div>

<p>
<b>or</b>
</p>

<div class="org-src-container">
<pre class="src src-scheme"><span style="color: #446844;">(</span><span style="color: #3232cc;">let</span><span style="color: #3232cc;"> [</span><span style="color: #661966;">[</span><span style="color: #684454;">x 5</span><span style="color: #661966;">]</span> <span style="color: #661966;">[</span><span style="color: #684454;">y 3</span><span style="color: #661966;">]</span><span style="color: #3232cc;">]</span> <span style="color: #3232cc;">...</span><span style="color: #446844;">),</span>
</pre>
</div>

<p>
the first two of which the author of this guide has seen both of, and
the last of which does nothing to help to distinguish the parentheses
anyway.
</p>

<p>
The reader of the code should not be forced to stumble over a
semantic identity because it is expressed by a syntactic distinction.
The reader's focus should not be directed toward the lexical tokens;
it should be directed toward the structure, but using square brackets
draws the reader's attention unnecessarily to the lexical tokens.
</p>
</div>
</div>
</div>
<div id="outline-container-org2ed85b0" class="outline-2">
<h2 id="org2ed85b0">Attribution</h2>
<div class="outline-text-2" id="text-org2ed85b0">
<p>
The following fragment of HTML/RDF/XML was generated by the Creative
Commons license chooser <a href="https://creativecommons.org/choose">https://creativecommons.org/choose</a> on
2011-05-07.  See the question <code>How do I properly attribute a Creative
Commons licensed work?</code> at <a href="http://creativecommons.org/FAQ">http://creativecommons.org/FAQ</a> for more
information about attribution.
</p>

<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">
<img alt="Creative Commons License" style="border-width:0"
src="http://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png" />
</a>
<br />
<span xmlns:dct="http://purl.org/dc/terms/"
href="http://purl.org/dc/dcmitype/Text"
property="dct:title" rel="dct:type">
Riastradh's Lisp Style Rules
</span>
by
<a xmlns:cc="http://creativecommons.org/ns#"
href="http://mumble.net/~campbell/scheme/style.txt"
property="cc:attributionName" rel="cc:attributionURL">
Taylor R. Campbell
</a>
is licensed under a
<a rel="license" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">
Creative Commons Attribution-NonCommercial-ShareAlike 3.0 Unported License
</a>.
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Created: 2025-12-23 Tue 15:29</p>
</div>
</body>
</html>
